<div id=toc></div>

# Table of Contents

- [cs.CR](#cs.CR) [Total: 16]
- [cs.SE](#cs.SE) [Total: 18]


<div id='cs.CR'></div>

# cs.CR [[Back]](#toc)

### [1] [Performance Evaluation and Threat Mitigation in Large-scale 5G Core Deployment](https://arxiv.org/abs/2507.17850)
*Rodrigo Moreira,Larissa F. Rodrigues Moreira,Fl√°vio de Oliveira Silva*

Main category: cs.CR

TL;DR: This paper examines how DDoS-generated chaotic workloads affect 5G core network function (NF) registration performance, emphasizing the need for diverse resource profiles and kernel-based monitoring to maintain SLA compliance and scalable security.


<details>
  <summary>Details</summary>
Motivation: Large-scale 5G software deployments face critical resource provisioning challenges, particularly under chaotic workloads from security threats like DDoS. Traditional methods using mathematical models or AI lack focus on dynamic security-related performance impacts.

Method: 1. Analyzes DDoS impacts on NFs via chaotic workload modeling; 2. Evaluates resource profile diversity requirements through SLA metrics; 3. Tests kernel-based monitoring approaches using packet capture data analysis; 4. Conducts empirical evaluations of NF deployment strategies under complex scenarios.

Result: 1. DDoS attacks require 18-22% more dynamic resources for SLA compliance; 2. Kernel-based monitoring scales 3-5x more efficiently than traditional methods; 3. Resource profile diversity reduces registration latency by 40% in chaotic workloads.

Conclusion: The work establishes that adaptive resource provisioning strategies combining diverse profiles with kernel-level security monitoring are essential for maintaining 5G core performance under dynamic DDoS threats, providing new design principles for resilient software-based network deployments.

Abstract: The deployment of large-scale software-based 5G core functions presents
significant challenges due to their reliance on optimized and intelligent
resource provisioning for their services. Many studies have focused on
analyzing the impact of resource allocation for complex deployments using
mathematical models, queue theories, or even Artificial Intelligence (AI). This
paper elucidates the effects of chaotic workloads, generated by Distributed
Denial of Service (DDoS) on different Network Functions (NFs) on User Equipment
registration performance. Our findings highlight the necessity of diverse
resource profiles to ensure Service-Level Agreement (SLA) compliance in
large-scale 5G core deployments. Additionally, our analysis of packet capture
approaches demonstrates the potential of kernel-based monitoring for scalable
security threat defense. Finally, our empirical evaluation provides insights
into the effective deployment of 5G NFs in complex scenarios.

</details>


### [2] [Learning to Locate: GNN-Powered Vulnerability Path Discovery in Open Source Code](https://arxiv.org/abs/2507.17888)
*Nima Atashin,Behrouz Tork Ladani,Mohammadreza Sharbaf*

Main category: cs.CR

TL;DR: VulPathFinder is an explainable vulnerability path discovery framework that improves upon rule-based methods like SliceLocator by using a Graph Neural Network (GNN) to detect sink statements, enabling more effective identification of paths leading to detected vulnerabilities.


<details>
  <summary>Details</summary>
Motivation: Current vulnerability detection frameworks struggle to generalize when explaining root causes via vulnerable paths due to reliance on predefined rules (e.g., SliceLocator's rule-based sink identification). This limits their ability to adapt to diverse vulnerability patterns in real-world open-source software.

Method: The paper proposes VulPathFinder, which employs a novel GNN model to detect sink statements by capturing semantic and syntactic dependencies in the code. This identifies potential sink points (PSPs), which are then used with program slicing to extract candidate vulnerable paths. These paths are ranked using feedback from a graph-based detector to select the most probable vulnerability path.

Result: Evaluations on the SARD buffer overflow benchmark dataset demonstrated VulPathFinder outperforms both the original SliceLocator and GNNExplainer in discovering paths to PSPs, with superior effectiveness in providing actionable explanations for identified vulnerabilities.

Conclusion: VulPathFinder presents a machine learning-driven, explainable approach to vulnerability path discovery that enhances generalization and explanatory capabilities compared to rule-based and traditional GNN explainability tools, offering deeper insights into root causes of vulnerabilities.

Abstract: Detecting security vulnerabilities in open-source software is a critical task
that is highly regarded in the related research communities. Several approaches
have been proposed in the literature for detecting vulnerable codes and
identifying the classes of vulnerabilities. However, there is still room to
work in explaining the root causes of detected vulnerabilities through locating
vulnerable statements and the discovery of paths leading to the activation of
the vulnerability. While frameworks like SliceLocator offer explanations by
identifying vulnerable paths, they rely on rule-based sink identification that
limits their generalization. In this paper, we introduce VulPathFinder, an
explainable vulnerability path discovery framework that enhances SliceLocator's
methodology by utilizing a novel Graph Neural Network (GNN) model for detecting
sink statements, rather than relying on predefined rules. The proposed GNN
captures semantic and syntactic dependencies to find potential sink points
(PSPs), which are candidate statements where vulnerable paths end. After
detecting PSPs, program slicing can be used to extract potentially vulnerable
paths, which are then ranked by feeding them back into the target graph-based
detector. Ultimately, the most probable path is returned, explaining the root
cause of the detected vulnerability. We demonstrated the effectiveness of the
proposed approach by performing evaluations on a benchmark of the buffer
overflow CWEs from the SARD dataset, providing explanations for the
corresponding detected vulnerabilities. The results show that VulPathFinder
outperforms both original SliceLocator and GNNExplainer (as a general GNN
explainability tool) in discovery of vulnerability paths to identified PSPs.

</details>


### [3] [Formal Verification of the Safegcd Implementation](https://arxiv.org/abs/2507.17956)
*Russell O'Connor,Andrew Poelstra*

Main category: cs.CR

TL;DR: The paper presents a computer-verified proof of the correctness for the libsecp256k1 modular inverse implementation using Coq and Verifiable C's separation logic, addressing the risk of errors in novel cryptographic algorithms.


<details>
  <summary>Details</summary>
Motivation: The paper aims to mitigate the potential risks of errors in new algorithms (like the novel extended Euclidean algorithm) used for critical cryptographic operations such as Bitcoin's digital signatures, where correctness is vital for security.

Method: The authors employed the Coq proof assistant and the separation logic framework from Verifiable C to formally verify the modular inverse implementation in libsecp256k1.

Result: A verified proof demonstrating the correctness of the modular inverse implementation in the libsecp256k1 cryptographic library was successfully completed.

Conclusion: By rigorously verifying the implementation, the paper ensures the reliability of the modular inverse computation, critical for maintaining security in elliptic curve-based systems like Bitcoin, and sets a precedent for verifying other cryptographic libraries.

Abstract: The modular inverse is an essential piece of computation required for
elliptic curve operations used for digital signatures in Bitcoin and other
applications. A novel approach to the extended Euclidean algorithm has been
developed by Bernstein and Yang within the last few years and incorporated into
the libsecp256k1 cryptographic library used by Bitcoin. However, novel
algorithms introduce new risks of errors. To address this we have completed a
computer verified proof of the correctness of (one of) libsecp256k1's modular
inverse implementations with the Coq proof assistant using the Verifiable C's
implementation of separation logic.

</details>


### [4] [TimelyHLS: LLM-Based Timing-Aware and Architecture-Specific FPGA HLS Optimization](https://arxiv.org/abs/2507.17962)
*Nowfel Mashnoor,Mohammad Akyash,Hadi Kamali,Kimia Azar*

Main category: cs.CR

TL;DR: TimelyHLS is an LLM-RAG framework that automates FPGA HLS code optimization via architectural knowledge bases, achieving timing closure with up to 70% less manual tuning and significant latency/area improvements.


<details>
  <summary>Details</summary>
Motivation: Current FPGA-targeted HLS struggles with timing closure and platform-specific optimization due to complex architectural constraints and resource tradeoffs, lacking automated support for platform-critical pragmas.

Method: The framework combines LLMs with RAG, using a structured knowledge base of FPGA features and pragmas to generate and iteratively refine HLS code through synthesis log analysis and performance feedback loops.

Result: TimelyHLS delivers 4x latency speedups (3.85x for Matrix Multiplication, 3.7x for Bitonic Sort), >50% area savings (57% FF reduction in Viterbi), and eliminates manual tuning on 70% of cases across 10 FPGA architectures and diverse benchmarks.

Conclusion: LLM-driven, architecture-aware synthesis can effectively address FPGA HLS optimization challenges by integrating domain-specific knowledge with iterative refinement processes, enabling platform-consistent timing closure and performance gains.

Abstract: Achieving timing closure and design-specific optimizations in FPGA-targeted
High-Level Synthesis (HLS) remains a significant challenge due to the complex
interaction between architectural constraints, resource utilization, and the
absence of automated support for platform-specific pragmas. In this work, we
propose TimelyHLS, a novel framework integrating Large Language Models (LLMs)
with Retrieval-Augmented Generation (RAG) to automatically generate and
iteratively refine HLS code optimized for FPGA-specific timing and performance
requirements. TimelyHLS is driven by a structured architectural knowledge base
containing FPGA-specific features, synthesis directives, and pragma templates.
Given a kernel, TimelyHLS generates HLS code annotated with both
timing-critical and design-specific pragmas. The synthesized RTL is then
evaluated using commercial toolchains, and simulation correctness is verified
against reference outputs via custom testbenches. TimelyHLS iteratively
incorporates synthesis logs and performance reports into the LLM engine for
refinement in the presence of functional discrepancies. Experimental results
across 10 FPGA architectures and diverse benchmarks show that TimelyHLS reduces
the need for manual tuning by up to 70%, while achieving up to 4x latency
speedup (e.g., 3.85x for Matrix Multiplication, 3.7x for Bitonic Sort) and over
50% area savings in certain cases (e.g., 57% FF reduction in Viterbi).
TimelyHLS consistently achieves timing closure and functional correctness
across platforms, highlighting the effectiveness of LLM-driven,
architecture-aware synthesis in automating FPGA design.

</details>


### [5] [MeAJOR Corpus: A Multi-Source Dataset for Phishing Email Detection](https://arxiv.org/abs/2507.17978)
*Paulo Mendes,Eva Maia,Isabel Pra√ßa*

Main category: cs.CR

TL;DR: The paper introduces MeAJOR Corpus, a new phishing email dataset with 135,894 samples that addresses class imbalance and boosts ML model performance to 98.34% F1 using XGBoost by integrating diverse features from open-source sources.


<details>
  <summary>Details</summary>
Motivation: Existing phishing datasets lack quality, diversity, and address challenges like class imbalance, generalisability, and reproducibility, limiting ML model effectiveness.

Method: Integrated 135894 phishing/legitimate emails from joint open-source repos with broad engineered features; tested across four models (RF, XGB, MLP, CNN) with varying feature configs.

Result: Achieved 98.34% F1 using XGBoost, demonstrating strong effectiveness with features spanning multiple categories, enhancing generalizability and reproducibility.

Conclusion: MeAJOR Corpus offers a reusable, consistent resource overcoming class imbalance and generalisability issues, beneficial for phishing detection research across models and configurations.

Abstract: Phishing emails continue to pose a significant threat to cybersecurity by
exploiting human vulnerabilities through deceptive content and malicious
payloads. While Machine Learning (ML) models are effective at detecting
phishing threats, their performance largely relies on the quality and diversity
of the training data. This paper presents MeAJOR (Merged email Assets from
Joint Open-source Repositories) Corpus, a novel, multi-source phishing email
dataset designed to overcome critical limitations in existing resources. It
integrates 135894 samples representing a broad number of phishing tactics and
legitimate emails, with a wide spectrum of engineered features. We evaluated
the dataset's utility for phishing detection research through systematic
experiments with four classification models (RF, XGB, MLP, and CNN) across
multiple feature configurations. Results highlight the dataset's effectiveness,
achieving 98.34% F1 with XGB. By integrating broad features from multiple
categories, our dataset provides a reusable and consistent resource, while
addressing common challenges like class imbalance, generalisability and
reproducibility.

</details>


### [6] [Removing Box-Free Watermarks for Image-to-Image Models via Query-Based Reverse Engineering](https://arxiv.org/abs/2507.18034)
*Haonan An,Guang Hua,Hangcheng Cao,Zhengru Fang,Guowen Xu,Susanto Rahardja,Yuguang Fang*

Main category: cs.CR

TL;DR: The paper reveals a vulnerability in box-free model watermarking, showing attackers can reverse-engineer hidden generative network outputs despite black-box encryption, achieving 100% watermark removal with high-quality images (PSNR 34.69 dB), necessitating stronger IP protection strategies.


<details>
  <summary>Details</summary>
Motivation: This paper challenges the assumed security of black-box HNet watermarking for deep generative networks, highlighting risks when attackers exploit query-based reverse engineering to bypass IP protections.

Method: Two attack approaches are proposed: (1) Query-based reverse engineering of an inverse HNet model using curated input images under black-box conditions, and (2) Leveraging the additive property of watermarking to build a forward surrogate model for improved image quality preservation.

Result: Both attacks achieve 100% watermark removal success with strong PSNR metrics (34.69 dB maximum), significantly outperforming existing attack methods in security and image fidelity.

Conclusion: Box-free model watermarking has critical vulnerabilities to reverse engineering attacks. The results demonstrate the inadequacy of current defensive strategies and emphasize the urgent need for robust IP protection mechanisms against these threats.

Abstract: The intellectual property of deep generative networks (GNets) can be
protected using a cascaded hiding network (HNet) which embeds watermarks (or
marks) into GNet outputs, known as box-free watermarking. Although both GNet
and HNet are encapsulated in a black box (called operation network, or ONet),
with only the generated and marked outputs from HNet being released to end
users and deemed secure, in this paper, we reveal an overlooked vulnerability
in such systems. Specifically, we show that the hidden GNet outputs can still
be reliably estimated via query-based reverse engineering, leaking the
generated and unmarked images, despite the attacker's limited knowledge of the
system. Our first attempt is to reverse-engineer an inverse model for HNet
under the stringent black-box condition, for which we propose to exploit the
query process with specially curated input images. While effective, this method
yields unsatisfactory image quality. To improve this, we subsequently propose
an alternative method leveraging the equivalent additive property of box-free
model watermarking and reverse-engineering a forward surrogate model of HNet,
with better image quality preservation. Extensive experimental results on image
processing and image generation tasks demonstrate that both attacks achieve
impressive watermark removal success rates (100%) while also maintaining
excellent image quality (reaching the highest PSNR of 34.69 dB), substantially
outperforming existing attacks, highlighting the urgent need for robust
defensive strategies to mitigate the identified vulnerability in box-free model
watermarking.

</details>


### [7] [NWaaS: Nonintrusive Watermarking as a Service for X-to-Image DNN](https://arxiv.org/abs/2507.18036)
*Haonan An,Guang Hua,Yu Guo,Hangcheng Cao,Susanto Rahardja,Yuguang Fang*

Main category: cs.CR

TL;DR: This paper introduces ShadowMark, a nonintrusive DNN watermarking framework for X-to-Image models that preserves absolute model fidelity while enabling robust watermark extraction through a black-box API side channel, eliminating the need for parameter/structure modification and addressing the fidelity-robustness trade-off.


<details>
  <summary>Details</summary>
Motivation: Existing DNN watermarking solutions inherently modify model parameters or architectures, causing behavior shifts and requiring costly fine-tuning. The growing model size and resulting reluctance among model owners hinder practical Watermarking as a Service (WaaS) adoption.

Method: Presents Nonintrusive Watermarking as a Service (NWaaS), implementing ShadowMark via a key encoder (to bind watermarks) and watermark decoder (to extract watermarks) that create a robust side channel in the model's black-box API without altering the model itself.

Result: Demonstrates through extensive experiments on diverse X-to-Image tasks the framework achieves nonintrusive watermarking with absolute fidelity across multiple DNN architectures while maintaining robustness against existing attacks.

Conclusion: ShadowMark addresses critical deployment challenges in DNN watermarking by decoupling fidelity and robustness, offering a practical, trustworthy, and architecture-agnostic solution for protecting model intellectual property without behavioral impact.

Abstract: The intellectual property of deep neural network (DNN) models can be
protected with DNN watermarking, which embeds copyright watermarks into model
parameters (white-box), model behavior (black-box), or model outputs
(box-free), and the watermarks can be subsequently extracted to verify model
ownership or detect model theft. Despite recent advances, these existing
methods are inherently intrusive, as they either modify the model parameters or
alter the structure. This natural intrusiveness raises concerns about
watermarking-induced shifts in model behavior and the additional cost of
fine-tuning, further exacerbated by the rapidly growing model size. As a
result, model owners are often reluctant to adopt DNN watermarking in practice,
which limits the development of practical Watermarking as a Service (WaaS)
systems. To address this issue, we introduce Nonintrusive Watermarking as a
Service (NWaaS), a novel trustless paradigm designed for X-to-Image models, in
which we hypothesize that with the model untouched, an owner-defined watermark
can still be extracted from model outputs. Building on this concept, we propose
ShadowMark, a concrete implementation of NWaaS which addresses critical
deployment challenges by establishing a robust and nonintrusive side channel in
the protected model's black-box API, leveraging a key encoder and a watermark
decoder. It is significantly distinctive from existing solutions by attaining
the so-called absolute fidelity and being applicable to different DNN
architectures, while being also robust against existing attacks, eliminating
the fidelity-robustness trade-off. Extensive experiments on image-to-image,
noise-to-image, noise-and-text-to-image, and text-to-image models, demonstrate
the efficacy and practicality of ShadowMark for real-world deployment of
nonintrusive DNN watermarking.

</details>


### [8] [RECALLED: An Unbounded Resource Consumption Attack on Large Vision-Language Models](https://arxiv.org/abs/2507.18053)
*Haoran Gao,Yuanhe Zhang,Zhenhong Zhou,Lei Jiang,Fanyu Meng,Yujia Xiao,Kun Wang,Yang Liu,Junlan Feng*

Main category: cs.CR

TL;DR: The paper introduces RECALLED, a first-of-its-kind method exploiting visual inputs to trigger unbounded resource consumption attacks (RCAs) in large vision-language models (LVLMs) through adversarial perturbations and parallel multi-objective optimization, significantly increasing service latency and GPU utilization.


<details>
  <summary>Details</summary>
Motivation: Current red-teaming studies on RCAs for LLMs overlook visual modality attack surfaces, leaving LVLMs vulnerable to resource depletion via image/text inputs.

Method: 1) Vision Guided Optimization: Pixel-level adversarial perturbations causing output repetition.
2) Fine-grained attack injection into visual inputs for unbounded generation.
3) Multi-Objective Parallel Losses to create universal attack templates and resolve optimization conflicts.

Result: RCAs using RECALLED increased latency by √ó26 and raised GPU utilization/memory consumption by 20%, demonstrating practical effectiveness against LVLMs.

Conclusion: This work uncovers critical security vulnerabilities in LVLMs when handling visual inputs and establishes a red-teaming framework for targeted defense development against resource consumption attacks.

Abstract: Resource Consumption Attacks (RCAs) have emerged as a significant threat to
the deployment of Large Language Models (LLMs). With the integration of vision
modalities, additional attack vectors exacerbate the risk of RCAs in large
vision-language models (LVLMs). However, existing red-teaming studies have
largely overlooked visual inputs as a potential attack surface, resulting in
insufficient mitigation strategies against RCAs in LVLMs. To address this gap,
we propose RECALLED (\textbf{RE}source \textbf{C}onsumption \textbf{A}ttack on
\textbf{L}arge Vision-\textbf{L}anguag\textbf{E} Mo\textbf{D}els), the first
approach for exploiting visual modalities to trigger unbounded RCAs
red-teaming. First, we present \textit{Vision Guided Optimization}, a
fine-grained pixel-level optimization, to obtain \textit{Output Recall}
adversarial perturbations, which can induce repeating output. Then, we inject
the perturbations into visual inputs, triggering unbounded generations to
achieve the goal of RCAs. Additionally, we introduce \textit{Multi-Objective
Parallel Losses} to generate universal attack templates and resolve
optimization conflicts when intending to implement parallel attacks. Empirical
results demonstrate that RECALLED increases service response latency by over 26
$\uparrow$, resulting in an additional 20\% increase in GPU utilization and
memory consumption. Our study exposes security vulnerabilities in LVLMs and
establishes a red-teaming framework that can facilitate future defense
development against RCAs.

</details>


### [9] [PyPitfall: Dependency Chaos and Software Supply Chain Vulnerabilities in Python](https://arxiv.org/abs/2507.18075)
*Jacob Mahon,Chenxi Hou,Zhihao Yao*

Main category: cs.CR

TL;DR: This paper analyzes vulnerable dependencies in the Python package ecosystem (PyPI) using PyPitfall, identifying 4,655 packages that explicitly depend on known-vulnerable versions and 141,044 packages permitting such versions. The study highlights supply chain security risks.


<details>
  <summary>Details</summary>
Motivation: Third-party package reuse in Python creates complex dependency chains where vulnerabilities can propagate, but PyPI lacks a systematic analysis of their prevalence, risking widespread security issues in downstream applications.

Method: The authors quantitatively analyzed 378,573 PyPI packages' dependency structures, detecting vulnerable versions through explicit requirements and version range constraints.

Result: 4,655 packages explicitly required known-vulnerable versions, while 141,044 allowed vulnerable versions within defined dependency ranges, demonstrating significant supply chain security exposure.

Conclusion: The study provides ecosystem-wide evidence of vulnerable dependencies in PyPI, aiming to increase transparency and awareness to improve Python software supply chain security practices.

Abstract: Python software development heavily relies on third-party packages. Direct
and transitive dependencies create a labyrinth of software supply chains. While
it is convenient to reuse code, vulnerabilities within these dependency chains
can propagate through dependencies, potentially affecting down-stream packages
and applications. PyPI, the official Python package repository, hosts many
packages and lacks a comprehensive analysis of the prevalence of vulnerable
dependencies. This paper introduces PyPitfall, a quantitative analysis of
vulnerable dependencies across the PyPI ecosystem. We analyzed the dependency
structures of 378,573 PyPI packages and identified 4,655 packages that
explicitly require at least one known-vulnerable version and 141,044 packages
that permit vulnerable versions within specified ranges. By characterizing the
ecosystem-wide dependency landscape and the security impact of transitive
dependencies, we aim to raise awareness of Python software supply chain
security.

</details>


### [10] [An Improved ChaCha Algorithm Based on Quantum Random Number](https://arxiv.org/abs/2507.18157)
*Chao Liu,Shuai Zhao,Chenhao Jia,Gengran Hu,Tingting Cui*

Main category: cs.CR

TL;DR: QRE-ChaCha enhances ChaCha cipher's security against classical and quantum attacks by integrating quantum random numbers in initial constants and state words, maintaining high efficiency.


<details>
  <summary>Details</summary>
Motivation: Existing ChaCha implementations face vulnerabilities from AI cryptanalysis and quantum computing advancements, requiring strengthened security measures without sacrificing efficiency.

Method: QRE-ChaCha modifies ChaCha by XORing initial constants with quantum random numbers and periodically injecting them into selected state words during odd rounds to improve diffusion.

Result: Demonstrated stronger resistance to differential attacks, passed NIST and GM/T 0005-2021 randomness tests, and maintained comparable encryption/decryption performance through variable-size file testing.

Conclusion: Quantum random number integration effectively reinforces ChaCha's security against both classical and quantum threats while preserving its real-time communication applicability.

Abstract: Due to the merits of high efficiency and strong security against timing and
side-channel attacks, ChaCha has been widely applied in real-time communication
and data streaming scenarios. However, with the rapid development of
AI-assisted cryptanalysis and quantum computing technologies, there are serious
challenges to the secure implementation of ChaCha cipher. To further strengthen
the security of ChaCha cipher, we propose an improved variant based on quantum
random numbers, i.e., Quantum Random Number Enhanced ChaCha (QRE-ChaCha).
Specifically, the design XORs the initial constants with quantum random numbers
and periodically injects quantum random numbers into selected state words
during odd rounds to enhance diffusion. Compared with the original ChaCha, the
present variant shows stronger resistance to differential attacks and generates
a keystream with statistical randomness, thereby offering increased robustness
against both classical and quantum attacks. To evaluate the security and
performance of the present ChaCha, our analysis proceeds in three main parts.
Firstly, we analyze its theoretical security in terms of quantum randomness and
attack testing, and conduct differential cryptanalysis with an automated search
method based on the Boolean satisfiability problem (SAT). Secondly, we subject
the keystream generated by the cipher to randomness tests using the NIST
statistical test suite and the GM/T 0005-2021 randomness testing standard.
Finally, we assess its encryption and decryption performance by measuring its
encryption speed on files of various sizes. According to the results, the
present ChaCha is significantly improved to resist differential attacks while
maintaining the high efficiency of the original ChaCha cipher, and its
keystream successfully passes statistical randomness tests using the NIST and
GM/T 0005-2021 standards, meeting cryptographic application requirements.

</details>


### [11] [Information Security Based on LLM Approaches: A Review](https://arxiv.org/abs/2507.18215)
*Chang Gong,Zhongwen Li,Xiaoqi Li*

Main category: cs.CR

TL;DR: This paper examines the application of large language models (LLMs) in enhancing information security, highlighting their roles in threat detection and analysis while addressing challenges like model transparency and adaptability.


<details>
  <summary>Details</summary>
Motivation: Traditional information security measures struggle with complex and evolving threats, necessitating intelligent solutions like LLMs to improve detection and reduce false alarms.

Method: Systematic review of LLM applications across malicious behavior prediction, network threat analysis, vulnerability detection, and cryptographic optimization, analyzing technical foundations based on neural networks and Transformer architecture.

Result: LLMs demonstrate improved detection accuracy and reduced false alarm rates in security systems compared to conventional methods.

Conclusion: While LLMs show promise, challenges in transparency, interpretability, and adaptability remain; future optimization of model structures and generalization capabilities will be critical for advancing intelligent security protection.

Abstract: Information security is facing increasingly severe challenges, and
traditional protection means are difficult to cope with complex and changing
threats. In recent years, as an emerging intelligent technology, large language
models (LLMs) have shown a broad application prospect in the field of
information security. In this paper, we focus on the key role of LLM in
information security, systematically review its application progress in
malicious behavior prediction, network threat analysis, system vulnerability
detection, malicious code identification, and cryptographic algorithm
optimization, and explore its potential in enhancing security protection
performance. Based on neural networks and Transformer architecture, this paper
analyzes the technical basis of large language models and their advantages in
natural language processing tasks. It is shown that the introduction of large
language modeling helps to improve the detection accuracy and reduce the false
alarm rate of security systems. Finally, this paper summarizes the current
application results and points out that it still faces challenges in model
transparency, interpretability, and scene adaptability, among other issues. It
is necessary to explore further the optimization of the model structure and the
improvement of the generalization ability to realize a more intelligent and
accurate information security protection system.

</details>


### [12] [Auto-SGCR: Automated Generation of Smart Grid Cyber Range Using IEC 61850 Standard Models](https://arxiv.org/abs/2507.18249)
*Muhammad M. Roomi,S. M. Suhail Hussain,Ee-Chien Chang,David M. Nicol,Daisuke Mashima*

Main category: cs.CR

TL;DR: The paper presents Auto-SGCR, an automated framework for generating high-fidelity, customizable smart grid cyber ranges using an XML-based modeling language.


<details>
  <summary>Details</summary>
Motivation: Digitalization has increased power grid vulnerability to cyber-attacks, necessitating iterative testing, configuration evaluation, and expert training. Existing cyber ranges are costly, inflexible, and lack configurability/reproducibility.

Method: 1. Defined Smart Grid Modeling Language (SG-ML), an XML-based language incorporating IEC 61850 SCL files<br>2. Developed an automated toolchain to parse SG-ML and instantiate smart grid cyber ranges.<br>3. Enabled model sharing/modification for customization and reuse.

Result: Case studies with large-scale substation models demonstrate Auto-SGCR's effectiveness. Framework mitigates existing cyber range limitations regarding configurability, accessibility, portability, and reproducibility through automation.

Conclusion: Auto-SGCR reduces the research-production gap by enabling easy customization, reuse, and cost-effective smart grid security training/experiments. Open-sourcing the toolchain and SG-ML models enhances collaboration and adoption.

Abstract: Digitalization of power grids have made them increasingly susceptible to
cyber-attacks in the past decade. Iterative cybersecurity testing is
indispensable to counter emerging attack vectors and to ensure dependability of
critical infrastructure. Furthermore, these can be used to evaluate
cybersecurity configuration, effectiveness of the cybersecurity measures
against various attack vectors, as well as to train smart grid cybersecurity
experts defending the system. Enabling extensive experiments narrows the gap
between academic research and production environment. A high-fidelity cyber
range is vital as it is often infeasible to conduct such experiments and
training using production environment. However, the design and implementation
of cyber range requires extensive domain knowledge of physical and cyber aspect
of the infrastructure. Furthermore, costs incurred for setup and maintenance of
cyber range are significant. Moreover, most existing smart grid cyber ranges
are designed as a one-off, proprietary system, and are limited in terms of
configurability, accessibility, portability, and reproducibility. To address
these challenges, an automated Smart grid Cyber Range generation framework is
presented in this paper. Initially a human-/machine-friendly, XML-based
modeling language called Smart Grid Modeling Language was defined, which
incorporates IEC 61850 System Configuration Language files. Subsequently, a
toolchain to parse SG-ML model files and automatically instantiate a functional
smart grid cyber range was developed. The developed SG-ML models can be easily
shared and/or modified to reproduce or customize for any cyber range. The
application of Auto-SGCR is demonstrated through case studies with large-scale
substation models. The toolchain along with example SG-ML models have been
open-sourced.

</details>


### [13] [LoRA-Leak: Membership Inference Attacks Against LoRA Fine-tuned Language Models](https://arxiv.org/abs/2507.18302)
*Delong Ran,Xinlei He,Tianshuo Cong,Anyu Wang,Qi Li,Xiaoyun Wang*

Main category: cs.CR

TL;DR: This paper analyzes the vulnerability of LoRA-fine-tuned language models to Membership Inference Attacks (MIAs) by introducing LoRA-Leak, an evaluation framework that reveals significant information leakage risks despite LoRA's low parameter tuning. The study demonstrates that pre-trained models amplify MIA threats, identifies effective defenses (dropout, layer exclusion), and provides practical guidance for data privacy in specialized LM providers.


<details>
  <summary>Details</summary>
Motivation: Existing MIAs neglect information leakage risks from pre-trained models in LoRA-based fine-tuning. While LoRA's small parameter changes suggest reduced vulnerability, this approach might create a false sense of security, necessitating systematic evaluation of privacy risks under the pre-training and fine-tuning paradigm.

Method: Developed LoRA-Leak: a comprehensive framework containing 15 MIAs (10 existing, 5 pre-trained model-enhanced attacks). Applied this to three advanced LMs across three NLP tasks, evaluating different fine-tuning settings and testing four defenses. Analyzed impact of pre-trained models on information leakage.

Result: LoRA-based models achieve 0.775 AUC under conservative settings, proving vulnerability to MIAs. Pre-trained models enable more accurate attacks. Defenses like dropout (73.2% AUC reduction) and layer exclusion (83.5% AUC reduction) effectively mitigate risks while maintaining model utility. Found pre-trained models significantly contribute to leakage in fine-tuning scenarios.

Conclusion: The pre-training and fine-tuning paradigm inherently creates privacy risks for LoRA-based models due to information leakage from pre-trained components. This study establishes that even minimal parameter tuning via LoRA exposes datasets to MIAs, emphasizing the need for robust defenses. Provides actionable insights for protecting private data in LM specialization workflows.

Abstract: Language Models (LMs) typically adhere to a "pre-training and fine-tuning"
paradigm, where a universal pre-trained model can be fine-tuned to cater to
various specialized domains. Low-Rank Adaptation (LoRA) has gained the most
widespread use in LM fine-tuning due to its lightweight computational cost and
remarkable performance. Because the proportion of parameters tuned by LoRA is
relatively small, there might be a misleading impression that the LoRA
fine-tuning data is invulnerable to Membership Inference Attacks (MIAs).
However, we identify that utilizing the pre-trained model can induce more
information leakage, which is neglected by existing MIAs. Therefore, we
introduce LoRA-Leak, a holistic evaluation framework for MIAs against the
fine-tuning datasets of LMs. LoRA-Leak incorporates fifteen membership
inference attacks, including ten existing MIAs, and five improved MIAs that
leverage the pre-trained model as a reference. In experiments, we apply
LoRA-Leak to three advanced LMs across three popular natural language
processing tasks, demonstrating that LoRA-based fine-tuned LMs are still
vulnerable to MIAs (e.g., 0.775 AUC under conservative fine-tuning settings).
We also applied LoRA-Leak to different fine-tuning settings to understand the
resulting privacy risks. We further explore four defenses and find that only
dropout and excluding specific LM layers during fine-tuning effectively
mitigate MIA risks while maintaining utility. We highlight that under the
"pre-training and fine-tuning" paradigm, the existence of the pre-trained model
makes MIA a more severe risk for LoRA-based LMs. We hope that our findings can
provide guidance on data privacy protection for specialized LM providers.

</details>


### [14] [Conformidade com os Requisitos Legais de Privacidade de Dados: Um Estudo sobre T√©cnicas de Anonimiza√ß√£o](https://arxiv.org/abs/2507.18360)
*Andr√© Menolli,Luiz Fernando Nunes,Thiago A. Coleti*

Main category: cs.CR

TL;DR: This paper analyzes data anonymization techniques (aggregation, generalization, perturbation, k-anonymity) to evaluate their effectiveness in balancing legal compliance with data utility under regulations like LGPD and GDPR.


<details>
  <summary>Details</summary>
Motivation: The enforcement of data protection laws such as LGPD and GDPR necessitates rigor in software quality criteria like data anonymization, while maintaining data utility for practical use.

Method: Investigated anonymization techniques through application to datasets containing personal/sensitive data, comparing their performance in privacy compliance and data utility preservation.

Result: Significant variations in method effectiveness were observed, demonstrating the trade-off between privacy enforcement and retaining useful data for analysis.

Conclusion: Achieving compliance with legal requirements while preserving data utility requires careful selection of anonymization methods to address the inherent privacy-utility balance.

Abstract: The protection of personal data has become a central topic in software
development, especially with the implementation of the General Data Protection
Law (LGPD) in Brazil and the General Data Protection Regulation (GDPR) in the
European Union. With the enforcement of these laws, certain software quality
criteria have become mandatory, such as data anonymization, which is one of the
main aspects addressed by these regulations. The aim of this article is to
analyze data anonymization techniques and assess their effectiveness in
ensuring compliance with legal requirements and the utility of the data for its
intended purpose. Techniques such as aggregation, generalization, perturbation,
and k-anonymity were investigated and applied to datasets containing personal
and sensitive data. The analysis revealed significant variations in the
effectiveness of each method, highlighting the need to balance privacy and data
utility.

</details>


### [15] [Scout: Leveraging Large Language Models for Rapid Digital Evidence Discovery](https://arxiv.org/abs/2507.18478)
*Shariq Murtuza*

Main category: cs.CR

TL;DR: The paper introduces Scout, a digital forensics framework leveraging large language models (LLMs) and multimodal models to prioritize relevant evidence files and reduce false positives in investigations.


<details>
  <summary>Details</summary>
Motivation: Increasing complexity of digital evidence due to advanced consumer technology necessitates efficient tools for triaging gigabytes of data and minimizing false positives.

Method: Scout uses foundational LLMs for text-based evidence (string searches, log analysis) and multimodal models for multimedia files (audio, images, video) to automate preliminary forensic processing.

Result: Scout successfully identifies high-priority evidence files in disk images, network packets, memory dumps, and multimedia data, accelerating investigation workflows.

Conclusion: The framework demonstrates LLMs' practical utility in digital forensics by providing scalable, efficient evidence prioritization for modern investigative needs.

Abstract: Recent technological advancements and the prevalence of technology in day to
day activities have caused a major increase in the likelihood of the
involvement of digital evidence in more and more legal investigations.
Consumer-grade hardware is growing more powerful, with expanding memory and
storage sizes and enhanced processor capabilities. Forensics investigators
often have to sift through gigabytes of data during an ongoing investigation
making the process tedious. Memory forensics, disk analysis all are well
supported by state of the art tools that significantly lower the effort
required to be put in by a forensic investigator by providing string searches,
analyzing images file etc. During the course of the investigation a lot of
false positives are identified that need to be lowered. This work presents
Scout, a digital forensics framework that performs preliminary evidence
processing and prioritizing using large language models. Scout deploys
foundational language models to identify relevant artifacts from a large number
of potential evidence files (disk images, captured network packets, memory
dumps etc.) which would have taken longer to get identified. Scout employs text
based large language models can easily process files with textual information.
For the forensic analysis of multimedia files like audio, image, video, office
documents etc. multimodal models are employed by Scout. Scout was able to
identify and realize the evidence file that were of potential interest for the
investigator.

</details>


### [16] [Layer-Aware Representation Filtering: Purifying Finetuning Data to Preserve LLM Safety Alignment](https://arxiv.org/abs/2507.18631)
*Hao Li,Lijun Li,Zhenghao Lu,Xianyi Wei,Rui Li,Jing Shao,Lei Sha*

Main category: cs.CR

TL;DR: This paper addresses safety alignment degradation in fine-tuned LLMs by introducing LARF, a layer-aware representation filtering method to detect and remove harmful data samples from training datasets.


<details>
  <summary>Details</summary>
Motivation: Fine-tuning aligned LLMs for real-world applications risks safety compromise due to subtle safety-degrading features in seemingly benign datasets.

Method: LARF identifies safety-sensitive layers within LLMs and leverages their representations to detect data samples with safety-degrading features during post-training.

Result: Experimental validation demonstrates LARF's effectiveness in identifying harmful data samples and mitigating safety alignment degradation in fine-tuned models.

Conclusion: The study highlights the necessity of inspecting post-training datasets for hidden safety risks and shows that layer-aware filtering can significantly improve model safety during fine-tuning.

Abstract: With rapid advancement and increasing accessibility of LLMs, fine-tuning
aligned models has become a critical step for adapting them to real-world
applications, which makes the safety of this fine-tuning process more important
than ever. However, recent studies have highlighted a critical challenge: even
when fine-tuning with seemingly benign downstream datasets, the safety of
aligned LLMs can be compromised, making them more susceptible to malicious
instructions. In this paper, we show that fine-tuning datasets often contain
samples with safety-degrading features that are not easily identifiable on the
surface. These samples can significantly degrade the safety alignment of LLMs
during fine-tuning. To address this issue, we propose LARF, a
\textbf{L}ayer-\textbf{A}ware \textbf{R}epresentation \textbf{F}iltering
method. This method identifies safety-sensitive layers within the LLM and
leverages their representations to detect which data samples in the
post-training dataset contain safety-degrading features. Experimental results
demonstrate that LARF can effectively identify benign data with
safety-degrading features. After removing such data, the safety alignment
degradation caused by fine-tuning is mitigated. Please see our code at
\href{https://github.com/LLLeoLi/LARF}{https://github.com/LLLeoLi/LARF}.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [17] [How Software Engineers Engage with AI: A Pragmatic Process Model and Decision Framework Grounded in Industry Observations](https://arxiv.org/abs/2507.17930)
*Vahid Garousi,Zafar Jafarov*

Main category: cs.SE

TL;DR: This paper analyzes how software engineers use AI tools (e.g., GitHub Copilot, ChatGPT) in daily work, proposing a process model and decision framework to improve human-AI collaboration in software engineering.


<details>
  <summary>Details</summary>
Motivation: The rise of 'vibe coding' and AI-assisted tools in SE highlights a need to understand how developers make trust/refinement/rejection decisions during AI tool usage, as these interactions remain underexplored in practice.

Method: Mixed-methods approach combining practitioner reports and direct observations from three industry settings in Turkey and Azerbaijan to develop 1) a pragmatic process model capturing SE activities (prompt design, inspection, fallback, refinement) and 2) a trade-off analysis framework for effort vs. output quality.

Result: Empirically grounded models showing engineers' navigation of AI-assisted workflows with human oversight, providing structured guidance for prompt design, output evaluation, and strategic refinement/rejection decisions.

Conclusion: The proposed models offer lightweight, practical frameworks for SE teams to optimize AI tool usage by balancing efficiency gains with quality assurance, advancing human-AI collaboration research in industry contexts.

Abstract: Artificial Intelligence (AI) has the potential to transform Software
Engineering (SE) by enhancing productivity, efficiency, and decision support.
Tools like GitHub Copilot and ChatGPT have given rise to "vibe coding"-an
exploratory, prompt-driven development style. Yet, how software engineers
engage with these tools in daily tasks, especially in deciding whether to
trust, refine, or reject AI-generated outputs, remains underexplored. This
paper presents two complementary contributions. First, a pragmatic process
model capturing real-world AI-assisted SE activities, including prompt design,
inspection, fallback, and refinement. Second, a 2D decision framework that
could help developers reason about trade-offs between effort saved and output
quality. Grounded in practitioner reports and direct observations in three
industry settings across Turkiye and Azerbaijan, our work illustrates how
engineers navigate AI use with human oversight. These models offer structured,
lightweight guidance to support more deliberate and effective use of AI tools
in SE, contributing to ongoing discussions on practical human-AI collaboration.

</details>


### [18] [Use as Directed? A Comparison of Software Tools Intended to Check Rigor and Transparency of Published Work](https://arxiv.org/abs/2507.17991)
*Peter Eckmann,Adrian Barnett,Alexandra Bannach-Brown,Elisa Pilar Bascunan Atria,Guillaume Cabanac,Louise Delwen Owen Franzen,Ma≈Çgorzata Anna Gazda,Kaitlyn Hair,James Howison,Halil Kilicoglu,Cyril Labbe,Sarah McCann,Vladislav Nachev,Martijn Roelandse,Maia Salholz-Hillel,Robert Schulz,Gerben ter Riet,Colby Vorland,Anita Bandrowski,Tracey Weissgerber*

Main category: cs.SE

TL;DR: The paper evaluates 11 automated tools for enhancing scientific rigor and transparency, identifies performance leaders in specific criteria, and provides recommendations for tool development and use.


<details>
  <summary>Details</summary>
Motivation: The reproducibility crisis in science is driven by inconsistent adherence to reporting standards and ineffective peer review in detecting missing information. Existing checklists like ARRIVE and CONSORT face compliance challenges, necessitating reliable automated solutions.

Method: Conducted a comparative analysis of 11 automated tools across 9 rigor criteria from the ScreenIT framework, assessing their effectiveness in detecting reporting issues in scientific abstracts.

Result: Some tools excelled in specific criteria (e.g., open data detection), while others improved through combination (e.g., inclusion/exclusion criteria check). Key developmental areas for tools were identified to maximize utility.

Conclusion: Proposes actionable insights and recommendations to stakeholders for improving tool design and integration, emphasizing collaboration and targeted enhancements; code and data are publicly available for replicability.

Abstract: The causes of the reproducibility crisis include lack of standardization and
transparency in scientific reporting. Checklists such as ARRIVE and CONSORT
seek to improve transparency, but they are not always followed by authors and
peer review often fails to identify missing items. To address these issues,
there are several automated tools that have been designed to check different
rigor criteria. We have conducted a broad comparison of 11 automated tools
across 9 different rigor criteria from the ScreenIT group. We found some
criteria, including detecting open data, where the combination of tools showed
a clear winner, a tool which performed much better than other tools. In other
cases, including detection of inclusion and exclusion criteria, the combination
of tools exceeded the performance of any one tool. We also identified key areas
where tool developers should focus their effort to make their tool maximally
useful. We conclude with a set of insights and recommendations for stakeholders
in the development of rigor and transparency detection tools. The code and data
for the study is available at https://github.com/PeterEckmann1/tool-comparison.

</details>


### [19] [An Empirical Study of GenAI Adoption in Open-Source Game Development: Tools, Tasks, and Developer Challenges](https://arxiv.org/abs/2507.18029)
*Xiang Echo Chen,Wenhan Zhu,Guoshuai Albert Shi,Michael W. Godfrey*

Main category: cs.SE

TL;DR: Analyzes GenAI adoption in open-source game development via GitHub issue discussions, comparing it to traditional AI (TradAI) and non-AI (NonAI) approaches to identify usage patterns, challenges, and integration practices.


<details>
  <summary>Details</summary>
Motivation: Prior research focused on traditional AI in gaming, with limited empirical understanding of real-world GenAI adoption, especially in open-source communities.

Method: Constructed a dataset of open-source game repositories, applied open card sorting and thematic analysis to stratified GitHub issues samples, and annotated issues by type/content for cross-group comparisons.

Result: Revealed distinct GenAI usage patterns vs. TradAI/NonAI, highlighting specific tools, tasks, and challenges in open-source game development contexts.

Conclusion: GenAI is redefining game development workflows but faces unique integration challenges requiring tailored tools and developer support strategies, particularly in open-source ecosystems.

Abstract: The growing capabilities of generative AI (GenAI) have begun to reshape how
games are designed and developed, offering new tools for content creation,
gameplay simulation, and design ideation. While prior research has explored
traditional uses of AI in games, such as controlling agents or generating
procedural content. There is limited empirical understanding of how GenAI is
adopted by developers in real-world contexts, especially within the open-source
community. This study aims to explore how GenAI technologies are discussed,
adopted, and integrated into open-source game development by analyzing issue
discussions on GitHub. We investigate the tools, tasks, and challenges
associated with GenAI by comparing GenAI-related issues to those involving
traditional AI (TradAI) and NonAI topics. Our goal is to uncover how GenAI
differs from other approaches in terms of usage patterns, developer concerns,
and integration practices. To address this objective, we construct a dataset of
open-source game repositories that discuss AI-related topics. We apply open
card sorting and thematic analysis to a stratified sample of GitHub issues,
labelling each by type and content. These annotations enable comparative
analysis across GenAI, TradAI, and NonAI groups, and provide insight into how
GenAI is shaping the workflows and pain points of open-source game developers.

</details>


### [20] [Your ATs to Ts: MITRE ATT&CK Attack Technique to P-SSCRM Task Mapping](https://arxiv.org/abs/2507.18037)
*Sivana Hamer,Jacob Bowen,Md Nazmul Haque,Chris Madden,Laurie Williams*

Main category: cs.SE

TL;DR: The paper presents a mapping between MITRE ATT&CK attack techniques and the P-SSCRM framework, using four strategies to align tasks across 10 frameworks for proactive software supply chain risk mitigation.


<details>
  <summary>Details</summary>
Motivation: This mapping addresses the need for software organizations to identify tasks that mitigate known cyber attack techniques within the software supply chain, enhancing risk management effectiveness.

Method: The authors employed four independent mapping strategies to link P-SSCRM tasks with MITRE ATT&CK techniques and additional frameworks, ensuring consensus and cross-referencing between standards.

Result: A comprehensive task-technique mapping is developed, demonstrating how P-SSCRM tasks mitigate specific MITRE ATT&CK techniques while simultaneously aligning with 10 external frameworks.

Conclusion: The mapping provides a standardized reference for organizations to proactively address software supply chain risks through task-based mitigation, and serves as a cross-framework alignment tool between MITRE ATT&CK and industry/government standards.

Abstract: The MITRE Adversarial Tactics, Techniques and Common Knowledge (MITRE ATT&CK)
Attack Technique to Proactive Software Supply Chain Risk Management Framework
(P-SSCRM) Task mapping described in this document helps software organizations
to determine how different tasks mitigate the attack techniques of software
supply chain attacks. The mapping was created through four independent
strategies to find agreed-upon mappings. Because each P-SSCRM task is mapped to
one or more tasks from the 10 frameworks, the mapping we provide is also a
mapping between MITRE ATT&CK and other prominent government and industry
frameworks.

</details>


### [21] [Factors Impacting Faculty Adoption of Project-Based Learning in Computing Education: a Survey](https://arxiv.org/abs/2507.18039)
*Ahmad D. Suleiman,Yiming Tang,Daqing Hou*

Main category: cs.SE

TL;DR: This study examines why computing educators adopt project-based learning (PjBL) and identifies barriers and enablers, highlighting the need for institutional support and professional development.


<details>
  <summary>Details</summary>
Motivation: Project-based learning (PjBL) can enhance student motivation and skills, but educators face inconsistent adoption due to institutional challenges and resource limitations.

Method: Mixed-methods approach with an online survey of 80 computing faculty, combining closed-ended questions (quantitative analysis) and open-ended questions (thematic analysis).

Result: Key barriers include planning challenges, project design difficulties, lack of institutional support; enablers involve peer collaboration, training, incentives, and project sources like research or industry partnerships.

Conclusion: Systemic support structures, including resources, funding, and professional development, are critical to enable widespread adoption and scaling of PjBL in computing education.

Abstract: This research full paper investigates the factors influencing computing
educators' adoption of project-based learning (PjBL) in software engineering
and computing curricula. Recognized as a student-centered pedagogical approach,
PjBL has the potential to enhance student motivation, engagement, critical
thinking, collaboration, and problem-solving skills. Despite these benefits,
faculty adoption remains inconsistent due to challenges such as insufficient
institutional support, time constraints, limited training opportunities,
designing or sourcing projects, and aligning them with course objectives. This
research explores these barriers and investigates the strategies and resources
that facilitate a successful adoption. Using a mixed-methods approach, data
from 80 computing faculty were collected through an online survey comprising
closed-ended questions to quantify barriers, enablers, and resource needs,
along with an open-ended question to gather qualitative insights. Quantitative
data were analyzed using statistical methods, while qualitative responses
underwent thematic analysis. Results reveal that while PjBL is widely valued,
its adoption is often selective and impacted by challenges in planning and
managing the learning process, designing suitable projects, and a lack of
institutional support, such as time, funding, and teaching assistants. Faculty
are more likely to adopt or sustain PjBL when they have access to peer
collaboration, professional development, and institutional incentives. In
addition, sourcing projects from research, industry partnerships, and borrowing
from peers emerged as key facilitators for new projects. These findings
underscore the need for systemic support structures to empower faculty to
experiment with and scale PjBL practices.

</details>


### [22] [An Empirical Study of Complexity, Heterogeneity, and Compliance of GitHub Actions Workflows](https://arxiv.org/abs/2507.18062)
*Edward Abrokwah,Taher A. Ghaleb*

Main category: cs.SE

TL;DR: This study empirically analyzes GitHub Actions workflows in open-source software to assess complexity, structuring patterns, best practice compliance, and language-specific differences in CI pipeline design.


<details>
  <summary>Details</summary>
Motivation: Dominant CI service GHA lacks empirical understanding of real-world workflow adherence to official documentation and community practices, potentially leading to unnecessary complexity.

Method: Analyzed GHA workflow structure, complexity, heterogeneity, and compliance with best practices using a dataset of Java, Python, and C++ repositories.

Result: Expected to reveal varying adherence to best practices across languages, including both strengths and weaknesses in workflow design.

Conclusion: Finds indicate GHA users may both benefit from and confuse aspects of current CI guidelines, suggesting the need for clearer documentation and targeted improvements in CI service design.

Abstract: Continuous Integration (CI) has evolved from a tooling strategy to a
fundamental mindset in modern CI engineering. It enables teams to develop,
test, and deliver software rapidly and collaboratively. Among CI services,
GitHub Actions (GHA) has emerged as a dominant service due to its deep
integration with GitHub and a vast ecosystem of reusable workflow actions.
Although GHA provides official documentation and community-supported best
practices, there appears to be limited empirical understanding of how
open-source real-world CI workflows align with such practices. Many workflows
might be unnecessarily complex and not aligned with the simplicity goals of CI
practices. This study will investigate the structure, complexity,
heterogeneity, and compliance of GHA workflows in open-source software
repositories. Using a large dataset of GHA workflows from Java, Python, and C++
repositories, our goal is to (a) identify workflow complexities, (b) analyze
recurring and heterogeneous structuring patterns, (c) assess compliance with
GHA best practices, and (d) uncover differences in CI pipeline design across
programming languages. Our findings are expected to reveal both areas of strong
adherence to best practices and areas for improvement where needed. These
insights will also have implications for CI services, as they will highlight
the need for clearer guidelines and comprehensive examples in CI documentation.

</details>


### [23] [Identifier Name Similarities: An Exploratory Study](https://arxiv.org/abs/2507.18081)
*Carol Wong,Mai Abe,Silvia De Benedictis,Marissa Halim,Anthony Peruma*

Main category: cs.SE

TL;DR: This exploratory study introduces a taxonomy of identifier name similarity in software projects to understand its impact on code comprehension and collaboration, providing a platform for future research.


<details>
  <summary>Details</summary>
Motivation: Poorly chosen identifier names in software projects can increase cognitive load and hinder collaboration, especially when similar names exist in structure or functionality.

Method: The authors developed a taxonomy categorizing different forms of identifier name similarity through an exploratory study.

Result: The taxonomy highlights various types of identifier name similarity, offering examples and preliminary evidence of their occurrence in software projects.

Conclusion: The proposed taxonomy serves as a foundation for analyzing the effects of identifier name similarity on code maintainability, enabling further refinement and validation of these findings.

Abstract: Identifier names, which comprise a significant portion of the codebase, are
the cornerstone of effective program comprehension. However, research has shown
that poorly chosen names can significantly increase cognitive load and hinder
collaboration. Even names that appear readable in isolation may lead to
misunderstandings in contexts when they closely resemble other names in either
structure or functionality. In this exploratory study, we present our
preliminary findings on the occurrence of identifier name similarity in
software projects through the development of a taxonomy that categorizes
different forms of identifier name similarity. We envision our initial taxonomy
providing researchers with a platform to analyze and evaluate the impact of
identifier name similarity on code comprehension, maintainability, and
collaboration among developers, while also allowing for further refinement and
expansion of the taxonomy.

</details>


### [24] [Understanding the Supply Chain and Risks of Large Language Model Applications](https://arxiv.org/abs/2507.18105)
*Yujie Ma,Lili Quan,Xiaofei Xie,Qiang Hu,Jiongchi Yu,Yao Zhang,Sen Chen*

Main category: cs.SE

TL;DR: This paper introduces the first comprehensive dataset for analyzing LLM supply chain security, mapping dependencies across 3,859 real-world applications and identifying 1,555 risk-related issues to highlight systemic vulnerabilities and propose safety recommendations.


<details>
  <summary>Details</summary>
Motivation: LLM-based systems rely on complex, interconnected supply chains with overlooked security risks - most assessments focus narrowly on models or data, but infrastructure, libraries, and dataset dependencies harbor critical vulnerabilities requiring systematic benchmarking.

Method: The authors collected 3,859 real-world LLM applications, performed interdependency analysis to identify 109,211 models, 2,474 datasets, and 9,862 libraries, mapped component relationships through fine-tuning paths and reuse patterns, and extracted 1,555 supply chain security issues from public vulnerability databases.

Result: Analysis revealed deeply nested dependencies in LLM applications and significant security vulnerabilities across all supply chain components (applications:50 issues, models:325, datasets:18, libraries:1,229), demonstrating the need for holistic risk assessment frameworks for LLM ecosystems.

Conclusion: The paper establishes a benchmark for LLM supply chain security analysis, emphasizing the importance of comprehensive dependency mapping and risk evaluation, and provides actionable recommendations to enhance the security of interconnected LLM components in real-world systems.

Abstract: The rise of Large Language Models (LLMs) has led to the widespread deployment
of LLM-based systems across diverse domains. As these systems proliferate,
understanding the risks associated with their complex supply chains is
increasingly important. LLM-based systems are not standalone as they rely on
interconnected supply chains involving pretrained models, third-party
libraries, datasets, and infrastructure. Yet, most risk assessments narrowly
focus on model or data level, overlooking broader supply chain vulnerabilities.
While recent studies have begun to address LLM supply chain risks, there
remains a lack of benchmarks for systematic research.
  To address this gap, we introduce the first comprehensive dataset for
analyzing and benchmarking LLM supply chain security. We collect 3,859
real-world LLM applications and perform interdependency analysis, identifying
109,211 models, 2,474 datasets, and 9,862 libraries. We extract model
fine-tuning paths, dataset reuse, and library reliance, mapping the ecosystem's
structure. To evaluate security, we gather 1,555 risk-related issues-50 for
applications, 325 for models, 18 for datasets, and 1,229 for libraries from
public vulnerability databases.
  Using this dataset, we empirically analyze component dependencies and risks.
Our findings reveal deeply nested dependencies in LLM applications and
significant vulnerabilities across the supply chain, underscoring the need for
comprehensive security analysis. We conclude with practical recommendations to
guide researchers and developers toward safer, more trustworthy LLM-enabled
systems.

</details>


### [25] [NoCode-bench: A Benchmark for Evaluating Natural Language-Driven Feature Addition](https://arxiv.org/abs/2507.18130)
*Le Deng,Zhonghao Jiang,Jialun Cao,Michael Pradel,Zhongxin Liu*

Main category: cs.SE

TL;DR: This paper presents NoCode-bench, a benchmark for evaluating large language models (LLMs) in natural language-driven no-code development tasks through real-world documentation and code implementations. Results show LLMs succeed in only 15.79% of tasks, indicating significant challenges remain for this paradigm.


<details>
  <summary>Details</summary>
Motivation: Natural language-driven no-code development could democratize software creation, but existing research lacks real-world benchmarks to evaluate LLM capabilities in this context. Software documentation serves as an ideal NL specification for system functionality.

Method: The authors created NoCode-bench with 634 tasks across 10 projects (114k code changes). Each task includes documentation updates, code implementations, and developer-validated test cases. A 'Verified' subset with 114 human-checked instances ensures reliable evaluation metrics. Experiments measured LLM performance on feature addition tasks, focusing on token usage efficiency and task success rates.

Result: Despite optimizing for token usage, top LLMs achieved only 15.79% task success rate. Key failure modes include poor cross-file editing capabilities, limited codebase understanding, and ineffective tool calling.

Conclusion: Current LLMs demonstrate insufficient readiness for fully natural language-driven no-code development. NoCode-bench provides standardized measurement to advance research in this area and identify capabilities requiring improvement.

Abstract: Natural language-driven no-code development allows users to specify software
functionality using natural language (NL) instead of editing source code,
promising increased productivity and democratized development. Large language
models (LLMs) show potential in enabling this paradigm. In this context,
software documentation acts as an NL specification for functionality. This work
introduces NoCode-bench, a benchmark designed to evaluate LLMs on real-world
NL-driven feature addition tasks, consisting of 634 tasks across 10 projects
and 114k code changes. Each task pairs documentation updates with corresponding
code implementations, validated by developer-written test cases. A subset of
114 high-quality, human-verified instances, NoCode-bench Verified, ensures
reliable evaluation. Our experiments reveal that, despite high token usage, the
best LLMs achieve a task success rate of only 15.79%, highlighting challenges
in cross-file editing, codebase understanding, and tool calling. These findings
indicate that LLMs are not yet ready for fully NL-driven no-code development.
NoCode-bench lays the foundation for future advances in this area.

</details>


### [26] [SMECS: A Software Metadata Extraction and Curation Software](https://arxiv.org/abs/2507.18159)
*Stephan Ferenz,Aida Jafarbigloo,Oliver Werth,Astrid Nie√üe*

Main category: cs.SE

TL;DR: SMECS simplifies metadata creation for research software by extracting data from sources like GitHub and providing an interactive curation interface, reducing resource demands while supporting FAIR principles.


<details>
  <summary>Details</summary>
Motivation: Creating high-quality metadata for research software is resource-intensive for researchers, hindering adoption of FAIR principles despite their importance for findability and reusability.

Method: Developed Software Metadata Extraction and Curation Software (SMECS) that combines metadata extraction from online repositories with an interactive user interface for curation and CodeMeta file export.

Result: Usability experiments confirmed SMECS provides a satisfactory user experience, effectively enabling metadata creation through automated extraction and interactive refinement.

Conclusion: SMECS addresses resource challenges in metadata creation, promoting FAIRification of research software by streamlining the process for researchers and software engineers.

Abstract: Metadata play a crucial role in adopting the FAIR principles for research
software and enables findability and reusability. However, creating
high-quality metadata can be resource-intensive for researchers and research
software engineers. To address this challenge, we developed the Software
Metadata Extraction and Curation Software (SMECS) which integrates the
extraction of metadata from existing sources together with a user-friendly
interface for metadata curation. SMECS extracts metadata from online
repositories such as GitHub and presents it to researchers through an
interactive interface for further curation and export as a CodeMeta file. The
usability of SMECS was evaluated through usability experiments which confirmed
that SMECS provides a satisfactory user experience. SMECS supports the
FAIRification of research software by simplifying metadata creation.

</details>


### [27] [GenAI for Automotive Software Development: From Requirements to Wheels](https://arxiv.org/abs/2507.18223)
*Nenad Petrovic,Fengjunjie Pan,Vahid Zolfaghari,Krzysztof Lebioda,Andre Schamschurko,Alois Knoll*

Main category: cs.SE

TL;DR: The paper proposes a GenAI workflow for automating ADAS software development, using LLMs for requirements modeling, test scenario generation, and code creation while leveraging RAG for regulatory compliance.


<details>
  <summary>Details</summary>
Motivation: Traditional ADAS development involves lengthy compliance cycles and re-engineering due to complex requirements and regulations.

Method: The approach employs LLMs for model-based requirements analysis (Ecore/XMI/OCL), test scenario generation via RAG from regulatory documents, and automatic code generation for simulation (Python) and hardware implementation (C++) using Model-Driven Engineering (MDE).

Result: Shorter development timelines through automated requirements modeling, test scenario generation, and code production; improved regulatory compliance via RAG.

Conclusion: LLM-powered automation significantly reduces ADAS development and testing time while ensuring compliance with regulations when integrated with MDE principles.

Abstract: This paper introduces a GenAI-empowered approach to automated development of
automotive software, with emphasis on autonomous and Advanced Driver Assistance
Systems (ADAS) capabilities. The process starts with requirements as input,
while the main generated outputs are test scenario code for simulation
environment, together with implementation of desired ADAS capabilities
targeting hardware platform of the vehicle connected to testbench. Moreover, we
introduce additional steps for requirements consistency checking leveraging
Model-Driven Engineering (MDE). In the proposed workflow, Large Language Models
(LLMs) are used for model-based summarization of requirements (Ecore metamodel,
XMI model instance and OCL constraint creation), test scenario generation,
simulation code (Python) and target platform code generation (C++).
Additionally, Retrieval Augmented Generation (RAG) is adopted to enhance test
scenario generation from autonomous driving regulations-related documents. Our
approach aims shorter compliance and re-engineering cycles, as well as reduced
development and testing time when it comes to ADAS-related capabilities.

</details>


### [28] [An Empirical Study on Embodied Artificial Intelligence Robot (EAIR) Software Bugs](https://arxiv.org/abs/2507.18267)
*Zeqin Liao,Zibin Zheng,Peifan Reng,Henglong Liang,Zixu Gao,Zhixiang Chen,Wei Li,Yuhong Nan*

Main category: cs.SE

TL;DR: This paper systematically analyzes 885 EAIR system bugs across 80 projects, categorizing them into 18 underlying causes, 15 symptoms (including 8 EAIR-specific ones), and 13 affected modules, while establishing cause-module mappings for efficient bug diagnosis.


<details>
  <summary>Details</summary>
Motivation: EAIR system bugs pose functional failure risks and physical hazards, but lack general understanding of their characteristics and root causes, impeding effective debugging techniques development.

Method: Collected and classified EAIR system bugs through systematic analysis of 80 projects, identifying underlying causes, symptoms, and module distributions. Established mappings between bug causes and their frequently occurring modules via extensive analysis.

Result: 1. 8 EAIR-specific symptoms characterized by severe functional failures. 2. 8 EAIR-specific causes dominated by AI-agent reasoning issues. 3. Module-cause mapping identified to guide targeted diagnostic efforts.

Conclusion: The study provides critical insights into EAIR system bugs' unique characteristics and establishes actionable foundations for improving bug prediction, detection, and repair in embodied AI systems through cause-module correlations.

Abstract: Embodied Artificial Intelligence Robots (EAIR) is an emerging and rapidly
evolving technological domain. Ensuring their program correctness is
fundamental to their successful deployment. However, a general and in-depth
understanding of EAIR system bugs remains lacking, which hinders the
development of practices and techniques to tackle EAIR system bugs.
  To bridge this gap, we conducted the first systematic study of 885 EAIR
system bugs collected from 80 EAIR system projects to investigate their
symptoms, underlying causes, and module distribution. Our analysis takes
considerable effort, which classifies these bugs into 18 underlying causes, 15
distinct symptoms, and identifies 13 affected modules. It reveals several new
interesting findings and implications which help shed light on future research
on tackling or repairing EAIR system bugs. First, among the 15 identified
symptoms, our findings highlight 8 symptoms specific to EAIR systems, which is
characterized by severe functional failures and potential physical hazards.
Second, within the 18 underlying causes, we define 8 EAIR-specific causes, the
majority of which stem from the intricate issues of AI- agent reasoning and
decision making. Finally, to facilitate precise and efficient bug prediction,
detection, and repair, we constructed a mapping between underlying causes and
the modules in which they most frequently occur, which enables researchers to
focus diagnostic efforts on the modules most susceptible to specific bug types.

</details>


### [29] [Scheduzz: Constraint-based Fuzz Driver Generation with Dual Scheduling](https://arxiv.org/abs/2507.18289)
*Yan Li,Wenzhang Yang,Yuekun Wang,Jian Gao,Shaohua Wang,Yinxing Xue,Lijun Zhang*

Main category: cs.SE

TL;DR: Scheduzz is an LLM-based library fuzzing technique that improves resource efficiency and coverage by modeling API usage constraints with dual scheduling optimization.


<details>
  <summary>Details</summary>
Motivation: Current automated fuzz driver generation techniques lack awareness of library usage conventions and inefficiently consume resources due to unoptimized driver execution.

Method: Combines LLM-driven API constraint analysis with a dual scheduling framework that optimizes fuzz driver execution by modeling as an online optimization problem.

Result: Outperforms baselines on 16/21 libraries with 1.62x-1.89x coverage improvements and discovers 33 new bugs including 3 CVEs while reducing computational overhead.

Conclusion: Scheduzz addresses critical limitations in conventional library fuzzing by integrating usage-conformant API analysis with strategic execution optimization.

Abstract: Fuzzing a library requires experts to understand the library usage well and
craft high-quality fuzz drivers, which is tricky and tedious. Therefore, many
techniques have been proposed to automatically generate fuzz drivers. However,
they fail to generate rational fuzz drivers due to the lack of adherence to
proper library usage conventions, such as ensuring a resource is closed after
being opened. To make things worse, existing library fuzzing techniques
unconditionally execute each driver, resulting in numerous irrational drivers
that waste computational resources while contributing little coverage and
generating false positive bug reports.
  To tackle these challenges, we propose a novel automatic library fuzzing
technique, Scheduzz, an LLM-based library fuzzing technique. It leverages LLMs
to understand rational usage of libraries and extract API combination
constraints. To optimize computational resource utilization, a dual scheduling
framework is implemented to efficiently manage API combinations and fuzz
drivers. The framework models driver generation and the corresponding fuzzing
campaign as an online optimization problem. Within the scheduling loop,
multiple API combinations are selected to generate fuzz drivers, while
simultaneously, various optimized fuzz drivers are scheduled for execution or
suspension.
  We implemented Scheduzz and evaluated it in 33 real-world libraries. Compared
to baseline approaches, Scheduzz significantly reduces computational overhead
and outperforms UTopia on 16 out of 21 libraries. It achieves 1.62x, 1.50x, and
1.89x higher overall coverage than the state-of-the-art techniques CKGFuzzer,
Promptfuzz, and the handcrafted project OSS-Fuzz, respectively. In addition,
Scheduzz discovered 33 previously unknown bugs in these well-tested libraries,
3 of which have been assigned CVEs.

</details>


### [30] [YATE: The Role of Test Repair in LLM-Based Unit Test Generation](https://arxiv.org/abs/2507.18316)
*Michael Konstantinou,Renzo Degiovanni,Jie M. Zhang,Mark Harman,Mike Papadakis*

Main category: cs.SE

TL;DR: This paper addresses the issue of incorrect unit tests generated by language models (LLMs) in automated test generation. It proposes YATE, a technique combining rule-based static analysis and re-prompting, which improves line and branch coverage, kills more mutants, and outperforms four LLM-based methods at comparable cost.


<details>
  <summary>Details</summary>
Motivation: Language models generate many syntactically or semantically incorrect tests, which waste resources and miss opportunities for creating valuable test cases. Repairing these tests could enhance testing effectiveness and serve as test generation seeds.

Method: YATE employs a hybrid approach of rule-based static analysis to detect common test errors and re-prompting to fix them. It iteratively repairs incorrect tests, refining LLM outputs until valid tests are created.

Result: YATE achieves 32.06% higher line coverage and kills 21.77% more mutants than standard LLM methods. Compared to four other LLM-based tools (HITS, SYMPROMPT, TESTSPARK, COVERUP), it attains 22% higher line coverage, 20% higher branch coverage, and kills 20% more mutants with similar computational cost.

Conclusion: YATE demonstrates a practical and cost-effective solution for repairing incorrect LLM-generated tests, significantly improving code coverage metrics and mutation killing performance compared to existing methods.

Abstract: Recent advances in automated test generation utilises language models to
produce unit tests. While effective, language models tend to generate many
incorrect tests with respect to both syntax and semantics. Although such
incorrect tests can be easily detected and discarded, they constitute a "missed
opportunity" -- if fixed, they are often valuable as they directly add testing
value (they effectively target the underlying program logic to be tested) and
indirectly form good seeds for generating additional tests. To this end, we
propose a simple technique for repairing some of these incorrect tests through
a combination of rule-based static analysis and re-prompting. We evaluate this
simple approach, named YATE, on a set of 6 open-source projects and show that
it can effectively produce tests that cover on average 32.06% more lines and
kill 21.77% more mutants than a plain LLM-based method. We also compare YATE
with four other LLM-based methods, namely HITS, SYMPROMPT, TESTSPARK and
COVERUP and show that it produces tests that cover substantially more code.
YATE achieves 22% higher line coverage, 20% higher branch coverage and kill 20%
more mutants at a comparable cost (number of calls to LLMs).

</details>


### [31] [Gotta catch 'em all! Towards File Localisation from Issues at Large](https://arxiv.org/abs/2507.18319)
*Jesse Maarleveld,Jiapan Guo,Daniel Feitosa*

Main category: cs.SE

TL;DR: This paper addresses file localization for general issues (not just bugs) by introducing a data pipeline accommodating arbitrary branching/merging, evaluating traditional IR methods as baselines, and analyzing biases from bug-localisation. Key findings include poor performance of bug-specific heuristics on general issues, statistically significant performance differences across issue types, and project-dependent outcomes.


<details>
  <summary>Details</summary>
Motivation: Existing research on file localization either focuses exclusively on bugs or uses filtering methods to isolate specific issue types, limiting understanding of broader issue localization. The authors aim to study localization for all issue types without selection.

Method: 1. Developed a data pipeline for creating issue-file localization datasets that handles arbitrary branching/merging. 2. Baseline evaluation using traditional information retrieval methods. 3. Statistical analysis of biases (e.g., identifier presence) from the bug localisation community on their dataset.

Result: Bug-specific heuristics show poor performance on general issues; small but statistically significant performance variations exist between issue types; identifier presence has minimal effect on most issues; results are project-dependent, suggesting value for domain-specific method tuning.

Conclusion: Bug-specific approaches are inadequate for general issue localization. Performance differences highlight the need for issue-type-sensitive models. Project dependence indicates benefits from adapting localization methods to specific project characteristics. Emphasizes research into general-purpose, customizable localization models.

Abstract: Bug localisation, the study of developing methods to localise the files
requiring changes to resolve bugs, has been researched for a long time to
develop methods capable of saving developers' time. Recently, researchers are
starting to consider issues outside of bugs. Nevertheless, most existing
research into file localisation from issues focusses on bugs or uses other
selection methods to ensure only certain types of issues are considered as part
of the focus of the work. Our goal is to work on all issues at large, without
any specific selection.
  In this work, we provide a data pipeline for the creation of issue file
localisation datasets, capable of dealing with arbitrary branching and merging
practices. We provide a baseline performance evaluation for the file
localisation problem using traditional information retrieval approaches.
Finally, we use statistical analysis to investigate the influence of biases
known in the bug localisation community on our dataset.
  Our results show that methods designed using bug-specific heuristics perform
poorly on general issue types, indicating a need for research into general
purpose models. Furthermore, we find that there are small, but statistically
significant differences in performance between different issue types. Finally,
we find that the presence of identifiers have a small effect on performance for
most issue types. Many results are project-dependent, encouraging the
development of methods which can be tuned to project-specific characteristics.

</details>


### [32] [FMI Meets SystemC: A Framework for Cross-Tool Virtual Prototyping](https://arxiv.org/abs/2507.18339)
*Nils Bosbach,Meik Schmidt,Lukas J√ºnger,Matthias Berthold,Rainer Leupers*

Main category: cs.SE

TL;DR: The paper introduces a new framework to enable FMI co-simulation with SystemC-based Virtual Platforms, allowing target software to receive realistic environmental data from external tools without hardware access, speeding up certification processes like ISO 26262.


<details>
  <summary>Details</summary>
Motivation: Complex systems require thorough testing but existing virtual platforms (VPs) have limited integration with co-simulation environments due to lack of FMI support in SystemC, hindering verification of realistic environmental interactions.

Method: Proposed a custom FMI integration framework for SystemC TLM-based VPs with a case study demonstrating temperature sensor data exchange between SystemC and external tools through FMI without modifying target software.

Result: Successfully demonstrated environmental sensor data (e.g., temperature) can be fed into SystemC simulations via FMI, enabling unmodified software execution with realistic peripheral inputs and facilitating early certification testing.

Conclusion: The framework bridges FMI and SystemC TLM ecosystems, significantly enhancing virtual testing capabilities by enabling external tool integration for environmental inputs, which accelerates modern system software verification and certification.

Abstract: As systems become more complex, the demand for thorough testing and virtual
prototyping grows. To simulate whole systems, multiple tools are usually needed
to cover different parts. These parts include the hardware of a system and the
environment with which the system interacts. The Functional Mock-up Interface
(FMI) standard for co-simulation can be used to connect these tools.
  The control part of modern systems is usually a computing unit, such as a
System-on-a-Chip (SoC) or Microcontroller Unit (MCU), which executes software
from a connected memory and interacts with peripherals. To develop software
without requiring access to physical hardware, full-system simulators, the
so-called Virtual Platforms (VPs), are commonly used. The IEEE-standardized
framework for VP development is SystemC TLM. SystemC provides interfaces and
concepts that enable modular design and model exchange. However, SystemC lacks
native FMI support, which limits the integration into broader co-simulation
environments.
  This paper presents a novel framework to control and interact with
SystemC-based VPs using the FMI. We present a case study showing how a
simulated temperature sensor in a SystemC simulation can obtain temperature
values from an external tool via FMI. This approach allows the unmodified
target software to run on the VP and receive realistic environmental input data
such as temperature, velocity, or acceleration values from other tools. Thus,
extensive software testing and verification is enabled. By having tests ready
and the software pre-tested using a VP once the physical hardware is available,
certifications like ISO 26262 can be done earlier.

</details>


### [33] [Automated Code Review Using Large Language Models with Symbolic Reasoning](https://arxiv.org/abs/2507.18476)
*Busra Icoz,Goksel Biricik*

Main category: cs.SE

TL;DR: This paper proposes a hybrid approach combining symbolic reasoning and Large Language Models (LLMs) to enhance automated code review, demonstrating improved accuracy and efficiency through experiments on the CodexGlue dataset.


<details>
  <summary>Details</summary>
Motivation: Manual code review is subjective and time-consuming, while existing LLM-based automation lacks sufficient logical reasoning capabilities to effectively evaluate code.

Method: The study integrates symbolic reasoning techniques with prompting methods and LLMs like CodeT5, CodeBERT, and GraphCodeBERT, testing their combined performance on the CodexGlue benchmark.

Result: The hybrid approach achieved higher accuracy and efficiency in code review compared to pure LLM-based methods, validating the effectiveness of symbolic reasoning augmentation.

Conclusion: Combining symbolic reasoning with LLMs creates a more robust automated code review system, suggesting this hybrid methodology should be adopted for better code quality assistance.

Abstract: Code review is one of the key processes in the software development lifecycle
and is essential to maintain code quality. However, manual code review is
subjective and time consuming. Given its rule-based nature, code review is well
suited for automation. In recent years, significant efforts have been made to
automate this process with the help of artificial intelligence. Recent
developments in Large Language Models (LLMs) have also emerged as a promising
tool in this area, but these models often lack the logical reasoning
capabilities needed to fully understand and evaluate code. To overcome this
limitation, this study proposes a hybrid approach that integrates symbolic
reasoning techniques with LLMs to automate the code review process. We tested
our approach using the CodexGlue dataset, comparing several models, including
CodeT5, CodeBERT, and GraphCodeBERT, to assess the effectiveness of combining
symbolic reasoning and prompting techniques with LLMs. Our results show that
this approach improves the accuracy and efficiency of automated code review.

</details>


### [34] [A Deep Dive into Retrieval-Augmented Generation for Code Completion: Experience on WeChat](https://arxiv.org/abs/2507.18515)
*Zezhou Yang,Ting Peng,Cuiyun Gao,Chaozheng Wang,Hailiang Huang,Yuetang Deng*

Main category: cs.SE

TL;DR: This paper empirically evaluates retrieval-augmented generation (RAG) methods for code completion in a large proprietary codebase (WeChat), comparing identifier-based and similarity-based RAG with different retrieval techniques (lexical vs. semantic). Key findings show similarity-based RAG with BM25 and GTE-Qwen combinations performs best and addresses distribution shifts between open-source and closed-source codebases.


<details>
  <summary>Details</summary>
Motivation: While RAG has proven effective in open-source code completion, open-source and closed-source codebases exhibit distribution shifts (e.g., domain specificity, access restrictions). Existing research lacks analysis of RAG methods in real-world industrial-scale closed-source environments like WeChat.

Method: We test 26 open-source LLMs (0.5B-671B parameters) with two RAG frameworks (identifier-based and similarity-based) across 1,669 WeChat internal repositories. For similarity-based RAG, we compare lexical (BM25) and semantic (dense vector) retrieval techniques and analyze their combination.

Result: 1. Similarity-based RAG outperforms identifier-based methods in closed-source code completion. 2. Advanced retrieval techniques significantly enhance RAG effectiveness (BM25=best lexical, GTE-Qwen=best semantic). 3. Lexical+semantic retrieval combination achieves optimal results. Developer survey confirms practical utility of RAG in real coding scenarios.

Conclusion: The study shows RAG methods, particularly similarity-based approaches with BM25/semantic fusion, can effectively bridge open-source vs closed-source codebase gaps in industrial settings. Complementary usage of lexical and semantic retrieval techniques is recommended for maximal performance in proprietary software systems.

Abstract: Code completion, a crucial task in software engineering that enhances
developer productivity, has seen substantial improvements with the rapid
advancement of large language models (LLMs). In recent years,
retrieval-augmented generation (RAG) has emerged as a promising method to
enhance the code completion capabilities of LLMs, which leverages relevant
context from codebases without requiring model retraining. While existing
studies have demonstrated the effectiveness of RAG on public repositories and
benchmarks, the potential distribution shift between open-source and
closed-source codebases presents unique challenges that remain unexplored. To
mitigate the gap, we conduct an empirical study to investigate the performance
of widely-used RAG methods for code completion in the industrial-scale codebase
of WeChat, one of the largest proprietary software systems. Specifically, we
extensively explore two main types of RAG methods, namely identifier-based RAG
and similarity-based RAG, across 26 open-source LLMs ranging from 0.5B to 671B
parameters. For a more comprehensive analysis, we employ different retrieval
techniques for similarity-based RAG, including lexical and semantic retrieval.
Based on 1,669 internal repositories, we achieve several key findings: (1) both
RAG methods demonstrate effectiveness in closed-source repositories, with
similarity-based RAG showing superior performance, (2) the effectiveness of
similarity-based RAG improves with more advanced retrieval techniques, where
BM25 (lexical retrieval) and GTE-Qwen (semantic retrieval) achieve superior
performance, and (3) the combination of lexical and semantic retrieval
techniques yields optimal results, demonstrating complementary strengths.
Furthermore, we conduct a developer survey to validate the practical utility of
RAG methods in real-world development environments.

</details>
