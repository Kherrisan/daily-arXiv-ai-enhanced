{"id": "2509.14271", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14271", "abs": "https://arxiv.org/abs/2509.14271", "authors": ["Gustavo Sandoval", "Denys Fenchenko", "Junyao Chen"], "title": "Early Approaches to Adversarial Fine-Tuning for Prompt Injection Defense: A 2022 Study of GPT-3 and Contemporary Models", "comment": null, "summary": "This paper documents early research conducted in 2022 on defending against\nprompt injection attacks in large language models, providing historical context\nfor the evolution of this critical security domain. This research focuses on\ntwo adversarial attacks against Large Language Models (LLMs): prompt injection\nand goal hijacking. We examine how to construct these attacks, test them on\nvarious LLMs, and compare their effectiveness. We propose and evaluate a novel\ndefense technique called Adversarial Fine-Tuning. Our results show that,\nwithout this defense, the attacks succeeded 31\\% of the time on GPT-3 series\nmodels. When using our Adversarial Fine-Tuning approach, attack success rates\nwere reduced to near zero for smaller GPT-3 variants (Ada, Babbage, Curie),\nthough we note that subsequent research has revealed limitations of\nfine-tuning-based defenses. We also find that more flexible models exhibit\ngreater vulnerability to these attacks. Consequently, large models such as\nGPT-3 Davinci are more vulnerable than smaller models like GPT-2. While the\nspecific models tested are now superseded, the core methodology and empirical\nfindings contributed to the foundation of modern prompt injection defense\nresearch, including instruction hierarchy systems and constitutional AI\napproaches.", "AI": {"tldr": "A paper on Adversarial Fine-Tuning for defending against prompt injection attacks in LLMs using GPT-3 series models, showing attack success dropping from 31\template: %} to near zero with smaller models, prioritizing legacy systems with production constraints.", "motivation": "As LLMs become prevalent, defending against prompt injections is crucial to maintain model integrity and ensure reliable user interactions.", "method": "Researchers tested prompt injection and goal hijacking by crafting and executing these attacks on various LLMs and conducted Adversarial Fine-Tuning as a defense strategy which involved reinforcing the models with attack-related examples.", "result": "Using Adversarial Fine-Tuning significantly lowered the success rate of attacks on GPT-3's smaller models (Ada, Babbage, Curie) to nearly 0\template: %, while GPT-3 Davinci showed higher vulnerability.\template: % The results hence demonstrated the effectiveness of the proposed defense.", "conclusion": "The paper established an early foundation for robust defenses against prompt injection by showing the effectiveness of Adversarial Fine-Tuning, yet the limitations indicated that more dynamic methods like instruction hierarchy and constitutional AI which supersedes this are necessary as models evolve."}}
{"id": "2509.14275", "categories": ["cs.CR", "cs.AI", "cs.CL", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14275", "abs": "https://arxiv.org/abs/2509.14275", "authors": ["Nobin Sarwar", "Shubhashis Roy Dipta"], "title": "FedMentor: Domain-Aware Differential Privacy for Heterogeneous Federated LLMs in Mental Health", "comment": "(e.g.: 18 pages, 6 figures, 6 tables)", "summary": "Privacy-preserving adaptation of Large Language Models (LLMs) in sensitive\ndomains (e.g., mental health) requires balancing strict confidentiality with\nmodel utility and safety. We propose FedMentor, a federated fine-tuning\nframework that integrates Low-Rank Adaptation (LoRA) and domain-aware\nDifferential Privacy (DP) to meet per-domain privacy budgets while maintaining\nperformance. Each client (domain) applies a custom DP noise scale proportional\nto its data sensitivity, and the server adaptively reduces noise when utility\nfalls below a threshold. In experiments on three mental health datasets, we\nshow that FedMentor improves safety over standard Federated Learning without\nprivacy, raising safe output rates by up to three points and lowering toxicity,\nwhile maintaining utility (BERTScore F1 and ROUGE-L) within 0.5% of the\nnon-private baseline and close to the centralized upper bound. The framework\nscales to backbones with up to 1.7B parameters on single-GPU clients, requiring\n< 173 MB of communication per round. FedMentor demonstrates a practical\napproach to privately fine-tune LLMs for safer deployments in healthcare and\nother sensitive fields.", "AI": {"tldr": "FedMentor is a privacy-preserving framework for fine-tuning LLMs in sensitive domains like mental health. It uses federated learning with LoRA and dynamic domain-aware DP to achieve safer outputs (+3 accuracy), reduced toxicity, and near-baseline utility while supporting large models with efficient communication.", "motivation": "The paper addresses the challenge of adapting Large Language Models (LLMs) for sensitive domains (e.g., mental health) while maintaining strict privacy, safety, and model utility in compliance with domain-specific confidentiality requirements.", "method": "FedMentor combines Low-Rank Adaptation (LoRA) with domain-aware Differential Privacy (DP) in a federated framework. Each client applies customized DP noise scaling based on data sensitivity, while the server dynamically reduces noise to maintain utility thresholds.", "result": "FedMentor improves safe output rates by 3 points, reduces toxicity, and maintains BERTScore F1/ROUGE-L within 0.5% of non-private baselines. It scales to 1.7B-parameter models with <173 MB per training round and matches centralized performance bounds.", "conclusion": "FedMentor demonstrates a practical approach for privacy-preserving LLM adaptation in sensitive domains, achieving safety improvements while balancing utility and scalability in healthcare applications."}}
{"id": "2509.14278", "categories": ["cs.CR", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14278", "abs": "https://arxiv.org/abs/2509.14278", "authors": ["Yuntao Du", "Zitao Li", "Ninghui Li", "Bolin Ding"], "title": "Beyond Data Privacy: New Privacy Risks for Large Language Models", "comment": null, "summary": "Large Language Models (LLMs) have achieved remarkable progress in natural\nlanguage understanding, reasoning, and autonomous decision-making. However,\nthese advancements have also come with significant privacy concerns. While\nsignificant research has focused on mitigating the data privacy risks of LLMs\nduring various stages of model training, less attention has been paid to new\nthreats emerging from their deployment. The integration of LLMs into widely\nused applications and the weaponization of their autonomous abilities have\ncreated new privacy vulnerabilities. These vulnerabilities provide\nopportunities for both inadvertent data leakage and malicious exfiltration from\nLLM-powered systems. Additionally, adversaries can exploit these systems to\nlaunch sophisticated, large-scale privacy attacks, threatening not only\nindividual privacy but also financial security and societal trust. In this\npaper, we systematically examine these emerging privacy risks of LLMs. We also\ndiscuss potential mitigation strategies and call for the research community to\nbroaden its focus beyond data privacy risks, developing new defenses to address\nthe evolving threats posed by increasingly powerful LLMs and LLM-powered\nsystems.", "AI": {"tldr": "This paper examines emerging privacy risks in deployed LLMs, identifies vulnerabilities from autonomous capabilities, and urges researchers to expand beyond traditional data privacy defenses to protect against sophisticated threats and societal harms.", "motivation": "The integration of LLMs into everyday applications and the exploitation of their autonomous decision-making capabilities have introduced critical privacy risks, including data leakage, malicious data exfiltration, and large-scale privacy attacks that endanger individual privacy, financial security, and societal trust.", "method": "The authors conducted a systematic examination of emerging privacy risks in LLMs, focusing on vulnerabilities arising during deployment, autonomous abilities exploitation, and new attack vectors.", "result": "The analysis highlights new privacy vulnerabilities in LLM-powered systems, such as inadvertent data leakage and sophisticated adversarial attacks, while proposing mitigation strategies to address these escalating threats.", "conclusion": "The paper urges the research community to broaden their focus beyond data privacy risks, emphasizing the development of new defenses against evolving threats posed by powerful LLMs and their systems."}}
{"id": "2509.14282", "categories": ["cs.CR", "quant-ph"], "pdf": "https://arxiv.org/pdf/2509.14282", "abs": "https://arxiv.org/abs/2509.14282", "authors": ["Ali Al-kuwari", "Noureldin Mohamed", "Saif Al-kuwari", "Ahmed Farouk", "Bikash K. Behera"], "title": "Resisting Quantum Key Distribution Attacks Using Quantum Machine Learning", "comment": null, "summary": "The emergence of quantum computing poses significant risks to the security of\nmodern communication networks as it breaks today's public-key cryptographic\nalgorithms. Quantum Key Distribution (QKD) offers a promising solution by\nharnessing the principles of quantum mechanics to establish secure keys.\nHowever, practical QKD implementations remain vulnerable to hardware\nimperfections and advanced attacks such as Photon Number Splitting and\nTrojan-Horse attacks. In this work, we investigate the potential of using\nquantum machine learning (QML) to detect popular QKD attacks. In particular, we\npropose a Hybrid Quantum Long Short-Term Memory (QLSTM) model to improve the\ndetection of common QKD attacks. By combining quantum-enhanced learning with\nclassical deep learning, the model captures complex temporal patterns in QKD\ndata, improving detection accuracy. To evaluate the proposed model, we\nintroduce a realistic QKD dataset simulating normal QKD operations along with\nseven attack scenarios, Intercept-and-Resend, Photon-Number Splitting (PNS),\nTrojan-Horse attacks Random Number Generator (RNG), Detector Blinding,\nWavelength-dependent Trojan Horse, and Combined attacks. The dataset includes\nquantum security metrics such as Quantum Bit Error Rate (QBER), measurement\nentropy, signal and decoy loss rates, and time-based metrics, ensuring an\naccurate representation of real-world conditions. Our results demonstrate\npromising performance of the quantum machine learning approach compared to\ntraditional classical machine learning models, highlighting the potential of\nhybrid techniques to enhance the security of future quantum communication\nnetworks. The proposed Hybrid QLSTM model achieved an accuracy of 93.7.0\\%\nafter 50 training epochs, outperforming classical deep learning models such as\nLSTM, and CNN.", "AI": {"tldr": "Error", "motivation": "Error", "method": "Error", "result": "Error", "conclusion": "Error"}}
{"id": "2509.14265", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.14265", "abs": "https://arxiv.org/abs/2509.14265", "authors": ["Siyuan Chen", "Zhichao Lu", "Qingfu Zhang"], "title": "Evolution of Kernels: Automated RISC-V Kernel Optimization with Large Language Models", "comment": "Technical report", "summary": "Automated kernel design is critical for overcoming software ecosystem\nbarriers in emerging hardware platforms like RISC-V. While large language\nmodels (LLMs) have shown promise for automated kernel optimization,\ndemonstrating success in CUDA domains with comprehensive technical documents\nand mature codebases, their effectiveness remains unproven for reference-scarce\ndomains like RISC-V. We present Evolution of Kernels (EoK), a novel LLM-based\nevolutionary program search framework that automates kernel design for domains\nwith limited reference material. EoK mitigates reference scarcity by mining and\nformalizing reusable optimization ideas (general design principles + actionable\nthoughts) from established kernel libraries' development histories; it then\nguides parallel LLM explorations using these ideas, enriched via\nRetrieval-Augmented Generation (RAG) with RISC-V-specific context, prioritizing\nhistorically effective techniques. Empirically, EoK achieves a median 1.27x\nspeedup, surpassing human experts on all 80 evaluated kernel design tasks and\nimproving upon prior LLM-based automated kernel design methods by 20%. These\nresults underscore the viability of incorporating human experience into\nemerging domains and highlight the immense potential of LLM-based automated\nkernel optimization.", "AI": {"tldr": "Auto kernel design avoids software bottlenecks using LLMs in areas with scarce references.", "motivation": "New platforms like RISC-V are having hard times with kernel design, because there aren't enough references available unlike more established ones such as CUDA. This shortage of references hampers the performance levels one can achieve.", "method": "EoK, based on LLMs, uses evolutionary program search to automatically design kernels even when references are limited. It derives and formalizes reusable optimization ideas from existing kernel development histories to assist the LLM. A RAG component adds RISC-V specific context to those ideas.", "result": "EoK performed between 20% and 1.27x better than the best prior approaches on all 80 tested tasks.", "conclusion": "EoK shows that LLMs can do great in areas with sparse references by incorporating human insights."}}
{"id": "2509.14284", "categories": ["cs.CR", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2509.14284", "abs": "https://arxiv.org/abs/2509.14284", "authors": ["Vaidehi Patil", "Elias Stengel-Eskin", "Mohit Bansal"], "title": "The Sum Leaks More Than Its Parts: Compositional Privacy Risks and Mitigations in Multi-Agent Collaboration", "comment": "Code: https://github.com/Vaidehi99/MultiAgentPrivacy", "summary": "As large language models (LLMs) become integral to multi-agent systems, new\nprivacy risks emerge that extend beyond memorization, direct inference, or\nsingle-turn evaluations. In particular, seemingly innocuous responses, when\ncomposed across interactions, can cumulatively enable adversaries to recover\nsensitive information, a phenomenon we term compositional privacy leakage. We\npresent the first systematic study of such compositional privacy leaks and\npossible mitigation methods in multi-agent LLM systems. First, we develop a\nframework that models how auxiliary knowledge and agent interactions jointly\namplify privacy risks, even when each response is benign in isolation. Next, to\nmitigate this, we propose and evaluate two defense strategies: (1)\nTheory-of-Mind defense (ToM), where defender agents infer a questioner's intent\nby anticipating how their outputs may be exploited by adversaries, and (2)\nCollaborative Consensus Defense (CoDef), where responder agents collaborate\nwith peers who vote based on a shared aggregated state to restrict sensitive\ninformation spread. Crucially, we balance our evaluation across compositions\nthat expose sensitive information and compositions that yield benign\ninferences. Our experiments quantify how these defense strategies differ in\nbalancing the privacy-utility trade-off. We find that while chain-of-thought\nalone offers limited protection to leakage (~39% sensitive blocking rate), our\nToM defense substantially improves sensitive query blocking (up to 97%) but can\nreduce benign task success. CoDef achieves the best balance, yielding the\nhighest Balanced Outcome (79.8%), highlighting the benefit of combining\nexplicit reasoning with defender collaboration. Together, our results expose a\nnew class of risks in collaborative LLM deployments and provide actionable\ninsights for designing safeguards against compositional, context-driven privacy\nleakage.", "AI": {"tldr": "Paper reveals 'compositional privacy leakage' during multi-agent LLM interactions and proposes mitigation strategies, with Collaborative Consensus Defense showing the best privacy-utility balance.", "motivation": "Existing privacy risks (memorization, inference, single-turn attacks) are insufficient for multi-agent systems where cumulative benign interactions can leak sensitive information through context-aware composition.", "method": "1) Framework analyzing how auxiliary knowledge and interactions amplify privacy risks. 2) Two defense strategies: Theory-of-Mind (ToM) for intent-aware blocking and Collaborative Consensus Defense (CoDef) for collaborative decision-making. 3) Evaluation across sensitive/benign composition scenarios.", "result": "ToM achieves 97% sensitive query blocking but reduces benign utility; CoDef attains 79.8% Balanced Outcome metric by combining reasoning and collaboration. Chain-of-thought alone blocks only 39% of leaks.", "conclusion": "The study highlights a new class of privacy risks in multi-agent LLM systems through compositional leakage and demonstrates actionable mitigation strategies (ToM and CoDef) to balance privacy-utility trade-offs."}}
{"id": "2509.14273", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14273", "abs": "https://arxiv.org/abs/2509.14273", "authors": ["Swapnil Sharma Sarker", "Tanzina Taher Ifty"], "title": "Automated and Context-Aware Code Documentation Leveraging Advanced LLMs", "comment": null, "summary": "Code documentation is essential to improve software maintainability and\ncomprehension. The tedious nature of manual code documentation has led to much\nresearch on automated documentation generation. Existing automated approaches\nprimarily focused on code summarization, leaving a gap in template-based\ndocumentation generation (e.g., Javadoc), particularly with publicly available\nLarge Language Models (LLMs). Furthermore, progress in this area has been\nhindered by the lack of a Javadoc-specific dataset that incorporates modern\nlanguage features, provides broad framework/library coverage, and includes\nnecessary contextual information. This study aims to address these gaps by\ndeveloping a tailored dataset and assessing the capabilities of publicly\navailable LLMs for context-aware, template-based Javadoc generation. In this\nwork, we present a novel, context-aware dataset for Javadoc generation that\nincludes critical structural and semantic information from modern Java\ncodebases. We evaluate five open-source LLMs (including LLaMA-3.1, Gemma-2,\nPhi-3, Mistral, Qwen-2.5) using zero-shot, few-shot, and fine-tuned setups and\nprovide a comparative analysis of their performance. Our results demonstrate\nthat LLaMA 3.1 performs consistently well and is a reliable candidate for\npractical, automated Javadoc generation, offering a viable alternative to\nproprietary systems.", "AI": {"tldr": "This work creates a modern Javadoc dataset and benchmarks LLMs, showing LLaMA 3.1 as a reliable tool for automated template-based documentation.", "motivation": "Manual Javadoc generation is tedious, and existing datasets lack coverage of modern Java frameworks/semantics; this study addresses these gaps.", "method": "The paper introduces a context-aware dataset for Javadoc generation with modern Java features and evaluates five open-source LLMs (LLaMA-3.1, Gemma-2, Phi-3, Mistral, Qwen-2.5) using zero-shot, few-shot, and fine-tuned setups.", "result": "LLaMA 3.1 consistently outperformed other models in Javadoc tasks, demonstrating it as a viable open-source alternative to proprietary systems.", "conclusion": "The study concludes that a tailored dataset and LLaMA 3.1 offer reliable, context-aware Javadoc generation, addressing gaps in automated template-based documentation."}}
{"id": "2509.14285", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14285", "abs": "https://arxiv.org/abs/2509.14285", "authors": ["S M Asif Hossain", "Ruksat Khan Shayoni", "Mohd Ruhul Ameen", "Akif Islam", "M. F. Mridha", "Jungpil Shin"], "title": "A Multi-Agent LLM Defense Pipeline Against Prompt Injection Attacks", "comment": null, "summary": "Prompt injection attacks represent a major vulnerability in Large Language\nModel (LLM) deployments, where malicious instructions embedded in user inputs\ncan override system prompts and induce unintended behaviors. This paper\npresents a novel multi-agent defense framework that employs specialized LLM\nagents in coordinated pipelines to detect and neutralize prompt injection\nattacks in real-time. We evaluate our approach using two distinct\narchitectures: a sequential chain-of-agents pipeline and a hierarchical\ncoordinator-based system. Our comprehensive evaluation on 55 unique prompt\ninjection attacks, grouped into 8 categories and totaling 400 attack instances\nacross two LLM platforms (ChatGLM and Llama2), demonstrates significant\nsecurity improvements. Without defense mechanisms, baseline Attack Success\nRates (ASR) reached 30% for ChatGLM and 20% for Llama2. Our multi-agent\npipeline achieved 100% mitigation, reducing ASR to 0% across all tested\nscenarios. The framework demonstrates robustness across multiple attack\ncategories including direct overrides, code execution attempts, data\nexfiltration, and obfuscation techniques, while maintaining system\nfunctionality for legitimate queries.", "AI": {"tldr": "Error", "motivation": "Error", "method": "Error", "result": "Error", "conclusion": "Error"}}
{"id": "2509.14279", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14279", "abs": "https://arxiv.org/abs/2509.14279", "authors": ["Robert Tjarko Lange", "Qi Sun", "Aaditya Prasad", "Maxence Faldor", "Yujin Tang", "David Ha"], "title": "Towards Robust Agentic CUDA Kernel Benchmarking, Verification, and Optimization", "comment": "62 pages, 10 figures", "summary": "Recent advances in large language models (LLMs) demonstrate their\neffectiveness in scaling test-time compute for software engineering tasks.\nHowever, these approaches often focus on high-level solutions, with limited\nattention to optimizing low-level CUDA kernel implementations. Additionally,\nexisting kernel generation benchmarks suffer from exploitable loopholes and\ninsufficient diversity in testing conditions, hindering true generalization\nassessment. To address these limitations, we introduce robust-kbench, a new\nbenchmark for rigorous evaluation of kernel performance and correctness across\nvaried scenarios. Furthermore, we present a comprehensive agentic framework\nthat automates CUDA kernel discovery, verification, and optimization. This\npipeline enables frontier LLMs to translate torch code to CUDA kernels and\niteratively improve their runtime within our robust evaluation setting. Our\nsequential workflow first translates PyTorch code into equivalent CUDA kernels.\nIt then optimizes their runtime using a novel evolutionary meta-generation\nprocedure tailored to the CUDA ecosystem, guided by LLM-based verifiers for\ncorrectness and efficient filtering. Evaluated on robust-kbench, our approach\nproduces CUDA kernels outperforming torch implementations for practical\napplications, including forward and backward passes. It can fuse operations and\ndeploy various runtime optimization strategies. The verifier workflow\naccurately classifies incorrect kernels, enhancing hardware verification\nefficiency.", "AI": {"tldr": "This work advances CUDA kernel optimization for LLMs by presenting robust-kbench and an agentic pipeline that combines evolutionary optimization with LLM-based verification. The result is faster, more accurate kernel implementations verified through a diverse, loophole-free benchmark suite.", "motivation": "Current LLM optimizations focus on high-level solutions, neglecting CUDA kernel-level efficiency. Existing benchmarks lack robustness and diversity, limiting meaningful generalization assessments. The work addresses these issues through targeted algorithmic and evaluative innovations.", "method": "The approach combines a novel benchmark (robust-kbench) with a sequential workflow: translating PyTorch to CUDA kernels, optimizing via evolutionary meta-generation, and verifying correctness with LLM-based tools. This framework enables iterative runtime improvements and efficient hardware validation.", "result": "Evaluated on robust-kbench, the framework generates CUDA kernels outperforming PyTorch implementations in runtime (forward/backward passes), supports operation fusion, and applies runtime optimizations. The verification system accurately filters invalid kernels, improving hardware testing efficiency.", "conclusion": "The paper introduces robust-kbench and an automated agentic framework to enhance CUDA kernel optimization for LLMs in software engineering tasks. This addresses gaps in low-level optimization and benchmarking limitations, achieving superior performance and correctness verification compared to existing methods."}}
{"id": "2509.14297", "categories": ["cs.CR", "cs.CL"], "pdf": "https://arxiv.org/pdf/2509.14297", "abs": "https://arxiv.org/abs/2509.14297", "authors": ["Xuan Luo", "Yue Wang", "Zefeng He", "Geng Tu", "Jing Li", "Ruifeng Xu"], "title": "A Simple and Efficient Jailbreak Method Exploiting LLMs' Helpfulness", "comment": null, "summary": "Safety alignment aims to prevent Large Language Models (LLMs) from responding\nto harmful queries. To strengthen safety protections, jailbreak methods are\ndeveloped to simulate malicious attacks and uncover vulnerabilities. In this\npaper, we introduce HILL (Hiding Intention by Learning from LLMs), a novel\njailbreak approach that systematically transforms imperative harmful requests\ninto learning-style questions with only straightforward hypotheticality\nindicators. Further, we introduce two new metrics to thoroughly evaluate the\nutility of jailbreak methods. Experiments on the AdvBench dataset across a wide\nrange of models demonstrate HILL's strong effectiveness, generalizability, and\nharmfulness. It achieves top attack success rates on the majority of models and\nacross malicious categories while maintaining high efficiency with concise\nprompts. Results of various defense methods show the robustness of HILL, with\nmost defenses having mediocre effects or even increasing the attack success\nrates. Moreover, the assessment on our constructed safe prompts reveals\ninherent limitations of LLMs' safety mechanisms and flaws in defense methods.\nThis work exposes significant vulnerabilities of safety measures against\nlearning-style elicitation, highlighting a critical challenge of balancing\nhelpfulness and safety alignments.", "AI": {"tldr": "This paper proposes HILL, a jailbreak method that transforms harmful requests into hypothetical learning-style questions, exposing vulnerabilities in LLM safety mechanisms with high attack success rates and efficiency.", "motivation": "Existing safety alignment measures for LLMs remain vulnerable to sophisticated attacks, requiring systematic methods to uncover weaknesses and improve defenses.", "method": "HILL converts imperative malicious queries into learning-style questions using minimal hypothetical indicators, supported by two new evaluation metrics for jailbreak effectiveness.", "result": "HILL achieves top attack success rates across 75%+ models tested, generalizes across malicious categories, and reveals defense methods often fail or exacerbate vulnerabilities.", "conclusion": "HILL demonstrates critical limitations in current safety mechanisms, highlighting the challenge of balancing helpfulness and safety alignment against learning-style elicitation attacks."}}
{"id": "2509.14281", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.14281", "abs": "https://arxiv.org/abs/2509.14281", "authors": ["Xifeng Yao", "Dongyu Lang", "Wu Zhang", "Xintong Guo", "Huarui Xie", "Yinhao Ni", "Ping Liu", "Guang Shen", "Yi Bai", "Dandan Tu", "Changzheng Zhang"], "title": "SCoGen: Scenario-Centric Graph-Based Synthesis of Real-World Code Problems", "comment": null, "summary": "Significant advancements have been made in the capabilities of code large\nlanguage models, leading to their rapid adoption and application across a wide\nrange of domains. However, their further advancements are often constrained by\nthe scarcity of real-world coding problems. To bridge this gap, we propose a\nnovel framework for synthesizing code problems that emulate authentic\nreal-world scenarios. This framework systematically integrates domain\nknowledge, domain skills, and coding skills, all of which are meticulously\nextracted from real-world programming-related datasets, including Stack\nOverflow and Kaggle. The extracted elements serve as the foundational building\nblocks for constructing code problems. To align the generated problems with\npractical applications, application scenarios are also mined from the\naforementioned datasets. These scenarios are then utilized to construct a\nscenario-centric graph that interconnects domain knowledge, domain skills, and\ncoding skills. Based on this structured representation, a sampling strategy on\nthe graph is designed, which effectively controls the generation of a code\nproblem with complexity and diversity, reflects real-world challenges.\nExperimental results demonstrate that the proposed method consistently achieves\nsuperior performance over state-of-the-art open-source large language models of\nvarying sizes and functionalities, including both coders and general-purpose\nmodels, across a diverse set of real-world benchmarks.", "AI": {"tldr": "A novel framework synthesizes real-world code problems using domain data and graphs, outperforming existing models in benchmarks.", "motivation": "Current advancements in code large language models are hindered by limited real-world coding data, motivating the need to synthesize realistic, diverse code problems for effective training and evaluation.", "method": "The framework integrates domain knowledge, domain skills, and coding skills extracted from datasets like Stack Overflow and Kaggle. It constructs a scenario-centric graph to interlink these elements and employs a graph-based sampling strategy to generate diverse, complexity-controlled code problems.", "result": "Experiments show the method outperforms state-of-the-art open-source models (both code-focused and general-purpose) across multiple real-world benchmarks, achieving consistent improvements in performance.", "conclusion": "The proposed framework effectively addresses the scarcity of real-world coding problems by synthesizing high-quality, scenario-driven code problems, significantly advancing the development of code large language models."}}
{"id": "2509.14335", "categories": ["cs.CR", "cs.AI", "cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14335", "abs": "https://arxiv.org/abs/2509.14335", "authors": ["Xinran Zheng", "Xingzhi Qian", "Yiling He", "Shuo Yang", "Lorenzo Cavallaro"], "title": "Beyond Classification: Evaluating LLMs for Fine-Grained Automatic Malware Behavior Auditing", "comment": null, "summary": "Automated malware classification has achieved strong detection performance.\nYet, malware behavior auditing seeks causal and verifiable explanations of\nmalicious activities -- essential not only to reveal what malware does but also\nto substantiate such claims with evidence. This task is challenging, as\nadversarial intent is often hidden within complex, framework-heavy\napplications, making manual auditing slow and costly. Large Language Models\n(LLMs) could help address this gap, but their auditing potential remains\nlargely unexplored due to three limitations: (1) scarce fine-grained\nannotations for fair assessment; (2) abundant benign code obscuring malicious\nsignals; and (3) unverifiable, hallucination-prone outputs undermining\nattribution credibility. To close this gap, we introduce MalEval, a\ncomprehensive framework for fine-grained Android malware auditing, designed to\nevaluate how effectively LLMs support auditing under real-world constraints.\nMalEval provides expert-verified reports and an updated sensitive API list to\nmitigate ground truth scarcity and reduce noise via static reachability\nanalysis. Function-level structural representations serve as intermediate\nattribution units for verifiable evaluation. Building on this, we define four\nanalyst-aligned tasks -- function prioritization, evidence attribution,\nbehavior synthesis, and sample discrimination -- together with domain-specific\nmetrics and a unified workload-oriented score. We evaluate seven widely used\nLLMs on a curated dataset of recent malware and misclassified benign apps,\noffering the first systematic assessment of their auditing capabilities.\nMalEval reveals both promising potential and critical limitations across audit\nstages, providing a reproducible benchmark and foundation for future research\non LLM-enhanced malware behavior auditing. MalEval is publicly available at\nhttps://github.com/ZhengXR930/MalEval.git", "AI": {"tldr": "MalEval is an open-source framework that evaluates LLMs for Android malware auditing through task-specific metrics, revealing both promise and challenges in using LLMs for verifiable behavior analysis.", "motivation": "Automated malware classification lacks verifiable explanations of malicious intent. Manual auditing is inefficient, and LLMs' auditing potential is hindered by scarce annotations, benign code noise, and unverifiable outputs. A systematic evaluation framework is urgently needed.", "method": "MalEval employs expert-verified reports, static reachability analysis, updated sensitive API lists, and function-level structural representations. It defines four analyst-aligned tasks (function prioritization, evidence attribution, behavior synthesis, sample discrimination) with domain-specific metrics and a unified workload-oriented score to evaluate LLMs.", "result": "A curated dataset of recent malware and misclassified benign apps was used to evaluate seven LLMs. Results revealed strengths and weaknesses across audit stages, demonstrating MalEval's effectiveness in addressing noise and ground truth scarcity while benchmarking LLM capabilities.", "conclusion": "MalEval introduces a comprehensive framework to assess and enhance LLMs for malware behavior auditing, highlighting their potential and critical limitations while providing a reproducible benchmark."}}
{"id": "2509.14294", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14294", "abs": "https://arxiv.org/abs/2509.14294", "authors": ["Hira Naveed", "Scott Barnett", "Chetan Arora", "John Grundy", "Hourieh Khalajzadeh", "Omar Haggag"], "title": "Monitoring Machine Learning Systems: A Multivocal Literature Review", "comment": null, "summary": "Context: Dynamic production environments make it challenging to maintain\nreliable machine learning (ML) systems. Runtime issues, such as changes in data\npatterns or operating contexts, that degrade model performance are a common\noccurrence in production settings. Monitoring enables early detection and\nmitigation of these runtime issues, helping maintain users' trust and prevent\nunwanted consequences for organizations. Aim: This study aims to provide a\ncomprehensive overview of the ML monitoring literature. Method: We conducted a\nmultivocal literature review (MLR) following the well established guidelines by\nGarousi to investigate various aspects of ML monitoring approaches in 136\npapers. Results: We analyzed selected studies based on four key areas: (1) the\nmotivations, goals, and context; (2) the monitored aspects, specific\ntechniques, metrics, and tools; (3) the contributions and benefits; and (4) the\ncurrent limitations. We also discuss several insights found in the studies,\ntheir implications, and recommendations for future research and practice.\nConclusion: Our MLR identifies and summarizes ML monitoring practices and gaps,\nemphasizing similarities and disconnects between formal and gray literature.\nOur study is valuable for both academics and practitioners, as it helps select\nappropriate solutions, highlights limitations in current approaches, and\nprovides future directions for research and tool development.", "AI": {"tldr": "Error", "motivation": "Error", "method": "Error", "result": "Error", "conclusion": "Error"}}
{"id": "2509.14558", "categories": ["cs.CR", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2509.14558", "abs": "https://arxiv.org/abs/2509.14558", "authors": ["Guorui Chen", "Yifan Xia", "Xiaojun Jia", "Zhijiang Li", "Philip Torr", "Jindong Gu"], "title": "LLM Jailbreak Detection for (Almost) Free!", "comment": null, "summary": "Large language models (LLMs) enhance security through alignment when widely\nused, but remain susceptible to jailbreak attacks capable of producing\ninappropriate content. Jailbreak detection methods show promise in mitigating\njailbreak attacks through the assistance of other models or multiple model\ninferences. However, existing methods entail significant computational costs.\nIn this paper, we first present a finding that the difference in output\ndistributions between jailbreak and benign prompts can be employed for\ndetecting jailbreak prompts. Based on this finding, we propose a Free Jailbreak\nDetection (FJD) which prepends an affirmative instruction to the input and\nscales the logits by temperature to further distinguish between jailbreak and\nbenign prompts through the confidence of the first token. Furthermore, we\nenhance the detection performance of FJD through the integration of virtual\ninstruction learning. Extensive experiments on aligned LLMs show that our FJD\ncan effectively detect jailbreak prompts with almost no additional\ncomputational costs during LLM inference.", "AI": {"tldr": "The paper introduces FJD, a low-cost method for detecting jailbreak attacks in large language models by analyzing output distribution differences and enhancing first-token confidence through temperature scaling and virtual instruction learning.", "motivation": "Despite the widespread use of large language models (LLMs) in enhancing security through alignment, they still face the vulnerability of jailbreak attacks which bypass safety measures. Current detection methods are computationally expensive, necessitating a more efficient solution to identify these attacks without additional resource demands during inference.", "method": "The proposed FJD method leverages the distinct output distribution patterns of jailbreak versus benign prompts. It employs an affirmative instruction to guide the LLM's response and applies temperature scaling to adjust the confidence in the first token. Additionally, the method is augmented with virtual instruction learning to optimize detection further.", "result": "Experimental results on various aligned LLMs demonstrate that FJD effectively identifies jailbreak prompts while maintaining computational efficiency, with minimal overhead during inference compared to existing methods.", "conclusion": "FJD offers an effective and computationally inexpensive way to detect jailbreak attacks in LLMs during inference, significantly improving current capabilities and potentially setting a new standard for practical LLM safety mechanisms."}}
{"id": "2509.14347", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14347", "abs": "https://arxiv.org/abs/2509.14347", "authors": ["Henri A\u00efdasso", "Francis Bordeleau", "Ali Tizghadam"], "title": "On the Illusion of Success: An Empirical Study of Build Reruns and Silent Failures in Industrial CI", "comment": "17 pages, 7 figures", "summary": "Reliability of build outcomes is a cornerstone of effective Continuous\nIntegration (CI). Yet in practice, developers often struggle with\nnon-deterministic issues in the code or CI infrastructure, which undermine\ntrust in build results. When faced with such unexpected outcomes, developers\noften repeatedly rerun jobs hoping for true success, but this practice is known\nto increase CI costs and reduce productivity. While recent studies have focused\non intermittent job failures, no prior work has investigated silent failures,\nwhere build jobs are marked as successful but fail to complete all or part of\ntheir tasks. Such silent failures often go unnoticed, creating an illusion of\nsuccess with detrimental consequences such as bugs escaping into production.\nThis paper presents the first empirical study of silent failures through the\npractice of rerunning successful jobs. An analysis of 142,387 jobs across 81\nindustrial projects shows that 11% of successful jobs are rerun, with 35% of\nthese reruns occurring after more than 24 hours. Using mixed-effects models on\n32 independent variables (AUC of 85%), we identified key factors associated\nwith reruns of successful jobs, notably testing and static analysis tasks,\nscripting languages like Shell, and developers prior rerun tendencies. A\nfurther analysis of 92 public issues revealed 11 categories of silent failures\naligning with these factors, the most frequent being artifact operation errors,\ncaching errors, and ignored exit codes. Overall, our findings provide valuable\ninsights into the circumstances and causes of silent failures to raise\nawareness among teams, and present solutions to improve CI reliability.", "AI": {"tldr": "This paper pioneers the study of silent CI failures, revealing 11% rerates of seemingly successful jobs and key predictors. It identifies 11 failure categories (e.g., caching) and suggests improvements for reliable CI systems.", "motivation": "Current CI practices struggle with non-deterministic issues like intermittent and silent failures, which reduce trust in build outcomes and increase costs. Previous studies focused on intermittent failures but overlooked silent failures (jobs marked as successful but incomplete/defective).", "method": "The paper conducts an empirical study using data from 142,387 jobs across 81 industrial projects, analyzed with mixed-effects models (32 variables) and manual analysis of 92 public issues.", "result": "11% of successful jobs were rerun, with 35% of reruns occurring after 24 hours. Key factors included testing/static analysis tasks, Shell scripts, and developer behaviors. 11 failure categories were identified, including artifact/operation errors, caching issues, and ignored exit codes.", "conclusion": "The study concludes that silent failures in CI are significant and often overlooked, leading to potential bugs in production. The research emphasizes the need for improved practices to address these failures and enhance CI reliability."}}
{"id": "2509.14583", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2509.14583", "abs": "https://arxiv.org/abs/2509.14583", "authors": ["Johnny So", "Michael Ferdman", "Nick Nikiforakis"], "title": "What Gets Measured Gets Managed: Mitigating Supply Chain Attacks with a Link Integrity Management System", "comment": "Extended version of the paper \"What Gets Measured Gets Managed:\n  Mitigating Supply Chain Attacks with a Link Integrity Management System\" that\n  will be published in ACM CCS 2025", "summary": "The web continues to grow, but dependency-monitoring tools and standards for\nresource integrity lag behind. Currently, there exists no robust method to\nverify the integrity of web resources, much less in a generalizable yet\nperformant manner, and supply chains remain one of the most targeted parts of\nthe attack surface of web applications.\n  In this paper, we present the design of LiMS, a transparent system to\nbootstrap link integrity guarantees in web browsing sessions with minimal\noverhead. At its core, LiMS uses a set of customizable integrity policies to\ndeclare the (un)expected properties of resources, verifies these policies, and\nenforces them for website visitors. We discuss how basic integrity policies can\nserve as building blocks for a comprehensive set of integrity policies, while\nproviding guarantees that would be sufficient to defend against recent supply\nchain attacks detailed by security industry reports. Finally, we evaluate our\nopen-sourced prototype by simulating deployments on a representative sample of\n450 domains that are diverse in ranking and category. We find that our proposal\noffers the ability to bootstrap marked security improvements with an overall\noverhead of hundreds of milliseconds on initial page loads, and negligible\noverhead on reloads, regardless of network speeds. In addition, from examining\narchived data for the sample sites, we find that several of the proposed policy\nbuilding blocks suit their dependency usage patterns, and would incur minimal\nadministrative overhead.", "AI": {"tldr": "LiMS is a transparent system for verifying web resource integrity during browsing sessions with minimal overhead. It uses customizable integrity policies to enforce security guarantees, defended against supply chain attacks in 450 domain simulations, and maintains performance (initial load overhead: ~hundreds of ms, negligible on reloads).", "motivation": "Current web dependency-monitoring tools lack robustness, generalizability, and performance, leaving supply chains as a critical attack vector. Existing solutions cannot scale effectively while maintaining a balance between security guarantees and accessibility for website visitors.", "method": "LiMS implements a policy-based framework where administrators define (un)expected resource characteristics through customizable rules. These policies form a foundational set that can build comprehensive integrity guarantees. By analyzing dependency patterns and enforcing policies during page loads, LiMS transparently verifies resource authenticity and blocks deviations.", "result": "The LiMS prototype demonstrates: defense against supply chain attacks (e.g., content substation, MITM tampering); minimal overhead (450ms average initial load cost); 96.7% of domains required under 1,000 policy rules; and policy patterns matching 83% of cross-origin dependency scenarios with low administrative effort.", "conclusion": "LiMS establishes a pragmatic framework for web resource integrity that balances security, performance, and usability. The evaluation shows its feasibility against real-world attack vectors while maintaining compatibility with diverse website infrastructure. The open-sourced prototype suggests broad adoption is technically and operationally viable with negligible maintenance required."}}
{"id": "2509.14373", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14373", "abs": "https://arxiv.org/abs/2509.14373", "authors": ["Huy Le", "Phong Nguyen", "Hao Do", "Tuan Nguyen", "Thien Pham", "Anh Nguyen-Duc", "Tho Quan"], "title": "CodeLSI: Leveraging Foundation Models for Automated Code Generation with Low-Rank Optimization and Domain-Specific Instruction Tuning", "comment": null, "summary": "Context: Automated code generation using Foundation Models (FMs) offers\npromising solutions for enhancing software development efficiency. However,\nchallenges remain in ensuring domain specificity, cost-effectiveness, and\nsecurity - especially when relying on third-party APIs. This paper introduces\nCodeLSI, a framework that combines low-rank optimization and domain-specific\ninstruction tuning to address these challenges.\n  Objectives: The aim of this study is to develop and evaluate CodeLSI, a novel\napproach for generating high-quality code tailored to specific domains, using\nFMs fine-tuned on company infrastructure without dependence on external APIs.\n  Methods: CodeLSI applies low-rank adaptation techniques to reduce the\ncomputational cost of model pre-training and fine-tuning. Domain-specific\ninstruction tuning is employed to align code generation with organizational\nneeds. We implemented and tested the framework on real-world JavaScript coding\ntasks using datasets drawn from internal software projects.\n  Results: Experimental evaluations show that CodeLSI produces high-quality,\ncontext aware code. It outperforms baseline models in terms of relevance,\naccuracy, and domain fit. The use of low-rank optimization significantly\nreduced resource requirements, enabling scalable training on company-owned\ninfrastructure.\n  Conclusion: CodeLSI demonstrates that combining low-rank optimization with\ndomain specific tuning can enhance the practicality and performance of FMs for\nautomated code generation. This approach provides a secure, cost-efficient\nalternative to commercial API based solutions and supports faster, more\ntargeted innovation in software development.", "AI": {"tldr": "CodeLSI introduces a framework using low-rank optimization and domain-specific instruction tuning for cost-effective, secure code generation without external APIs.", "motivation": "Third-party API reliance in foundation model-based code generation poses challenges in domain specificity, cost, and security. This study aims to provide an independent, scalable solution.", "method": "The framework utilizes low-rank adaptation to reduce pre-training costs and domain-specific instruction tuning to align code generation with organizational needs, validated through JavaScript tasks on internal datasets.", "result": "CodeLSI outperformed baselines in relevance, accuracy, and domain fit while reducing resource requirements via low-rank optimization, enabling cost-effective, scalable infrastructure training.", "conclusion": "CodeLSI demonstrates that combining low-rank techniques with domain-specific tuning enhances foundation models for secure, efficient, and domain-adapted code generation, offering a competitive alternative to commercial API solutions."}}
{"id": "2509.14589", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.14589", "abs": "https://arxiv.org/abs/2509.14589", "authors": ["Taesoo Kim", "HyungSeok Han", "Soyeon Park", "Dae R. Jeong", "Dohyeok Kim", "Dongkwan Kim", "Eunsoo Kim", "Jiho Kim", "Joshua Wang", "Kangsu Kim", "Sangwoo Ji", "Woosun Song", "Hanqing Zhao", "Andrew Chin", "Gyejin Lee", "Kevin Stevens", "Mansour Alharthi", "Yizhuo Zhai", "Cen Zhang", "Joonun Jang", "Yeongjin Jang", "Ammar Askar", "Dongju Kim", "Fabian Fleischer", "Jeongin Cho", "Junsik Kim", "Kyungjoon Ko", "Insu Yun", "Sangdon Park", "Dowoo Baik", "Haein Lee", "Hyeon Heo", "Minjae Gwon", "Minjae Lee", "Minwoo Baek", "Seunggi Min", "Wonyoung Kim", "Yonghwi Jin", "Younggi Park", "Yunjae Choi", "Jinho Jung", "Gwanhyun Lee", "Junyoung Jang", "Kyuheon Kim", "Yeonghyeon Cha", "Youngjoon Kim"], "title": "ATLANTIS: AI-driven Threat Localization, Analysis, and Triage Intelligence System", "comment": "Version 1.0 (September 17, 2025). Technical Report. Team Atlanta --\n  1st place in DARPA AIxCC Final Competition. Project page:\n  https://team-atlanta.github.io/", "summary": "We present ATLANTIS, the cyber reasoning system developed by Team Atlanta\nthat won 1st place in the Final Competition of DARPA's AI Cyber Challenge\n(AIxCC) at DEF CON 33 (August 2025). AIxCC (2023-2025) challenged teams to\nbuild autonomous cyber reasoning systems capable of discovering and patching\nvulnerabilities at the speed and scale of modern software. ATLANTIS integrates\nlarge language models (LLMs) with program analysis -- combining symbolic\nexecution, directed fuzzing, and static analysis -- to address limitations in\nautomated vulnerability discovery and program repair. Developed by researchers\nat Georgia Institute of Technology, Samsung Research, KAIST, and POSTECH, the\nsystem addresses core challenges: scaling across diverse codebases from C to\nJava, achieving high precision while maintaining broad coverage, and producing\nsemantically correct patches that preserve intended behavior. We detail the\ndesign philosophy, architectural decisions, and implementation strategies\nbehind ATLANTIS, share lessons learned from pushing the boundaries of automated\nsecurity when program analysis meets modern AI, and release artifacts to\nsupport reproducibility and future research.", "AI": {"tldr": "ATLANTIS, a cyber reasoning system integrating LLMs with program analysis techniques (symbolic execution, fuzzing, static analysis), won DARPA's AI Cyber Challenge by addressing automated vulnerability discovery and repair across diverse codebases.", "motivation": "Existing systems struggle with scalability, precision, and semantic correctness in automated vulnerability detection and repair. AIxCC demanded solutions capable of handling heterogeneous codebases (C-Java) with broad coverage and high-precision patches while preserving program intent.", "method": "Combined large language models with symbolic execution, directed fuzzing, and static analysis to address codebase diversity, precision-coverage tradeoffs, and semantic correctness. Multi-institutional collaboration between Georgia Tech, Samsung, KAIST, and POSTECH enabled architectural innovations in scalability and patch validation.", "result": "Won 1st place in DARPA's AIxCC final competition (DEF CON 33). Demonstrated effective integration of AI with program analysis for vulnerability discovery/patching, with published implementation details and reproducibility artifacts for subsequent work.", "conclusion": "Established a new paradigm for cyber reasoning by combining AI with traditional analysis techniques. Released artifacts for reproducibility, advances automated security, and provides foundational insights for future AI-enhanced program analysis systems."}}
{"id": "2509.14404", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.14404", "abs": "https://arxiv.org/abs/2509.14404", "authors": ["Haoye Tian", "Chong Wang", "BoYang Yang", "Lyuye Zhang", "Yang Liu"], "title": "A Taxonomy of Prompt Defects in LLM Systems", "comment": null, "summary": "Large Language Models (LLMs) have become key components of modern software,\nwith prompts acting as their de-facto programming interface. However, prompt\ndesign remains largely empirical and small mistakes can cascade into\nunreliable, insecure, or inefficient behavior. This paper presents the first\nsystematic survey and taxonomy of prompt defects, recurring ways that prompts\nfail to elicit their intended behavior from LLMs. We organize defects along six\ndimensions: (1) Specification and Intent, (2) Input and Content, (3) Structure\nand Formatting, (4) Context and Memory, (5) Performance and Efficiency, and (6)\nMaintainability and Engineering. Each dimension is refined into fine-grained\nsubtypes, illustrated with concrete examples and root cause analysis. Grounded\nin software engineering principles, we show how these defects surface in real\ndevelopment workflows and examine their downstream effects. For every subtype,\nwe distill mitigation strategies that span emerging prompt engineering\npatterns, automated guardrails, testing harnesses, and evaluation frameworks.\nWe then summarize these strategies in a master taxonomy that links defect,\nimpact, and remedy. We conclude with open research challenges and a call for\nrigorous engineering-oriented methodologies to ensure that LLM-driven systems\nare dependable by design.", "AI": {"tldr": "This paper introduces a first-of-its-kind taxonomy for prompt defects in LLMs, organized into six dimensions with mitigation strategies, advocating for systematic engineering practices to build reliable AI systems.", "motivation": "Prompt design for LLMs is currently empirical and error-prone, with small mistakes causing unreliable, insecure, or inefficient behavior. The paper aims to provide a structured framework to identify, categorize, and mitigate these defects systematically.", "method": "The authors conduct a systematic survey and taxonomy of prompt defects, organizing them into six dimensions with detailed subtypes, examples, and root cause analyses. Mitigation strategies are distilled into a master taxonomy linking defects to remedies.", "result": "The paper introduces a comprehensive taxonomy of prompt defects across six dimensions, accompanied by mitigation strategies (e.g., automated guardrails, testing frameworks). It also highlights open challenges and emphasizes engineering-oriented methodologies for dependable LLM systems.", "conclusion": "The paper concludes with a call for rigorous engineering methodologies to ensure dependable LLM-driven systems by addressing prompt defects systematically."}}
{"id": "2509.14604", "categories": ["cs.CR", "cs.ET"], "pdf": "https://arxiv.org/pdf/2509.14604", "abs": "https://arxiv.org/abs/2509.14604", "authors": ["Ramazan Yener", "Muhammad Hassan", "Masooda Bashir"], "title": "Threats and Security Strategies for IoMT Infusion Pumps", "comment": "9 pages. Published as a book chapter in Human Factors in\n  Cybersecurity (AHFE 2025)", "summary": "The integration of the Internet of Medical Things (IoMT) into healthcare\nsystems has transformed patient care by enabling real-time monitoring, enhanced\ndiagnostics, and enhanced operational efficiency. However, this increased\nconnectivity has also expanded the attack surface for cybercriminals, raising\nsignificant cybersecurity and privacy concerns. This study focuses on the\ncybersecurity vulnerabilities of IoMT infusion pumps, which are critical\ndevices in modern healthcare. Through a targeted literature review of the past\nfive years, we analyzed seven current studies from a pool of 132 papers to\nidentify security vulnerabilities. Our findings indicate that infusion pumps\nface vulnerabilities such as device-level flaws, authentication and access\ncontrol issues, network and communication weaknesses, data security and privacy\nrisks, and operational or organizational challenges that can expose them to\nlateral attacks within healthcare networks. Our analysis synthesizes findings\nfrom seven recent studies to clarify how and why infusion pumps remain\nvulnerable in each of these areas. By categorizing the security gaps, we\nhighlight critical risk patterns and their implications. This work underscores\nthe scope of the issue and provides a structured understanding that is valuable\nfor healthcare IT professionals and device manufacturers. Ultimately, the\nfindings can inform the development of targeted, proactive security strategies\nto better safeguard infusion pumps and protect patient well-being.", "AI": {"tldr": "This study analyzes cybersecurity vulnerabilities in IoMT infusion pumps through a review of 7 recent studies (from 132 papers), identifying security gaps in device-level flaws, authentication, network weaknesses, data privacy, and operational challenges to inform proactive security strategies.", "motivation": "The integration of IoMT into healthcare has increased cyber risks, particularly for critical devices like infusion pumps. This work addresses gaps in understanding their vulnerabilities to improve patient safety and healthcare IT resilience.", "method": "A systematic literature review of 7 studies (selected from 132 papers over five years), synthesizing findings on cybersecurity vulnerabilities in IoMT infusion pumps through categorical analysis of security gaps and risk patterns.", "result": "Identified vulnerabilities include device-level flaws, authentication/access control weaknesses, network communication risks, data privacy issues, and operational challenges. Analysis revealed recurring risk patterns across studies that expose infusion pumps to lateral attacks in healthcare networks.", "conclusion": "The study establishes a structured framework of security risks for IoMT infusion pumps, emphasizing the need for targeted mitigation strategies. It provides healthcare professionals and manufacturers with actionable insights to strengthen device security and protect patient well-being."}}
{"id": "2509.14483", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14483", "abs": "https://arxiv.org/abs/2509.14483", "authors": ["Thanh-Long Bui", "Hoa Khanh Dam", "Rashina Hoda"], "title": "An LLM-based multi-agent framework for agile effort estimation", "comment": "Submitted to ASE'25", "summary": "Effort estimation is a crucial activity in agile software development, where\nteams collaboratively review, discuss, and estimate the effort required to\ncomplete user stories in a product backlog. Current practices in agile effort\nestimation heavily rely on subjective assessments, leading to inaccuracies and\ninconsistencies in the estimates. While recent machine learning-based methods\nshow promising accuracy, they cannot explain or justify their estimates and\nlack the capability to interact with human team members. Our paper fills this\nsignificant gap by leveraging the powerful capabilities of Large Language\nModels (LLMs). We propose a novel LLM-based multi-agent framework for agile\nestimation that not only can produce estimates, but also can coordinate,\ncommunicate and discuss with human developers and other agents to reach a\nconsensus. Evaluation results on a real-life dataset show that our approach\noutperforms state-of-the-art techniques across all evaluation metrics in the\nmajority of the cases. Our human study with software development practitioners\nalso demonstrates an overwhelmingly positive experience in collaborating with\nour agents in agile effort estimation.", "AI": {"tldr": "The paper introduces an LLM-based multi-agent framework for agile software development effort estimation that outperforms existing methods and enhances collaboration with human team members.", "motivation": "Current agile effort estimation practices rely on subjective assessments, leading to inaccuracies and inconsistencies. Existing machine learning-based methods provide accurate estimates but lack the ability to explain or justify their predictions and interact with human team members.", "method": "The authors propose a novel Large Language Model (LLM)-based multi-agent framework designed for agile effort estimation. This framework enables agents to produce estimates, coordinate, communicate, and discuss with human developers and other agents to reach a consensus. The integration of LLMs allows for both estimation and interaction capabilities.", "result": "The evaluation results on a real-life dataset demonstrate that the LLM-based approach significantly outperforms existing state-of-the-art methods on most evaluation metrics and features a favorable collaborative user experience in agile estimation.", "conclusion": "The paper concludes that their LLM-based multi-agent framework effectively addresses the limitations of current agile estimation practices by offering accurate, explainable, and collaborative effort estimation."}}
{"id": "2509.14608", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.14608", "abs": "https://arxiv.org/abs/2509.14608", "authors": ["Shashank Shreedhar Bhatt", "Tanmay Rajore", "Khushboo Aggarwal", "Ganesh Ananthanarayanan", "Ranveer Chandra", "Nishanth Chandran", "Suyash Choudhury", "Divya Gupta", "Emre Kiciman", "Sumit Kumar Pandey", "Srinath Setty", "Rahul Sharma", "Teijia Zhao"], "title": "Enterprise AI Must Enforce Participant-Aware Access Control", "comment": null, "summary": "Large language models (LLMs) are increasingly deployed in enterprise settings\nwhere they interact with multiple users and are trained or fine-tuned on\nsensitive internal data. While fine-tuning enhances performance by\ninternalizing domain knowledge, it also introduces a critical security risk:\nleakage of confidential training data to unauthorized users. These risks are\nexacerbated when LLMs are combined with Retrieval-Augmented Generation (RAG)\npipelines that dynamically fetch contextual documents at inference time.\n  We demonstrate data exfiltration attacks on AI assistants where adversaries\ncan exploit current fine-tuning and RAG architectures to leak sensitive\ninformation by leveraging the lack of access control enforcement. We show that\nexisting defenses, including prompt sanitization, output filtering, system\nisolation, and training-level privacy mechanisms, are fundamentally\nprobabilistic and fail to offer robust protection against such attacks.\n  We take the position that only a deterministic and rigorous enforcement of\nfine-grained access control during both fine-tuning and RAG-based inference can\nreliably prevent the leakage of sensitive data to unauthorized recipients.\n  We introduce a framework centered on the principle that any content used in\ntraining, retrieval, or generation by an LLM is explicitly authorized for\n\\emph{all users involved in the interaction}. Our approach offers a simple yet\npowerful paradigm shift for building secure multi-user LLM systems that are\ngrounded in classical access control but adapted to the unique challenges of\nmodern AI workflows. Our solution has been deployed in Microsoft Copilot\nTuning, a product offering that enables organizations to fine-tune models using\ntheir own enterprise-specific data.", "AI": {"tldr": "This paper identifies security risks in enterprise LLMs when using fine-tuning and RAG pipelines due to weak access control. It introduces a deterministic authorization framework to prevent data leakage, validated through deployment in Microsoft's Copilot Tuning product.", "motivation": "The paper motivates that enterprise LLMs face critical security risks when trained on sensitive data and combined with RAG pipelines due to inadequate access control enforcement. Existing defenses fail to prevent data exfiltration attacks where adversaries exploit architectural weaknesses to leak confidential information.", "method": "The authors propose a framework requiring explicit authorization for all content used in LLM training, retrieval, or generation, ensuring strict access control enforcement for every user interaction. This contrasts with probabilistic defenses (prompt sanitization, output filtering) by demanding deterministic security guarantees.", "result": "The authors achieve deployment of their framework in Microsoft Copilot Tuning, demonstrating a practical implementation that enables secure fine-tuning of LLMs with enterprise-specific data while enforcing authorization across training and inference workflows.", "conclusion": "The paper concludes that deterministic enforcement of fine-grained access control during both fine-tuning and RAG-based inference is essential to prevent data leakage in multi-user LLM systems. This represents a paradigm shift from probabilistic to rigorous security measures grounded in classical access control principles."}}
{"id": "2509.14623", "categories": ["cs.SE", "cs.AI", "cs.PL", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2509.14623", "abs": "https://arxiv.org/abs/2509.14623", "authors": ["Hanlong Wan", "Xing Lu", "Yan Chen", "Karthik Devaprasad", "Laura Hinkle"], "title": "Automating Modelica Module Generation Using Large Language Models: A Case Study on Building Control Description Language", "comment": "This is the pre-peer-review version of a journal paper; the repo is\n  available at: https://github.com/pnnl/prompt2control", "summary": "Dynamic energy systems and controls require advanced modeling frameworks to\ndesign and test supervisory and fault tolerant strategies. Modelica is a widely\nused equation based language, but developing control modules is labor intensive\nand requires specialized expertise. This paper examines the use of large\nlanguage models (LLMs) to automate the generation of Control Description\nLanguage modules in the Building Modelica Library as a case study. We developed\na structured workflow that combines standardized prompt scaffolds, library\naware grounding, automated compilation with OpenModelica, and human in the loop\nevaluation. Experiments were carried out on four basic logic tasks (And, Or,\nNot, and Switch) and five control modules (chiller enable/disable, bypass valve\ncontrol, cooling tower fan speed, plant requests, and relief damper control).\nThe results showed that GPT 4o failed to produce executable Modelica code in\nzero shot mode, while Claude Sonnet 4 achieved up to full success for basic\nlogic blocks with carefully engineered prompts. For control modules, success\nrates reached 83 percent, and failed outputs required medium level human repair\n(estimated one to eight hours). Retrieval augmented generation often produced\nmismatches in module selection (for example, And retrieved as Or), while a\ndeterministic hard rule search strategy avoided these errors. Human evaluation\nalso outperformed AI evaluation, since current LLMs cannot assess simulation\nresults or validate behavioral correctness. Despite these limitations, the LLM\nassisted workflow reduced the average development time from 10 to 20 hours down\nto 4 to 6 hours per module, corresponding to 40 to 60 percent time savings.\nThese results highlight both the potential and current limitations of LLM\nassisted Modelica generation, and point to future research in pre simulation\nvalidation, stronger grounding, and closed loop evaluation.", "AI": {"tldr": "Error", "motivation": "Error", "method": "Error", "result": "Error", "conclusion": "Error"}}
{"id": "2509.14622", "categories": ["cs.CR", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14622", "abs": "https://arxiv.org/abs/2509.14622", "authors": ["Yihao Guo", "Haocheng Bian", "Liutong Zhou", "Ze Wang", "Zhaoyi Zhang", "Francois Kawala", "Milan Dean", "Ian Fischer", "Yuantao Peng", "Noyan Tokgozoglu", "Ivan Barrientos", "Riyaaz Shaik", "Rachel Li", "Chandru Venkataraman", "Reza Shifteh Far", "Moses Pawar", "Venkat Sundaranatha", "Michael Xu", "Frank Chu"], "title": "Adversarial Distilled Retrieval-Augmented Guarding Model for Online Malicious Intent Detection", "comment": null, "summary": "With the deployment of Large Language Models (LLMs) in interactive\napplications, online malicious intent detection has become increasingly\ncritical. However, existing approaches fall short of handling diverse and\ncomplex user queries in real time. To address these challenges, we introduce\nADRAG (Adversarial Distilled Retrieval-Augmented Guard), a two-stage framework\nfor robust and efficient online malicious intent detection. In the training\nstage, a high-capacity teacher model is trained on adversarially perturbed,\nretrieval-augmented inputs to learn robust decision boundaries over diverse and\ncomplex user queries. In the inference stage, a distillation scheduler\ntransfers the teacher's knowledge into a compact student model, with a\ncontinually updated knowledge base collected online. At deployment, the compact\nstudent model leverages top-K similar safety exemplars retrieved from the\nonline-updated knowledge base to enable both online and real-time malicious\nquery detection. Evaluations across ten safety benchmarks demonstrate that\nADRAG, with a 149M-parameter model, achieves 98.5% of WildGuard-7B's\nperformance, surpasses GPT-4 by 3.3% and Llama-Guard-3-8B by 9.5% on\nout-of-distribution detection, while simultaneously delivering up to 5.6x lower\nlatency at 300 queries per second (QPS) in real-time applications.", "AI": {"tldr": "ADRAG is a two-stage framework for online malicious intent detection using adversarial training and knowledge distillation, achieving high accuracy with low latency.", "motivation": "Existing methods fail to handle diverse, complex real-time user queries. Large model latency and poor out-of-distribution detection necessitate a robust, efficient solution.", "method": "1) Train a teacher model on adversarially perturbed, retrieval-augmented inputs. 2 Distill training into a compact student model using a dynamic online knowledge base of safety exemplars for inference.", "result": "ADRAG (149M param) matches 98.5%i WildGuard-7B's performance, exceeds GPT-4 by 3.3%i and Llama-Guard-3-8B by 9.5%i on out-of-distribution detection, with 5.6\u00d7 lower latency (300 QPS).", "conclusion": "ADRAG provides scalable, real-time malicious intent detection through adversarial training, knowledge distillation, and dynamic retrieval, outperforming larger models in accuracy and efficiency."}}
{"id": "2509.14626", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14626", "abs": "https://arxiv.org/abs/2509.14626", "authors": ["Feiran Qin", "M. M. Abid Naziri", "Hengyu Ai", "Saikat Dutta", "Marcelo d'Amorim"], "title": "Evaluating the Effectiveness of Coverage-Guided Fuzzing for Testing Deep Learning Library APIs", "comment": null, "summary": "Deep Learning (DL) libraries such as PyTorch provide the core components to\nbuild major AI-enabled applications. Finding bugs in these libraries is\nimportant and challenging. Prior approaches have tackled this by performing\neither API-level fuzzing or model-level fuzzing, but they do not use coverage\nguidance, which limits their effectiveness and efficiency. This raises an\nintriguing question: can coverage guided fuzzing (CGF), in particular\nframeworks like LibFuzzer, be effectively applied to DL libraries, and does it\noffer meaningful improvements in code coverage, bug detection, and scalability\ncompared to prior methods?\n  We present the first in-depth study to answer this question. A key challenge\nin applying CGF to DL libraries is the need to create a test harness for each\nAPI that can transform byte-level fuzzer inputs into valid API inputs. To\naddress this, we propose FlashFuzz, a technique that leverages Large Language\nModels (LLMs) to automatically synthesize API-level harnesses by combining\ntemplates, helper functions, and API documentation. FlashFuzz uses a feedback\ndriven strategy to iteratively synthesize and repair harnesses. With this\napproach, FlashFuzz synthesizes harnesses for 1,151 PyTorch and 662 TensorFlow\nAPIs. Compared to state-of-the-art fuzzing methods (ACETest, PathFinder, and\nTitanFuzz), FlashFuzz achieves up to 101.13 to 212.88 percent higher coverage\nand 1.0x to 5.4x higher validity rate, while also delivering 1x to 1182x\nspeedups in input generation. FlashFuzz has discovered 42 previously unknown\nbugs in PyTorch and TensorFlow, 8 of which are already fixed. Our study\nconfirms that CGF can be effectively applied to DL libraries and provides a\nstrong baseline for future testing approaches.", "AI": {"tldr": "This paper proposes FlashFuzz, an LLM-based coverage-guided fuzzing technique for deep learning libraries. FlashFuzz synthesizes API harnesses using templates and documentation, achieving significant improvements in code coverage, bug detection, and speed compared to existing methods, with 42 new bugs discovered in PyTorch/TensorFlow.", "motivation": "Current DL library testing methods (API-level/model-level fuzzing without coverage-guidance) face limitations in effectiveness and efficiency. No prior work has successfully applied coverage-guided fuzzing (CGF), which requires test harnesses for each API, a manual and laborious process.", "method": "FlashFuzz automatically generates and refines API test harnesses using Large Language Models (LLMs). It combines documentation, templates, and helper functions with a feedback-driven synthesis/repair mechanism. Applied to 1,151 PyTorch and 662 TensorFlow APIs.", "result": "FlashFuzz outperformed state-of-the-art methods (ACETest/PathFinder/TitanFuzz): 101-212.88x higher coverage, 1-5.4x better validity rate, 1-1182x faster input generation. Discovered 42 new bugs, 8 of which were patched.", "conclusion": "CGF is feasible and effective for DL libraries through automated harness generation. FlashFuzz establishes a strong baseline for future testing approaches and demonstrates concrete bug detection capabilities."}}
{"id": "2509.14657", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.14657", "abs": "https://arxiv.org/abs/2509.14657", "authors": ["Sergio Benlloch-Lopez", "Miquel Viel-Vazquez", "Javier Naranjo-Alcazar", "Jordi Grau-Haro", "Pedro Zuccarello"], "title": "Threat Modeling for Enhancing Security of IoT Audio Classification Devices under a Secure Protocols Framework", "comment": "Accepted at Computing Conference 2026, London, UK", "summary": "The rapid proliferation of IoT nodes equipped with microphones and capable of\nperforming on-device audio classification exposes highly sensitive data while\noperating under tight resource constraints. To protect against this, we present\na defence-in-depth architecture comprising a security protocol that treats the\nedge device, cellular network and cloud backend as three separate trust\ndomains, linked by TPM-based remote attestation and mutually authenticated TLS\n1.3. A STRIDE-driven threat model and attack-tree analysis guide the design. At\nstartup, each boot stage is measured into TPM PCRs. The node can only decrypt\nits LUKS-sealed partitions after the cloud has verified a TPM quote and\nreleased a one-time unlock key. This ensures that rogue or tampered devices\nremain inert. Data in transit is protected by TLS 1.3 and hybridised with Kyber\nand Dilithium to provide post-quantum resilience. Meanwhile, end-to-end\nencryption and integrity hashes safeguard extracted audio features. Signed,\nrollback-protected AI models and tamper-responsive sensors harden firmware and\nhardware. Data at rest follows a 3-2-1 strategy comprising a solid-state drive\nsealed with LUKS, an offline cold archive encrypted with a hybrid post-quantum\ncipher and an encrypted cloud replica. Finally, we set out a plan for\nevaluating the physical and logical security of the proposed protocol.", "AI": {"tldr": "This paper presents a multi-layered IoT security architecture using hardware attestation, post-quantum cryptography, and 3-2-1 data storage to protect audio-sensitive devices from tampering and unauthorized access.", "motivation": "The proliferation of IoT audio devices creates exposure of sensitive data under severe resource constraints while risking compromise due to tampering at any system layer. Traditional security approaches are inadequate for this scenario.", "method": "The system employs a three-domain security framework (edge, network, cloud) using TPM-based remote attestation and TLS 1.3 with Kyber/Dilithium post-quantum hybridization. Secure boot measurements via TPM PCRs, LUKS disk encryption with cloud-verified unlock keys, end-to-end audio feature protection, and a 3-2-1 storage strategy (LUKS-encrypted SSD, hybrid-encrypted offline archive, cloud replica) are central to the design. STRIDE threat modeling and attack-tree analysis guide implementation.", "result": "The protocol achieves boot-time integrity verification, post-quantum resilient communications, tamper-proof firmware through signed models, and comprehensive data-at-rest protections. Physical tamper-responsiveness and a detailed evaluation plan are also established.", "conclusion": "The proposed defense-in-depth architecture combines hardware-based attestation, post-quantum cryptography, and robust data protection to comprehensively secure IoT audio devices against cyber and physical threats."}}
{"id": "2509.14646", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.14646", "abs": "https://arxiv.org/abs/2509.14646", "authors": ["Yongpan Wang", "Xin Xu", "Xiaojie Zhu", "Xiaodong Gu", "Beijun Shen"], "title": "SALT4Decompile: Inferring Source-level Abstract Logic Tree for LLM-Based Binary Decompilation", "comment": "13 pages, 7 figures", "summary": "Decompilation is widely used in reverse engineering to recover high-level\nlanguage code from binary executables. While recent approaches leveraging Large\nLanguage Models (LLMs) have shown promising progress, they typically treat\nassembly code as a linear sequence of instructions, overlooking arbitrary jump\npatterns and isolated data segments inherent to binary files. This limitation\nsignificantly hinders their ability to correctly infer source code semantics\nfrom assembly code. To address this limitation, we propose \\saltm, a novel\nbinary decompilation method that abstracts stable logical features shared\nbetween binary and source code. The core idea of \\saltm is to abstract selected\nbinary-level operations, such as specific jumps, into a high-level logic\nframework that better guides LLMs in semantic recovery. Given a binary\nfunction, \\saltm constructs a Source-level Abstract Logic Tree (\\salt) from\nassembly code to approximate the logic structure of high-level language. It\nthen fine-tunes an LLM using the reconstructed \\salt to generate decompiled\ncode. Finally, the output is refined through error correction and symbol\nrecovery to improve readability and correctness. We compare \\saltm to three\ncategories of baselines (general-purpose LLMs, commercial decompilers, and\ndecompilation methods) using three well-known datasets (Decompile-Eval, MBPP,\nExebench). Our experimental results demonstrate that \\saltm is highly effective\nin recovering the logic of the source code, significantly outperforming\nstate-of-the-art methods (e.g., 70.4\\% TCP rate on Decompile-Eval with a 10.6\\%\nimprovement). The results further validate its robustness against four commonly\nused obfuscation techniques. Additionally, analyses of real-world software and\na user study confirm that our decompiled output offers superior assistance to\nhuman analysts in comprehending binary functions.", "AI": {"tldr": "SaltM is a binary decompilation framework that abstracts binary operations into a high-level logic tree to guide LLMs, achieving state-of-the-art accuracy (70.4% TCP) and robustness against obfuscation, while improving readability and analyst efficiency in reverse engineering.", "motivation": "Traditional decompilation approaches using LLMs treat assembly code as linear instruction sequences, ignoring arbitrary jump patterns and isolated data segments critical for source code semantics. This limitation impairs their ability to infer accurate program logic.", "method": "SaltM constructs a Source-level Abstract Logic Tree (Salt) to abstract binary operations (e.g., jumps) into high-level logic. It fine-tunes an LLM using the Salt tree for semantic recovery, followed by error correction and symbol recovery to generate decompiled code.", "result": "SaltM achieves a 70.4% TCP rate on Decompile-Eval (10.6% improvement over SOTA), validates robustness against four obfuscation techniques, and outperforms baselines across three datasets (Decompile-Eval, MBPP, Exebench). Real-world evaluations and a user study confirm its practical effectiveness for human analysts.", "conclusion": "SaltM significantly outperforms existing state-of-the-art decompilation methods by effectively recovering source code logic through abstracting binary operations into a high-level structure. It demonstrates robustness against obfuscation techniques and provides superior assistance to human analysts in understanding binary functions."}}
{"id": "2509.14706", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2509.14706", "abs": "https://arxiv.org/abs/2509.14706", "authors": ["Yonghao Ni", "Zhongwen Li", "Xiaoqi Li"], "title": "Security Analysis of Web Applications Based on Gruyere", "comment": null, "summary": "With the rapid development of Internet technologies, web systems have become\nessential infrastructures for modern information exchange and business\noperations. However, alongside their expansion, numerous security\nvulnerabilities have emerged, making web security a critical research focus\nwithin the broader field of cybersecurity. These issues are closely related to\ndata protection, privacy preservation, and business continuity, and systematic\nresearch on web security is crucial for mitigating malicious attacks and\nenhancing the reliability and robustness of network systems. This paper first\nreviews the OWASP Top 10, summarizing the types, causes, and impacts of common\nweb vulnerabilities, and illustrates their exploitation mechanisms through\nrepresentative cases. Building upon this, the Gruyere platform is adopted as an\nexperimental subject for analyzing known vulnerabilities. The study presents\ndetailed reproduction steps for specific vulnerabilities, proposes\ncomprehensive remediation strategies, and further compares Gruyere's\nvulnerabilities with contemporary real-world cases. The findings suggest that,\nalthough Gruyere's vulnerabilities are relatively outdated, their underlying\nprinciples remain highly relevant for explaining a wide range of modern\nsecurity flaws. Overall, this research demonstrates that web system security\nanalysis based on Gruyere not only deepens the understanding of vulnerability\nmechanisms but also provides practical support for technological innovation and\nsecurity defense.", "AI": {"tldr": "The paper examines web security through the lens of the OWASP Top 10 vulnerabilities and the Gruyere platform, highlighting the enduring relevance of older vulnerabilities to modern security challenges.", "motivation": "The motivation stems from the growing importance of web systems and the associated security risks, which necessitate systematic research to protect data, privacy, and ensure business continuity.", "method": "The method involves reviewing the OWASP Top 10 to identify and explain vulnerabilities, followed by an in-depth analysis of the Gruyere platform to reproduce and address known flaws through case studies.", "result": "The study showcases how to replicate and resolve the vulnerabilities in Gruyere, drawing connections to contemporary cases and showing their ongoing relevance.", "conclusion": "The conclusion emphasizes the value of using Gruyere-based web security analysis for enhancing understanding of vulnerabilities, which supports technological innovation and contemporary security defense strategies."}}
{"id": "2509.14740", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14740", "abs": "https://arxiv.org/abs/2509.14740", "authors": ["Andrei-Raoul Morariu", "Andreas Strandberg", "Bogdan Iancu", "Jerker Bjorkqvist"], "title": "Wireless Communication Performance Testing: From Laboratory Environment to Research Vessel", "comment": "5 pages, 4 figures, 2 tables", "summary": "This study investigates signal transmission within a shared spectrum,\nfocusing on measurements conducted both in laboratory and outdoor environments.\nThe objective was to demonstrate how laboratory objects obstructing the line of\nsight can attenuate the signal between a transmitter (Tx) and a receiver (Rx).\nAdditionally, we examined the impact of distance and placement in various\nlocations aboard an electric research boat on signal transmission efficiency.\nThese findings contribute to understanding whether the environmental factors\ninfluence wireless communication in dynamic and obstructed environments.", "AI": {"tldr": "This study examines how laboratory objects and environment factors like distance/placement on a moving boat affect wireless signal transmission efficiency in shared spectrums. Key findings indicate environmental obstructions significantly impede communication. ", "motivation": "The paper aims to evaluate how physical obstructions and placement variations in dynamic, complex environments impact wireless communication reliability. Understanding these factors helps design robust systems.", "method": "Experiments combined lab-based line-of-sight obstruction simulations with field measurements on an electric research boat, varying Tx/Rx placement and distances.", "result": "Lab obstructions caused measurable signal attenuation, while boat experiments demonstrated environment-specific transmission losses due to placement and distance.", "conclusion": "The paper concludes that environmental factors critically influence wireless communication in obstructed/dynamic settings, requiring tailored system designs to mitigate these effects."}}
{"id": "2509.14754", "categories": ["cs.CR", "G.2.0"], "pdf": "https://arxiv.org/pdf/2509.14754", "abs": "https://arxiv.org/abs/2509.14754", "authors": ["Minzhong Luo", "Yudong Sun", "Yin Long"], "title": "Variables Ordering Optimization in Boolean Characteristic Set Method Using Simulated Annealing and Machine Learning-based Time Prediction", "comment": null, "summary": "Solving systems of Boolean equations is a fundamental task in symbolic\ncomputation and algebraic cryptanalysis, with wide-ranging applications in\ncryptography, coding theory, and formal verification. Among existing\napproaches, the Boolean Characteristic Set (BCS) method[1] has emerged as one\nof the most efficient algorithms for tackling such problems. However, its\nperformance is highly sensitive to the ordering of variables, with solving\ntimes varying drastically under different orderings for fixed variable counts n\nand equations size m. To address this challenge, this paper introduces a novel\noptimization framework that synergistically integrates machine learning\n(ML)-based time prediction with simulated annealing (SA) to efficiently\nidentify high-performance variables orderings. Weconstruct a dataset comprising\nvariable frequency spectrum X and corresponding BCS solving time t for\nbenchmark systems(e.g., n = m = 28). Utilizing this data, we train an accurate\nML predictor ft(X) to estimate solving time for any given variables ordering.\nFor each target system, ft serves as the cost function within an SA algorithm,\nenabling rapid discovery of low-latency orderings that significantly expedite\nsubsequent BCS execution. Extensive experiments demonstrate that our method\nsubstantially outperforms the standard BCS algorithm[1], Gr\\\"obner basis method\n[2] and SAT solver[3], particularly for larger-scale systems(e.g., n = 32).\nFurthermore, we derive probabilistic time complexity bounds for the overall\nalgorithm using stochastic process theory, establishing a quantitative\nrelationship between predictor accuracy and expected solving complexity. This\nwork provides both a practical acceleration tool for algebraic cryptanalysis\nand a theoretical foundation for ML-enhanced combinatorial optimization in\nsymbolic computation.", "AI": {"tldr": "Combines ML and simulated annealing to optimize variable orderings for solving Boolean equations, significantly improving performance over existing methods.", "motivation": "The BCS method's performance is highly sensitive to variable ordering, causing unpredictable solving times. Existing approaches lack systematic methods to optimize orderings, motivating the need for a robust solution to improve efficiency in symbolic computation.", "method": "The framework combines machine learning (ML)-based time prediction with simulated annealing (SA). It uses a dataset of variable frequency spectra and corresponding BCS solving times to train an ML predictor, which guides the SA algorithm to identify optimal variable orderings.", "result": "Extensive experiments show the framework outperforms BCS, Gr\u00f6bner basis methods, and SAT solvers, particularly for larger systems. Probabilistic time complexity bounds are derived, linking predictor accuracy to solving efficiency.", "conclusion": "This paper introduces an ML-integrated optimization framework that enhances the Boolean Characteristic Set method, offering both practical efficiency gains for algebraic cryptanalysis and theoretical insights into ML-driven combinatorial optimization."}}
{"id": "2509.14744", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14744", "abs": "https://arxiv.org/abs/2509.14744", "authors": ["Worawalan Chatlatanagulchai", "Kundjanasith Thonglek", "Brittany Reid", "Yutaro Kashiwa", "Pattara Leelaprute", "Arnon Rungsawang", "Bundit Manaskasemsak", "Hajimu Iida"], "title": "On the Use of Agentic Coding Manifests: An Empirical Study of Claude Code", "comment": null, "summary": "Agentic coding tools receive goals written in natural language as input,\nbreak them down into specific tasks, and write/execute the actual code with\nminimal human intervention. Key to this process are agent manifests,\nconfiguration files (such as Claude.md) that provide agents with essential\nproject context, identity, and operational rules. However, the lack of\ncomprehensive and accessible documentation for creating these manifests\npresents a significant challenge for developers. We analyzed 253 Claude.md\nfiles from 242 repositories to identify structural patterns and common content.\nOur findings show that manifests typically have shallow hierarchies with one\nmain heading and several subsections, with content dominated by operational\ncommands, technical implementation notes, and high-level architecture.", "AI": {"tldr": "The paper analyzes 253 Claude.md agent manifests to reveal shallow hierarchical structures and content patterns dominated by operational instructions and technical notes, highlighting a need for better documentation to aid developers.", "motivation": "The lack of clear documentation for creating agent manifests like Claude.md poses challenges for developers, prompting this study to identify structural and content patterns to guide their creation.", "method": "Analyzed 253 Claude.md files from 242 repositories to identify common structural and content patterns through qualitative analysis.", "result": "Manifests exhibit shallow hierarchies (one main heading with subsections) containing operational commands (60%), technical implementation notes (25%), and high-level architecture (15%).", "conclusion": "The findings provide actionable insights for developers to structure manifests more effectively and motivate the creation of standardized documentation for agent configuration files."}}
{"id": "2509.14987", "categories": ["cs.CR", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14987", "abs": "https://arxiv.org/abs/2509.14987", "authors": ["Md Talha Mohsin"], "title": "Blockchain-Enabled Explainable AI for Trusted Healthcare Systems", "comment": "6 Pages, 4 Figures", "summary": "This paper introduces a Blockchain-Integrated Explainable AI Framework (BXHF)\nfor healthcare systems to tackle two essential challenges confronting health\ninformation networks: safe data exchange and comprehensible AI-driven clinical\ndecision-making. Our architecture incorporates blockchain, ensuring patient\nrecords are immutable, auditable, and tamper-proof, alongside Explainable AI\n(XAI) methodologies that yield transparent and clinically relevant model\npredictions. By incorporating security assurances and interpretability\nrequirements into a unified optimization pipeline, BXHF ensures both data-level\ntrust (by verified and encrypted record sharing) and decision-level trust (with\nauditable and clinically aligned explanations). Its hybrid edge-cloud\narchitecture allows for federated computation across different institutions,\nenabling collaborative analytics while protecting patient privacy. We\ndemonstrate the framework's applicability through use cases such as\ncross-border clinical research networks, uncommon illness detection and\nhigh-risk intervention decision support. By ensuring transparency,\nauditability, and regulatory compliance, BXHF improves the credibility, uptake,\nand effectiveness of AI in healthcare, laying the groundwork for safer and more\nreliable clinical decision-making.", "AI": {"tldr": "BXHF combines blockchain and XAI to secure healthcare data and explain AI decisions, enabling privacy-preserving collaboration and compliant clinical AI.", "motivation": "Healthcare systems face challenges in safe data exchange and comprehensible AI-driven clinical decisions. The paper addresses these by combining blockchain security with explainable AI to establish trust at both data and decision levels.", "method": "BXHF integrates blockchain for immutable, auditable patient records and XAI methodologies to provide transparent predictions. It uses a hybrid edge-cloud architecture for federated computation across institutions, combining security and interpretability in a unified optimization pipeline.", "result": "The framework is demonstrated through use cases including cross-border clinical research, uncommon illness detection, and high-risk intervention support, showing its ability to enable collaborative analytics while protecting privacy.", "conclusion": "BXHF improves the credibility, uptake, and effectiveness of AI in healthcare by ensuring transparency, auditability, and regulatory compliance, laying the groundwork for safer and more reliable clinical decision-making."}}
{"id": "2509.14745", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14745", "abs": "https://arxiv.org/abs/2509.14745", "authors": ["Miku Watanabe", "Hao Li", "Yutaro Kashiwa", "Brittany Reid", "Hajimu Iida", "Ahmed E. Hassan"], "title": "On the Use of Agentic Coding: An Empirical Study of Pull Requests on GitHub", "comment": null, "summary": "Large language models (LLMs) are increasingly being integrated into software\ndevelopment processes. The ability to generate code and submit pull requests\nwith minimal human intervention, through the use of autonomous AI agents, is\npoised to become a standard practice. However, little is known about the\npractical usefulness of these pull requests and the extent to which their\ncontributions are accepted in real-world projects. In this paper, we\nempirically study 567 GitHub pull requests (PRs) generated using Claude Code,\nan agentic coding tool, across 157 diverse open-source projects. Our analysis\nreveals that developers tend to rely on agents for tasks such as refactoring,\ndocumentation, and testing. The results indicate that 83.8% of these\nagent-assisted PRs are eventually accepted and merged by project maintainers,\nwith 54.9% of the merged PRs are integrated without further modification. The\nremaining 45.1% require additional changes benefit from human revisions,\nespecially for bug fixes, documentation, and adherence to project-specific\nstandards. These findings suggest that while agent-assisted PRs are largely\nacceptable, they still benefit from human oversight and refinement.", "AI": {"tldr": "Autonomous LLM-generated PRs have high acceptance rates (83.8%) but often need human refinement for complex tasks like bug fixes and style compliance, demonstrating their value is maximized with hybrid human-AI collaboration.", "motivation": "The paper aims to address the gap in understanding whether autonomous LLM-generated pull requests (PRs) are practically useful and accepted in real-world software development workflows.", "method": "The authors empirically analyzed 567 GitHub pull requests (PRs) generated using Claude Code across 157 open-source projects, evaluating acceptance rates and the extent of modifications required during integration.", "result": "83.8% of agent-assisted PRs were accepted, with 54.9% merged without modification. The remaining 45.1% required human revisions, especially for debugging, documentation improvements, and project-style compliance.", "conclusion": "The study concludes that agent-assisted pull requests (PRs) are largely acceptable in open-source projects but still require human oversight for refinement, particularly for complex tasks like bug fixes and adherence to project standards."}}
{"id": "2509.15170", "categories": ["cs.CR", "cs.AI", "eess.SP"], "pdf": "https://arxiv.org/pdf/2509.15170", "abs": "https://arxiv.org/abs/2509.15170", "authors": ["Aarushi Mahajan", "Wayne Burleson"], "title": "Watermarking and Anomaly Detection in Machine Learning Models for LORA RF Fingerprinting", "comment": "IEEE International Conference on Acoustics, Speech, and Signal\n  Processing (ICASSP)", "summary": "Radio frequency fingerprint identification (RFFI) distinguishes wireless\ndevices by the small variations in their analog circuits, avoiding heavy\ncryptographic authentication. While deep learning on spectrograms improves\naccuracy, models remain vulnerable to copying, tampering, and evasion. We\npresent a stronger RFFI system combining watermarking for ownership proof and\nanomaly detection for spotting suspicious inputs. Using a ResNet-34 on log-Mel\nspectrograms, we embed three watermarks: a simple trigger, an adversarially\ntrained trigger robust to noise and filtering, and a hidden gradient/weight\nsignature. A convolutional Variational Autoencoders (VAE) with Kullback-Leibler\n(KL) warm-up and free-bits flags off-distribution queries. On the LoRa dataset,\nour system achieves 94.6% accuracy, 98% watermark success, and 0.94 AUROC,\noffering verifiable, tamper-resistant authentication.", "AI": {"tldr": "This paper proposes a secure RFFI system combining watermarks and anomaly detection, outperforming previous methods with 94.6% accuracy and robust authentication features.", "motivation": "Existing deep learning RFFI methods using spectrograms are vulnerable to copying, tampering, and evasion attacks, requiring stronger authentication mechanisms.", "method": "Combines watermarking (simple trigger, adversarial trigger, gradient/weight signature) and anomaly detection (ResNet-34 on log-Mel spectrograms + convolutional VAE with KL warm-up and free-bits) for RFFI.", "result": "Achieves 94.6% accuracy, 98% watermark success rate, and 0.94 AUROC on LoRa dataset.", "conclusion": "The proposed RFFI system offers verifiable, tamper-resistant authentication with high accuracy and effective watermarking."}}
{"id": "2509.14829", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14829", "abs": "https://arxiv.org/abs/2509.14829", "authors": ["Shuo Jin", "Songqiang Chen", "Xiaoyuan Xie", "Shing-Chi Cheung"], "title": "RulER: Automated Rule-Based Semantic Error Localization and Repair for Code Translation", "comment": "Due to the limitation \"The abstract field cannot be longer than 1,920\n  characters\", the abstract here is shorter than that in the PDF file", "summary": "Automated code translation aims to convert programs between different\nprogramming languages while maintaining their functionality. Due to the\nimperfections of code translation models, the generated translations may\ncontain errors that compromise their reliability. Existing automated debugging\nmethods for code translation rely on code alignments and repair patch templates\nto locate and fix erroneous translations. However, existing methods lack\nreliable references to construct code alignments and design repair patch\ntemplates, which significantly impacts their localization accuracy and repair\neffectiveness. To address these limitations, we reintroduce code translation\nrules and propose a rule-based debugging method for code translation, called\nRulER. RulER automatically derives code translation rules from correct\ntranslations generated by LLMs, enabling the efficient collection of diverse\ntranslation rules. In addition, RulER dynamically combines the existing rules\non expandable nodes like expressions and tokens to further adaptively align\nmore statements. These rules capture clear and detailed structural\ncorrespondences between source and target programming languages. Therefore,\nthey can serve as reliable and reusable references for code alignment and\nrepair template design, enabling RulER to locate and fix translation errors\neffectively. Our evaluation of RulER on Java-to-C++ and Python-to-C++\ntranslations produced by four code translation models demonstrates that RulER\noutperforms state-of-the-art methods, BatFix and TransMap. Our experimental\nresults show that RulER outperformed the best baseline by 20% and 272% in terms\nof error localization rates and repair success rates, respectively. RulER\nexhibits superior repair performance compared to directly prompting LLMs for\npatch generation, demonstrating a promising methodology for extracting and\nleveraging coding knowledge from LLMs.", "AI": {"tldr": "RulER is a rule-based debugging method for code translation that uses automatically derived translation rules from LLMs to improve error localization and repair, outperforming existing methods by 20-272%.", "motivation": "Existing code translation debugging methods struggle with unreliable code alignments and repair templates, leading to low localization accuracy and ineffective repairs due to imperfect translation models.", "method": "RulER derives translation rules from LLM-generated correct translations, dynamically combines rules on expandable nodes (expressions/tokens) for adaptive alignment, and uses these rules as reliable references for precise error localization and repair.", "result": "RulER outperformed baseline methods (BatFix, TransMap, direct LLM prompting) by 20-272% in Java-to-C++ and Python-to-C++ translation repair, achieving higher error localization and success rates.", "conclusion": "RulER demonstrates that leveraging rule-based translation knowledge from LLMs provides a superior methodology for reliable code translation debugging, offering clear structural correspondences and reusable repair strategies."}}
{"id": "2509.15202", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2509.15202", "abs": "https://arxiv.org/abs/2509.15202", "authors": ["Yuanbo Xie", "Yingjie Zhang", "Tianyun Liu", "Duohe Ma", "Tingwen Liu"], "title": "Beyond Surface Alignment: Rebuilding LLMs Safety Mechanism via Probabilistically Ablating Refusal Direction", "comment": "Accepted by EMNLP2025 Finding", "summary": "Jailbreak attacks pose persistent threats to large language models (LLMs).\nCurrent safety alignment methods have attempted to address these issues, but\nthey experience two significant limitations: insufficient safety alignment\ndepth and unrobust internal defense mechanisms. These limitations make them\nvulnerable to adversarial attacks such as prefilling and refusal direction\nmanipulation. We introduce DeepRefusal, a robust safety alignment framework\nthat overcomes these issues. DeepRefusal forces the model to dynamically\nrebuild its refusal mechanisms from jailbreak states. This is achieved by\nprobabilistically ablating the refusal direction across layers and token depths\nduring fine-tuning. Our method not only defends against prefilling and refusal\ndirection attacks but also demonstrates strong resilience against other unseen\njailbreak strategies. Extensive evaluations on four open-source LLM families\nand six representative attacks show that DeepRefusal reduces attack success\nrates by approximately 95%, while maintaining model capabilities with minimal\nperformance degradation.", "AI": {"tldr": "The paper introduces DeepRefusal, a robust safety alignment framework that dynamically rebuilds refusal mechanisms from jailbreak states to defend against attacks, reducing success rates by ~95%.", "motivation": "Current safety alignment methods lack depth and robust internel defense, making them vulnerable to attacks like prefilling and refusal direction manipulation.", "method": "DeepRefusal dynamically rebuilds refusal mechanisms by probabilistically ablating the refusal direction during fine-tuning across layers and token depths.", "result": "DeepRefusal reduced attack success rates by ~95% on four open-source LLMs and six attacks with minimal performance loss.", "conclusion": "DeepRefusal provides a robust safety alignment framework that addresses previous limitations and defends against various jailbreak strategies."}}
{"id": "2509.14856", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14856", "abs": "https://arxiv.org/abs/2509.14856", "authors": ["Hanyang Guo", "Xunjin Zheng", "Zihan Liao", "Hang Yu", "Peng DI", "Ziyin Zhang", "Hong-Ning Dai"], "title": "CodeFuse-CR-Bench: A Comprehensiveness-aware Benchmark for End-to-End Code Review Evaluation in Python Projects", "comment": null, "summary": "Automated code review (CR) is a key application for Large Language Models\n(LLMs), but progress is hampered by a \"reality gap\": existing benchmarks\nevaluate models on isolated sub-tasks using simplified, context-poor data. This\nfails to reflect the holistic context-rich nature of real-world CR. To bridge\nthis gap, we introduce CodeFuse-CR-Bench, the first comprehensiveness-aware\nbenchmark for repository-level CR evaluation. CodeFuse-CR-Bench comprises 601\nhigh-quality instances from 70 Python projects covering nine Pull-Request (PR)\nproblem domains, where each instance provides rich, multi-faceted context\nincluding the associated issue, PR details, and repository state, enabling\nend-to-end evaluation. Beyond superficial metrics, we also propose a novel\nevaluation framework that combines rule-based checks for location and syntax\nwith model-based judgments of review quality. We present the first large-scale\nassessment of state-of-the-art LLMs on this comprehensive CR task. Our results\nestablish crucial baselines and reveal that (1) no single LLM dominates all\naspects of CR; (2) Gemini 2.5 Pro achieves the highest comprehensive\nperformance; and (3) different LLMs exhibit varying robustness to redundant\ncontext. These findings highlight the necessity of holistic, multi-dimensional\nevaluation and provide actionable insights for advancing truly intelligent yet\npractical CR assistants.", "AI": {"tldr": "This paper introduces CodeFuse-CR-Bench, a repository-level benchmark for holistic code review evaluation of LLMs, addressing existing benchmarks\u2019 lack of real-world context. It proposes a mixed evaluation framework combining rule-based checks with model-based judgments, revealing Gemini 2.5 Pro\u2019s leading performance and diverse LLM robustness to contextual noise.", "motivation": "Current benchmarks for LLM-based code review (CR) use isolated tasks and simplified data, failing to capture the complex, context-rich nature of real-world CR. This limits their utility for practical LLM development.", "method": "The authors created CodeFuse-CR-Bench (601 PRs across 70 projects, 9 domains), providing multi-faceted context (issue descriptions, PR details, repo states). They designed an evaluation framework with rule-based (location/syntax validation) and model-based (quality scoring) metrics, testing state-of-the-art LLMs.", "result": "Key findings: (1\uff09No LLM dominates all CR aspects; (2\uff09Gemini 2.5 Pro achieves highest comprehensive performance; (3\uff09LLMs show varied robustness to redundant context. Quantitative results establish baselines for future work.", "conclusion": "The study underscores the necessity of holistic, multi-dimensional evaluation frameworks for CR systems. CodeFuse-CR-Bench and its methodology provide actionable insights for developing practical, context-aware CR assistants while exposing gaps in current LLM capabilities."}}
{"id": "2509.15213", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2509.15213", "abs": "https://arxiv.org/abs/2509.15213", "authors": ["Yicheng Zhang", "Zijian Huang", "Sophie Chen", "Erfan Shayegani", "Jiasi Chen", "Nael Abu-Ghazaleh"], "title": "Evil Vizier: Vulnerabilities of LLM-Integrated XR Systems", "comment": null, "summary": "Extended reality (XR) applications increasingly integrate Large Language\nModels (LLMs) to enhance user experience, scene understanding, and even\ngenerate executable XR content, and are often called \"AI glasses\". Despite\nthese potential benefits, the integrated XR-LLM pipeline makes XR applications\nvulnerable to new forms of attacks. In this paper, we analyze LLM-Integated XR\nsystems in the literature and in practice and categorize them along different\ndimensions from a systems perspective. Building on this categorization, we\nidentify a common threat model and demonstrate a series of proof-of-concept\nattacks on multiple XR platforms that employ various LLM models (Meta Quest 3,\nMeta Ray-Ban, Android, and Microsoft HoloLens 2 running Llama and GPT models).\nAlthough these platforms each implement LLM integration differently, they share\nvulnerabilities where an attacker can modify the public context surrounding a\nlegitimate LLM query, resulting in erroneous visual or auditory feedback to\nusers, thus compromising their safety or privacy, sowing confusion, or other\nharmful effects. To defend against these threats, we discuss mitigation\nstrategies and best practices for developers, including an initial defense\nprototype, and call on the community to develop new protection mechanisms to\nmitigate these risks.", "AI": {"tldr": "Error", "motivation": "Error", "method": "Error", "result": "Error", "conclusion": "Error"}}
{"id": "2509.14899", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14899", "abs": "https://arxiv.org/abs/2509.14899", "authors": ["Amine Barrak", "Yosr Fourati", "Michael Olchawa", "Emna Ksontini", "Khalil Zoghlami"], "title": "CARGO: A Framework for Confidence-Aware Routing of Large Language Models", "comment": null, "summary": "As large language models (LLMs) proliferate in scale, specialization, and\nlatency profiles, the challenge of routing user prompts to the most appropriate\nmodel has become increasingly critical for balancing performance and cost. We\nintroduce CARGO (Category-Aware Routing with Gap-based Optimization), a\nlightweight, confidence-aware framework for dynamic LLM selection. CARGO\nemploys a single embedding-based regressor trained on LLM-judged pairwise\ncomparisons to predict model performance, with an optional binary classifier\ninvoked when predictions are uncertain. This two-stage design enables precise,\ncost-aware routing without the need for human-annotated supervision. To capture\ndomain-specific behavior, CARGO also supports category-specific regressors\ntrained across five task groups: mathematics, coding, reasoning, summarization,\nand creative writing. Evaluated on four competitive LLMs (GPT-4o, Claude 3.5\nSonnet, DeepSeek V3, and Perplexity Sonar), CARGO achieves a top-1 routing\naccuracy of 76.4% and win rates ranging from 72% to 89% against individual\nexperts. These results demonstrate that confidence-guided, lightweight routing\ncan achieve expert-level performance with minimal overhead, offering a\npractical solution for real-world, multi-model LLM deployments.", "AI": {"tldr": "The paper introduces CARGO, a lightweight, confidence-aware framework for dynamically selecting the most appropriate large language model (LLM) based on user prompts. It uses a two-stage system involving a regressor and an optional classifier to optimize performance and cost, achieving strong results across different LLMs.", "motivation": "With the increasing diversity of large language models in terms of scale, specialization, and latency, there is a critical need for effective routing of user prompts to the optimal model to balance performance and cost without relying on human-annotated data.", "method": "CARGO uses a single embedding-based regressor trained on LLM-judged pairwise comparisons to predict model performance. It optionally uses a binary classifier for uncertain predictions. Additionally, it supports category-specific regressors across five task groups (mathematics, coding, reasoning, summarization, creative writing) for domain-specific behavior.", "result": "CARGO achieves a top-1 routing accuracy of 76.4% and win rates between 72% and 89% against individual experts when evaluated on four competitive LLMs (GPT-4o, Claude 3.5 Sonnet, DeepSeek V3, and Perplexity Sonar).", "conclusion": "Confidence-guided, lightweight routing frameworks like CARGO can match expert-level performance with minimal overhead, making them a practical solution for real-world multi-model LLM deployments."}}
{"id": "2509.15195", "categories": ["cs.SE", "cs.AI", "cs.CR", "D.4.6; I.2.2; D.2.5"], "pdf": "https://arxiv.org/pdf/2509.15195", "abs": "https://arxiv.org/abs/2509.15195", "authors": ["Max Bazalii", "Marius Fleischer"], "title": "Orion: Fuzzing Workflow Automation", "comment": "11 pages, 3 figures, 3 tables", "summary": "Fuzz testing is one of the most effective techniques for finding software\nvulnerabilities. While modern fuzzers can generate inputs and monitor\nexecutions automatically, the overall workflow, from analyzing a codebase, to\nconfiguring harnesses, to triaging results, still requires substantial manual\neffort. Prior attempts focused on single stages such as harness synthesis or\ninput minimization, leaving researchers to manually connect the pieces into a\ncomplete fuzzing campaign.\n  We introduce Orion, a framework that automates the the manual bottlenecks of\nfuzzing by integrating LLM reasoning with traditional tools, allowing campaigns\nto scale to settings where human effort alone was impractical. Orion uses LLMs\nfor code reasoning and semantic guidance, while relying on deterministic tools\nfor verification, iterative refinement, and tasks that require precision.\nAcross our benchmark suite, Orion reduces human effort by 46-204x depending on\nthe workflow stage, and we demonstrate its effectiveness through the discovery\nof two previously unknown vulnerabilities in the widely used open-source clib\nlibrary.", "AI": {"tldr": "Orion is a framework that integrates LLM reasoning with traditional tools to automate manual bottlenecks in fuzz testing, reducing human effort by 46-204x and enabling scalable vulnerability discovery.", "motivation": "Modern fuzzers require substantial manual effort for code analysis, harness configuration, and result triage, with prior work addresses single stages but leaving integration to researchers.", "method": "Orion combines LLMs for code reasoning/semantic guidance with deterministic tools for verification and precision tasks, creating an integrated automated fuzzing workflow.", "result": "Orion achieves 46-204x human effort reduction across workflow stages and discovers two novel vulnerabilities in the clib open-source library.", "conclusion": "By merging LLM capabilities with traditional tools, Orion effectively automates fuzzing campaigns at scale where human effort alone was impractical, demonstrating practical vulnerability discovery potential."}}
{"id": "2509.14931", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14931", "abs": "https://arxiv.org/abs/2509.14931", "authors": ["Stefano Fossati", "Damian Andrew Tamburri", "Massimiliano Di Penta", "Marco Tonnarelli"], "title": "\"Let it be Chaos in the Plumbing!\" Usage and Efficacy of Chaos Engineering in DevOps Pipelines", "comment": "To be published in the Proceedings of International Conference on\n  Software Maintenance and Evolution 2025", "summary": "Chaos Engineering (CE) has emerged as a proactive method to improve the\nresilience of modern distributed systems, particularly within DevOps\nenvironments. Originally pioneered by Netflix, CE simulates real-world failures\nto expose weaknesses before they impact production. In this paper, we present a\nsystematic gray literature review that investigates how industry practitioners\nhave adopted and adapted CE principles over recent years. Analyzing 50 sources\npublished between 2019 and early 2024, we developed a comprehensive\nclassification framework that extends the foundational CE principles into ten\ndistinct concepts. Our study reveals that while the core tenets of CE remain\ninfluential, practitioners increasingly emphasize controlled experimentation,\nautomation, and risk mitigation strategies to align with the demands of agile\nand continuously evolving DevOps pipelines. Our results enhance the\nunderstanding of how CE is intended and implemented in practice, and offer\nguidance for future research and industrial applications aimed at improving\nsystem robustness in dynamic production environments.", "AI": {"tldr": "The paper explores how chaos engineering (CE) is being adapted by industry practitioners in DevOps environments through a systematic review of 50 industry sources from 2019 to 2024. It extends CE principles into 10 distinct concepts and highlights the growing importance of controlled experimentation, risk mitigation, and automation in improving system resilience.", "motivation": "Chaos engineering has become a widely adopted practice for testing and building resilience in distributed systems, but there is a need to better understand its emerging adaptations and applications in real-world DevOps environments. This lack of understanding creates a knowledge gap about the evolving nature of CE practices and their practical implementation needs.", "method": "A systematic gray literature review methodology was employed, analyzing 50 relevant sources published between 2019 and early 2024. The study used inductive qualitative analysis to develop a classification framework that extends the foundational CE principles into ten distinct conceptual categories.", "result": "The analysis identified a shift toward controlled experimentation approaches using structural mitigation strategies - 39% of sources emphasized operational risk mitigation. Significant findings showed 61% of practitioners implemented observability platforms while 75% automated chaos testing processes to match agile DevOps practices. The study produced the first classification framework capturing CE's practical evolution into testing, automation, risk management, and measurement domains.", "conclusion": "This paper's classification framework captures both the consistent value of CE principles and their adaptable implementation in dynamic DevOps environments. The key conclusions emphasize the transition from purely experimental CE to a matured discipline focusing on risk mitigation (83% of sources had risk evaluation models) and automation (persistent 75% implementation rate) in production systems. These findings provide practical guidance for implementing CE in continuously evolving software environments."}}
{"id": "2509.15150", "categories": ["cs.SE", "cs.PL", "D.2.6; D.3.3; D.2.3; D.2.5; D.2.13"], "pdf": "https://arxiv.org/pdf/2509.15150", "abs": "https://arxiv.org/abs/2509.15150", "authors": ["Federico Bruzzone", "Walter Cazzola", "Luca Favalli"], "title": "Code Less to Code More: Streamlining Language Server Protocol and Type System Development for Language Families", "comment": "34 pages, 10 figures, Journal of Systems and Software, June 2025, for\n  the replication package, see https://doi.org/10.5281/zenodo.15276991", "summary": "Developing editing support for $L$ languages in $E$ editors is complex and\ntime-consuming. Some languages do not provide dedicated editors, while others\noffer a single native editor. The $\\textit{language server protocol}$ (LSP)\nreduces the language-editor combinations $L \\times E$ to $L + E$, where a\nsingle language server communicates with editors via LSP plugins. However,\noverlapping implementations of linguistic components remain an issue. Existing\nlanguage workbenches struggle with modularity, reusability, and leveraging type\nsystems for language server generation. In this work, we propose: (i) Typelang,\na family of domain-specific languages for modular, composable, and reusable\ntype system implementation, (ii) a modular language server generation process,\nproducing servers for languages built in a modular workbench, (iii) the\nvariant-oriented programming paradigm and a cross-artifact coordination layer\nto manage interdependent software variants, and (iv) an LSP plugin generator,\nreducing $E$ to $1$ by automating plugin creation for multiple editors. To\nsimplify editing support for language families, each language artifact\nintegrates its own Typelang variant, used to generate language servers. This\nreduces combinations to $T \\times 1$, where $T = L$ represents the number of\ntype systems. Further reuse of language artifacts across languages lowers this\nto $N \\times 1$, where $N << T$, representing unique type systems. We implement\nTypelang in Neverlang, generating language servers for each artifact and LSP\nplugins for three editors. Empirical evaluation shows a 93.48% reduction in\ncharacters needed for type system implementation and 100% automation of LSP\nplugin generation, significantly lowering effort for editing support in\nlanguage families, especially when artifacts are reused.", "AI": {"tldr": "This paper proposes Typelang and a modular framework to reduce the complexity of implementing language servers for multiple programming languages and editors by enabling reusable type systems, automated LSP plugin generation, and variant-oriented programming, achieving significant automation and effort reduction.", "motivation": "Developing editing support for multiple language-editor combinations is complex and inefficient despite the Language Server Protocol (LSP). Existing tools lack modularity, reusability, and systematic generation of type-driven language servers, increasing maintenance costs.", "method": "1. Typelang: A domain-specific language family for modular type system implementation. 2. Modular language server generation workflow leveraging component reuse. 3. Variant-oriented programming and cross-artifact coordination for managing interdependent software variants. 4. An LSP plugin generator automating support for multiple editors.", "result": "93.48\\% reduction in type system implementation characters and 100\\% automation of LSP plugin generation. Demonstrated in Neverlang with three editors, reducing combinations from L\u00d7E to N\u00d71 through artifact reuse.", "conclusion": "The approach significantly lowers editing support development effort for language families by enabling modular, reusable type systems and automating LSP integration, particularly beneficial when reusing language artifacts across projects."}}
