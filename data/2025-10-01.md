<div id=toc></div>

# Table of Contents

- [cs.CR](#cs.CR) [Total: 19]
- [cs.SE](#cs.SE) [Total: 38]


<div id='cs.CR'></div>

# cs.CR [[Back]](#toc)

### [1] [Fast Energy-Theft Attack on Frequency-Varying Wireless Power without Additional Sensors](https://arxiv.org/abs/2509.25394)
*Hui Wang,Nima Tashakor,Xiaoyang Tian,Hans D. Schotten,Stefan M. Goetz*

Main category: cs.CR

TL;DR: The paper presents an optimized wireless power attack method using a main receiving coil for faster intrusions and less hardware.


<details>
  <summary>Details</summary>
Motivation: To enhance energy access protection and cybersecurity against energy theft via wireless charging.

Method: Eliminated time-consuming maximum receiver current regulation and used the main receiving coil instead of an additional sensor coil to detect the magnetic field.

Result: The attack can intrude and steal energy within 0.2 ms, with experimental results showing 65% power can be stolen from encrypted wireless power.

Conclusion: The improved attack applicability indicates that energy access protection requires significant attention.

Abstract: With the popularity of wireless charging, energy access protection and
cybersecurity are gaining importance, especially in public places. Currently,
the most common energy encryption method uses frequency and associated
impedance variation. However, we have proven that this method is not reliable,
since a hacker can detect the changing frequency and adjust the compensation.
However, the previously presented system needed time to follow the updated
frequency, while encryption systems may vary the frequency faster to avoid
energy theft. Furthermore, the previous system required an additional sensor
coil. To solve these problems, we optimized the attack and the associated
system, which can intrude and steal energy within 0.2 ms. The key is the
elimination of the time-consuming maximum receiver current regulation. Also, we
use the main receiving coil rather than any additional sensor antenna to detect
the magnetic field. Thus, the new hardware is even simpler. A simulation model
and experimental results demonstrate the fast response speed of the attack on
encrypted wireless power and steal 65% of the power. Overall, the applicability
of the attack is highly improved and leaves less room for hardening the
encryption. The results demonstrate that energy access protection needs to be
given great attention.

</details>


### [2] [Optimal Threshold Signatures in Bitcoin](https://arxiv.org/abs/2509.25408)
*Korok Ray,Sindura Saraswathi*

Main category: cs.CR

TL;DR: Dynamic threshold signatures optimally balance security and usability through time-decaying access probabilities, enabling safer cryptocurrency fund management.


<details>
  <summary>Details</summary>
Motivation: Higher security thresholds in cryptocurrencies risk locking users out of funds, while lower thresholds increase theft vulnerability. The challenge is balancing these tradeoffs in threshold signature design.

Method: The authors model a dynamic threshold signature scheme where the probability of user or attacker obtaining signatures decays over time. They analyze how security and usability interventions affect optimal threshold selection.

Result: Optimal thresholds exist that balance security/usability tradeoffs. Security/usability enhancements allow higher optimal thresholds (more security) while maintaining fund accessibility through time-based probability decay.

Conclusion: Dynamic threshold signature schemes can achieve optimality by balancing security and usability, where improvements in these areas enable higher thresholds and longer time locks.

Abstract: We formulate the design of a threshold signature scheme as made possible on
cryptocurrency protocols like Bitcoin. The funds are secured by an m-of-n
threshold signature, where at least m signatures are needed to unlock the
funds. A user designs this scheme knowing that a malicious attacker can also
obtain the signatures with some probability. Higher thresholds offer more
security, but also risk locking the user out of his own funds. The optimal
threshold balances these twin effects. Interventions like increasing the
security or usability of the signatures allow for higher thresholds. We model
dynamic threshold signature schemes, where the probability of a user or
attacker obtaining signatures decays with time. A dynamic threshold signature
scheme is optimal, and increasing security or usability allows for higher
thresholds and longer time locks.

</details>


### [3] [Characterizing Event-themed Malicious Web Campaigns: A Case Study on War-themed Websites](https://arxiv.org/abs/2509.25410)
*Maraz Mia,Mir Mehedi A. Pritom,Tariqul Islam,Shouhuai Xu*

Main category: cs.CR

TL;DR: This paper studies event-themed malicious websites, focusing on war-themed examples to understand their attack patterns using explainable clustering methods.


<details>
  <summary>Details</summary>
Motivation: The prevalence of cybercrimes themed around global events urges a deeper understanding to design proactive defenses.

Method: The authors used explainable unsupervised clustering methods on a case study of war-themed websites.

Result: Attackers were found to exploit event-specific activities like fundraising for their attacks, and the clustering method provided insights into campaign characteristics.

Conclusion: The study emphasizes the need for early defenses tailored to event themes, with clustering methods aiding in the detection of event-driven malicious campaigns.

Abstract: Cybercrimes such as online scams and fraud have become prevalent.
Cybercriminals often abuse various global or regional events as themes of their
fraudulent activities to breach user trust and attain a higher attack success
rate. These attacks attempt to manipulate and deceive innocent people into
interacting with meticulously crafted websites with malicious payloads,
phishing, or fraudulent transactions. To deepen our understanding of the
problem, this paper investigates how to characterize event-themed malicious
website-based campaigns, with a case study on war-themed websites. We find that
attackers tailor their attacks by exploiting the unique aspects of events, as
evidenced by activities such as fundraising, providing aid, collecting
essential supplies, or seeking updated news. We use explainable unsupervised
clustering methods to draw further insights, which could guide the design of
effective early defenses against various event-themed malicious web campaigns.

</details>


### [4] [Finding Phones Fast: Low-Latency and Scalable Monitoring of Cellular Communications in Sensitive Areas](https://arxiv.org/abs/2509.25430)
*Martin Kotuliak,Simon Erni,Jakub Polák,Marc Roeschlin,Richard Baker,Ivan Martinovic,Srdjan Čapkun*

Main category: cs.CR

TL;DR: LTag: First low-latency, operator-independent system blocks unauthorized cellular communication by monitoring uplink/downlink signals pre-connection, enabling real-time geofencing and disruption within 2.3 ms.


<details>
  <summary>Details</summary>
Motivation: Existing cellular monitoring systems suffer from high latency, operator dependency, or poor scalability. This prevents timely detection and disruption of unauthorized devices (e.g., drones, hidden transceivers) in sensitive areas, enabling data exfiltration/infiltration risks.

Method: LTag employs distributed downlink and uplink sniffers to measure cellular protocol data and signal characteristics. Aggregated data is processed to determine connection eligibility before UE (User Equipment) connection establishment, enabling rapid geofencing decisions.

Result: LTag achieves signal origin classification (inside/outside geofence area) within 2.3 ms of the first base station-to-device message. It enables disruption of unauthorized communication before any user data transmission, validated through geofencing deployment.

Conclusion: The paper introduces LTag, a low-latency, operator-independent monitoring system that addresses the critical gap in real-time cellular transmission monitoring. It demonstrates effectiveness in enabling timely disruption of unauthorized communication through a scalable and deployment-ready solution.

Abstract: The widespread availability of cellular devices introduces new threat vectors
that allow users or attackers to bypass security policies and physical barriers
and bring unauthorized devices into sensitive areas. These threats can arise
from user non-compliance or deliberate actions aimed at data
exfiltration/infiltration via hidden devices, drones, etc. We identify a
critical gap in this context: the absence of low-latency systems for
high-quality and instantaneous monitoring of cellular transmissions. Such
low-latency systems are crucial to allow for timely detection, decision (e.g.,
geofencing or localization), and disruption of unauthorized communication in
sensitive areas. Operator-based monitoring systems, built for purposes such as
people counting or tracking, lack real-time capability, require cooperation
across multiple operators, and thus are hard to deploy. Operator-independent
monitoring approaches proposed in the literature either lack low-latency
capabilities or do not scale.
  We propose LTag, the first low-latency, operator-independent and scalable
system designed to monitor cellular connections across all operators prior to
any user data transmission. LTag consists of several downlink sniffers and a
distributed network of uplink sniffers that measure both downlink protocol
information and uplink signal characteristics at multiple locations to gain a
detailed spatial image of uplink signals. LTag aggregates the recorded
information, processes it, and provides a decision about the connection all
prior to connection establishment of a UE. To evaluate LTag, we deployed it in
the context of geofencing, where LTag was able to determine if the signals
originate from inside or outside of an area within 2.3 ms of the initial base
station-to-device message, therefore enabling prompt and targeted suppression
of communication before any user data was transmitted.

</details>


### [5] [Fingerprinting LLMs via Prompt Injection](https://arxiv.org/abs/2509.25448)
*Yuepeng Hu,Zhengyuan Jiang,Mengyuan Li,Osama Ahmed,Zhicong Huang,Cheng Hong,Neil Gong*

Main category: cs.CR

TL;DR: LLMPrint introduces a novel framework for detecting model provenance by exploiting LLMs' vulnerability to prompt injection, creating robust fingerprints resilient to post-processing methods like quantization or post-training.


<details>
  <summary>Details</summary>
Motivation: Existing provenance detection methods either require embedding signals before model release (inapplicable to existing LLMs), or rely on suboptimal prompt-based comparisons that fail under post-processing.

Method: LLMPrint constructs unique model fingerprints by optimizing fingerprint prompts to enforce consistent token preferences. It leverages prompt injection vulnerabilities and proposes a unified, statistically guaranteed verification protocol for both gray-box and black-box scenarios.

Result: Evaluations on 5 base models and 700 variants show LLMPrint achieves high true positive rates (approaching 100%) with false positive rates near 0%, maintaining effectiveness under various post-processing techniques.

Conclusion: LLMPrint provides a practical, robust solution for model provenance detection. Its exploitation of inherent LLM vulnerabilities and unified verification framework addresses critical limitations of existing methods, enabling reliable detection of model lineage even after extensive modifications.

Abstract: Large language models (LLMs) are often modified after release through
post-processing such as post-training or quantization, which makes it
challenging to determine whether one model is derived from another. Existing
provenance detection methods have two main limitations: (1) they embed signals
into the base model before release, which is infeasible for already published
models, or (2) they compare outputs across models using hand-crafted or random
prompts, which are not robust to post-processing. In this work, we propose
LLMPrint, a novel detection framework that constructs fingerprints by
exploiting LLMs' inherent vulnerability to prompt injection. Our key insight is
that by optimizing fingerprint prompts to enforce consistent token preferences,
we can obtain fingerprints that are both unique to the base model and robust to
post-processing. We further develop a unified verification procedure that
applies to both gray-box and black-box settings, with statistical guarantees.
We evaluate LLMPrint on five base models and around 700 post-trained or
quantized variants. Our results show that LLMPrint achieves high true positive
rates while keeping false positive rates near zero.

</details>


### [6] [Managing Differentiated Secure Connectivity using Intents](https://arxiv.org/abs/2509.25462)
*Loay Abdelrazek,Filippo Rebecchi*

Main category: cs.CR

TL;DR: This paper proposes intent-based security management for 5G/6G mobile networks using differentiated security levels and an extended TM Forum ontology to address complex, goal-driven security requirements, aiming to enhance automation and resilience.


<details>
  <summary>Details</summary>
Motivation: New 5G/6G services and use cases introduce diverse security requirements and threats, while existing automation approaches lack the expressiveness to enforce measurable, goal-oriented security policies effectively.

Method: The authors introduce differentiated security levels and extend intent-based management frameworks using a TMF intent security ontology to formalize functional/non-functional security requirements and outline standardization steps.

Result: The work demonstrates a framework for expressing security requirements via intent modeling and identifies necessary standardization steps to enable intent-driven security automation in mobile networks.

Conclusion: The proposed approach advancement aims to improve security automation, adaptability, and overall resilience for next-generation mobile networks through intent-based security management.

Abstract: Mobile networks in the 5G and 6G era require to rethink how to manage
security due to the introduction of new services, use cases, each with its own
security requirements, while simultaneously expanding the threat landscape.
Although automation has emerged as a key enabler to address complexity in
networks, existing approaches lack the expressiveness to define and enforce
complex, goal-driven, and measurable security requirements. In this paper, we
propose the concept of differentiated security levels and leveraging intents as
a management framework. We discuss the requirements and enablers to extend the
currently defined intent-based management frameworks to pave the path for
intent-based security management in mobile networks. Our approach formalizes
both functional and non-functional security requirements and demonstrates how
these can be expressed and modeled using an extended TM Forum (TMF) intent
security ontology. We further discuss the required standardization steps to
achieve intent-based security management. Our work aims at advance security
automation, improve adaptability, and strengthen the resilience and security
posture of the next-generation mobile networks.

</details>


### [7] [Balancing Compliance and Privacy in Offline CBDC Transactions Using a Secure Element-based System](https://arxiv.org/abs/2509.25469)
*Panagiotis Michalopoulos,Anthony Mack,Cameron Clark,Linus Chen,Johannes Sedlmeir,Andreas Veneris*

Main category: cs.CR

TL;DR: This paper introduces a compliant offline payment framework for CBDCs and cryptocurrencies using hardware security and zero-knowledge proofs, achieving commercial-grade performance with configurable privacy tiers.


<details>
  <summary>Details</summary>
Motivation: Offline payments improve scalability and privacy but conflict with AML/CFT regulations, creating a critical tension in CBDC implementation.

Method: A prototype leverages Secure Elements and digital credentials, with optional integration of Zero-Knowledge Proofs for tiered privacy protection.

Result: The prototype achieves transaction latency comparable to commercial systems while demonstrating regulatory adaptability through performance evaluations.

Conclusion: The paper proposes an offline digital currency payment solution using Secure Elements and Zero-Knowledge Proofs, balancing regulatory compliance with privacy enhancement for both cryptocurrencies and CBDCs.

Abstract: Blockchain technology has spawned a vast ecosystem of digital currencies with
Central Bank Digital Currencies (CBDCs) -- digital forms of fiat currency --
being one of them. An important feature of digital currencies is facilitating
transactions without network connectivity, which can enhance the scalability of
cryptocurrencies and the privacy of CBDC users. However, in the case of CBDCs,
this characteristic also introduces new regulatory challenges, particularly
when it comes to applying established Anti-Money Laundering and Countering the
Financing of Terrorism (AML/CFT) frameworks. This paper introduces a prototype
for offline digital currency payments, equally applicable to cryptocurrencies
and CBDCs, that leverages Secure Elements and digital credentials to address
the tension of offline payment support with regulatory compliance. Performance
evaluation results suggest that the prototype can be flexibly adapted to
different regulatory environments, with a transaction latency comparable to
real-life commercial payment systems. Furthermore, we conceptualize how the
integration of Zero-Knowledge Proofs into our design could accommodate various
tiers of enhanced privacy protection.

</details>


### [8] [Environmental Rate Manipulation Attacks on Power Grid Security](https://arxiv.org/abs/2509.25476)
*Yonatan Gizachew Achamyeleh,Yang Xiang,Yun-Ping Hsiao,Yasamin Moghaddas,Mohammad Abdullah Al Faruque*

Main category: cs.CR

TL;DR: This paper introduces Environmental Rate Manipulation (ERM), a novel hardware Trojan triggering mechanism that leverages environmental parameter rate-of-change to evade detection and cause cascading failures in power electronics systems.


<details>
  <summary>Details</summary>
Motivation: Traditional Trojans using digital triggers or fixed thresholds are detectable during testing; there is a need for stealthier attack vectors that exploit dynamic environmental factors to bypass redundancy and sensor-fusion defenses.

Method: The ERM mechanism employs a 14 µm² circuit to monitor capacitor charging rates in sensor front-ends, disrupting PWM signals when rapid environmental changes occur. This hardware is implemented using standard power electronics components to avoid anomalies under normal conditions.

Result: Experiments on TI solar inverters caused driver chip failures, while ETAP simulations showed 100 kW inverter sabotage could initiate grid-wide instabilities. ERM evades conventional testing by relying on temporal rather than static conditions.

Conclusion: ERM exposes systemic vulnerabilities in power electronics security frameworks, demonstrating that attacks targeting environmental rate dynamics can compromise not only individual sensors but entire classes of hardware dependent on sensor fusion and redundancy mechanisms.

Abstract: The growing complexity of global supply chains has made hardware Trojans a
significant threat in sensor-based power electronics. Traditional Trojan
designs depend on digital triggers or fixed threshold conditions that can be
detected during standard testing. In contrast, we introduce Environmental Rate
Manipulation (ERM), a novel Trojan triggering mechanism that activates by
monitoring the rate of change in environmental parameters rather than their
absolute values. This approach allows the Trojan to remain inactive under
normal conditions and evade redundancy and sensor-fusion defenses. We implement
a compact 14~$\mu$m$^2$ circuit that measures capacitor charging rates in
standard sensor front-ends and disrupts inverter pulse-width modulation PWM
signals when a rapid change is induced. Experiments on a commercial Texas
Instruments solar inverter demonstrate that ERM can trigger catastrophic driver
chip failure. Furthermore, ETAP simulations indicate that a single compromised
100~kW inverter may initiate cascading grid instabilities. The attack's
significance extends beyond individual sensors to entire classes of
environmental sensing systems common in power electronics, demonstrating
fundamental challenges for hardware security.

</details>


### [9] [Defeating Cerberus: Concept-Guided Privacy-Leakage Mitigation in Multimodal Language Models](https://arxiv.org/abs/2509.25525)
*Boyang Zhang,Istemi Ekin Akkus,Ruichuan Chen,Alice Dethise,Klaus Satzke,Ivica Rimac,Yang Zhang*

Main category: cs.CR

TL;DR: The paper investigates PII leakage risks in vision-language models (VLMs) and proposes a concept-guided mitigation method to block PII-sensitive tasks without retraining, achieving 93.3% refusal rate with minimal performance impact.


<details>
  <summary>Details</summary>
Motivation: Multimodal models' PII vulnerabilities remain underexplored despite their ability to process privacy-sensitive image and text data. Existing single-modal research neglects cross-modal risks and dataset limitations hinder progress.

Method: Introduces concept-guided internal state modification to identify and alter PII-related model states, combined with novel multimodal PII datasets simulating real-world scenarios.

Result: 93.3 average refusal rate for PII tasks across conditions with negligible impact on unrelated tasks, validated through extensive experiments and adaptability analysis.

Conclusion: The proposed method effectively mitigates PII leakage in vision-language models without retraining, addressing current dataset gaps while maintaining model utility.

Abstract: Multimodal large language models (MLLMs) have demonstrated remarkable
capabilities in processing and reasoning over diverse modalities, but their
advanced abilities also raise significant privacy concerns, particularly
regarding Personally Identifiable Information (PII) leakage. While relevant
research has been conducted on single-modal language models to some extent, the
vulnerabilities in the multimodal setting have yet to be fully investigated. In
this work, we investigate these emerging risks with a focus on vision language
models (VLMs), a representative subclass of MLLMs that covers the two
modalities most relevant for PII leakage, vision and text. We introduce a
concept-guided mitigation approach that identifies and modifies the model's
internal states associated with PII-related content. Our method guides VLMs to
refuse PII-sensitive tasks effectively and efficiently, without requiring
re-training or fine-tuning. We also address the current lack of multimodal PII
datasets by constructing various ones that simulate real-world scenarios.
Experimental results demonstrate that the method can achieve an average refusal
rate of 93.3% for various PII-related tasks with minimal impact on unrelated
model performances. We further examine the mitigation's performance under
various conditions to show the adaptability of our proposed method.

</details>


### [10] [Zero Trust-based Decentralized Identity Management System for Autonomous Vehicles](https://arxiv.org/abs/2509.25566)
*Amal Yousseef,Shalaka Satam,Banafsheh Saber Latibari,Mai Abdel-Malek,Soheil Salehi,Pratik Satam*

Main category: cs.CR

TL;DR: This paper proposes a blockchain-enabled Zero Trust security framework for AVs, achieving strong cybersecurity with minimal performance impact.


<details>
  <summary>Details</summary>
Motivation: Traditional perimeter-based security models are insufficient for AVs' dynamic, untrusted environments due to their reliance on centralized authorities and inability to continuously verify entities.

Method: A Zero Trust-based Decentralized Identity Management (D-IM) protocol was developed by integrating Zero Trust Architecture principles with blockchain's tamper-resistant properties. Hyperledger Iroha was utilized for lightweight, secure authentication without centralized authority.

Result: Experiments showed the protocol introduced <7.5% PRR reduction in urban settings and <11% CBR increase for LTE-V2X, demonstrating efficiency and robustness against cyberattacks.

Conclusion: The D-IM framework provides a resilient and efficient solution for securing real-time V2X communication in AVs, effectively addressing impersonation and replay attacks while maintaining minimal performance overhead.

Abstract: The rise of autonomous vehicles (AVs) promises to significantly enhance
transportation safety and efficiency by mitigating human error, which is
responsible for over 90\% of road accidents. However, the increasing
connectivity of AVs introduces new cybersecurity challenges, as traditional
perimeter-based security models are inadequate for dynamic and untrusted
environments. This paper presents a novel Zero Trust-based Decentralized
Identity Management (D-IM) protocol for AVs. By integrating the core principles
of Zero Trust Architecture, "never trust, always verify", with the tamper
resistant and decentralized nature of a blockchain network, our framework
eliminates reliance on centralized authorities and provides continuous
verification for every entity. We detail the system's design, which leverages
Hyperledger Iroha to enable lightweight and secure authentication without a
central trusted entity. A comprehensive experimental evaluation, conducted
across both urban and highway scenarios, validates the protocol's practicality.
Our results demonstrate that the D-IM framework introduces minimal overhead,
with less than 7.5\% reduction in Packet Reception Rate (PRR) in urban settings
and an increase of under 11\% in Channel Busy Ratio (CBR) for LTE-V2X. These
findings prove the protocol's efficiency and robustness, providing a resilient
foundation for securing real-time V2X communication against impersonation and
replay attacks.

</details>


### [11] [STAC: When Innocent Tools Form Dangerous Chains to Jailbreak LLM Agents](https://arxiv.org/abs/2509.25624)
*Jing-Jing Li,Jianfeng He,Chao Shang,Devang Kulshreshtha,Xun Xian,Yi Zhang,Hang Su,Sandesh Swamy,Yanjun Qi*

Main category: cs.CR

TL;DR: LLM agents are vulnerable to STAC attacks where seemingly harmless tool calls are chained to perform harmful actions, and a new defense strategy effectively reduces attack success rates.


<details>
  <summary>Details</summary>
Motivation: As autonomous LLM agents become more prevalent, their use of tools introduces new security challenges beyond traditional content-based safety issues. Priorities needed to assess sequence-based vulnerabilities.

Method: The authors develop STAC, a multi-turn attack framework that automatically generates and validates harmful sequences of tool calls. They also test existing defenses and propose a reasoning-based defense prompt.

Result: Evaluation shows high vulnerability (ASR >90%) in state-of-the-art LLM agents like GPT-4.1 to STAC. The new defense reduces ASR by up to 28.8%.

Conclusion: STAC highlights the need for defenses that reason about entire action sequences rather than individual prompts or responses.

Abstract: As LLMs advance into autonomous agents with tool-use capabilities, they
introduce security challenges that extend beyond traditional content-based LLM
safety concerns. This paper introduces Sequential Tool Attack Chaining (STAC),
a novel multi-turn attack framework that exploits agent tool use. STAC chains
together tool calls that each appear harmless in isolation but, when combined,
collectively enable harmful operations that only become apparent at the final
execution step. We apply our framework to automatically generate and
systematically evaluate 483 STAC cases, featuring 1,352 sets of
user-agent-environment interactions and spanning diverse domains, tasks, agent
types, and 10 failure modes. Our evaluations show that state-of-the-art LLM
agents, including GPT-4.1, are highly vulnerable to STAC, with attack success
rates (ASR) exceeding 90% in most cases. The core design of STAC's automated
framework is a closed-loop pipeline that synthesizes executable multi-step tool
chains, validates them through in-environment execution, and reverse-engineers
stealthy multi-turn prompts that reliably induce agents to execute the verified
malicious sequence. We further perform defense analysis against STAC and find
that existing prompt-based defenses provide limited protection. To address this
gap, we propose a new reasoning-driven defense prompt that achieves far
stronger protection, cutting ASR by up to 28.8%. These results highlight a
crucial gap: defending tool-enabled agents requires reasoning over entire
action sequences and their cumulative effects, rather than evaluating isolated
prompts or responses.

</details>


### [12] [Better Privilege Separation for Agents by Restricting Data Types](https://arxiv.org/abs/2509.25926)
*Dennis Jacob,Emad Alghamdi,Zhanhao Hu,Basel Alomair,David Wagner*

Main category: cs.CR

TL;DR: This paper proposes a novel security framework for LLMs using type-directed privilege separation to block prompt injection attacks by restricting interactions to strictly defined data types, ensuring both safety and performance.


<details>
  <summary>Details</summary>
Motivation: Current defense mechanisms against prompt injection (e.g., detectors, finetuning) are ineffective against adaptive attacks or incompatible with state-of-the-art LLMs, necessitating a more robust and universally applicable solution.

Method: The paper introduces type-directed privilege separation, which enforces security by converting untrusted content into a curated set of restricted data types, limiting the LLM’s interaction scope to eliminate prompt injection vulnerabilities.

Result: Case studies show that the proposed method systematically prevents prompt injection attacks while maintaining high system utility, demonstrating its effectiveness and practicality.

Conclusion: Type-directed privilege separation provides a systematic and effective solution to prevent prompt injection attacks in LLMs without compromising utility, offering a robust alternative to existing vulnerable approaches.

Abstract: Large language models (LLMs) have become increasingly popular due to their
ability to interact with unstructured content. As such, LLMs are now a key
driver behind the automation of language processing systems, such as AI agents.
Unfortunately, these advantages have come with a vulnerability to prompt
injections, an attack where an adversary subverts the LLM's intended
functionality with an injected task. Past approaches have proposed detectors
and finetuning to provide robustness, but these techniques are vulnerable to
adaptive attacks or cannot be used with state-of-the-art models. To this end we
propose type-directed privilege separation for LLMs, a method that
systematically prevents prompt injections. We restrict the ability of an LLM to
interact with third-party data by converting untrusted content to a curated set
of data types; unlike raw strings, each data type is limited in scope and
content, eliminating the possibility for prompt injections. We evaluate our
method across several case studies and find that designs leveraging our
principles can systematically prevent prompt injection attacks while
maintaining high utility.

</details>


### [13] [SoK: Systematic analysis of adversarial threats against deep learning approaches for autonomous anomaly detection systems in SDN-IoT networks](https://arxiv.org/abs/2509.26350)
*Tharindu Lakshan Yasarathna,Nhien-An Le-Khac*

Main category: cs.CR

TL;DR: The paper examines adversarial attacks on DL-based AAD systems in SDN-IoT networks. It introduces a structured threat model, taxonomy, and finds that attacks reduce accuracy by up to 48.4%. They propose adaptive defenses like adversarial training but note its computational cost.


<details>
  <summary>Details</summary>
Motivation: The motivation stems from the rising adoption of SDN and IoT and the need for advanced security. Traditional security measures are inadequate against adversarial attacks that exploit DL systems. The authors enhance network security by offering deeper analysis of adversarial vulnerabilities and refined defense strategies.

Method: The research methodology includes developing a threat model and taxonomy for adversarial attacks on SDN-IoT systems. It systematically evaluates attack types (white, black, grey-box strategies) on benchmark datasets using C&W and DeepFool techniques to simulate real threat scenarios.

Result: The results identify membership inference as the most damaging attack type. Adversarial attacks cause up to 48.4% drop in detection accuracy, while C&W and DeepFool report high evasion rates. The study shows that adversarial training bolsters system robustness but imposes high computational demands.

Conclusion: The conclusion emphasizes the integration of structured threat models and adaptive defenses like adversarial training, real-time mitigation, and explainable AI for securing DL-based AAD systems. The work lays a foundation for future research into efficient, resilient, and interpretable SDN-IoT security solutions.

Abstract: Integrating SDN and the IoT enhances network control and flexibility.
DL-based AAD systems improve security by enabling real-time threat detection in
SDN-IoT networks. However, these systems remain vulnerable to adversarial
attacks that manipulate input data or exploit model weaknesses, significantly
degrading detection accuracy. Existing research lacks a systematic analysis of
adversarial vulnerabilities specific to DL-based AAD systems in SDN-IoT
environments. This SoK study introduces a structured adversarial threat model
and a comprehensive taxonomy of attacks, categorising them into data, model,
and hybrid-level threats. Unlike previous studies, we systematically evaluate
white, black, and grey-box attack strategies across popular benchmark datasets.
Our findings reveal that adversarial attacks can reduce detection accuracy by
up to 48.4%, with Membership Inference causing the most significant drop. C&W
and DeepFool achieve high evasion success rates. However, adversarial training
enhances robustness, and its high computational overhead limits the real-time
deployment of SDN-IoT applications. We propose adaptive countermeasures,
including real-time adversarial mitigation, enhanced retraining mechanisms, and
explainable AI-driven security frameworks. By integrating structured threat
models, this study offers a more comprehensive approach to attack
categorisation, impact assessment, and defence evaluation than previous
research. Our work highlights critical vulnerabilities in existing DL-based AAD
models and provides practical recommendations for improving resilience,
interpretability, and computational efficiency. This study serves as a
foundational reference for researchers and practitioners seeking to enhance
DL-based AAD security in SDN-IoT networks, offering a systematic adversarial
threat model and conceptual defence evaluation based on prior empirical
studies.

</details>


### [14] [Exact Bias of Linear TRNG Correctors -- Spectral Approach](https://arxiv.org/abs/2509.26393)
*Maciej Skorski,Francisco-Javier Soto,Onur Günlü*

Main category: cs.CR

TL;DR: This paper analytically establishes near-optimal security bounds for linear TRNG extractors using Fourier analysis, revealing trade-offs between compression and security through extensive code evaluations.


<details>
  <summary>Details</summary>
Motivation: Previous TRNG security approximations lacked precision, necessitating a rigorous mathematical framework to quantify cryptographic security and extraction costs in hardware implementations.

Method: The authors combine ℓ∞ and ℓ2 norm analyses via code weight enumerators and input bias parameters, using Fourier analysis to bridge theoretical bounds. They validate these by scanning ~20,000 codes for empirical trade-off measurements.

Result: 1) Improved total variation security bounds by an order of magnitude
2) Revealed 50% code rate sacrifice required for 80-bit security at 10% input bias
3) Demonstrated fundamental compression-security trade-offs across real-world TRNG scenarios

Conclusion: The work enables precise TRNG post-processing evaluation, proving that high security demands significant compression efficiency trade-offs in hardware, which directly impacts practical randomness extraction costs.

Abstract: Using Fourier analysis, this paper establishes exact security bounds for
linear extractors in True Random Number Generators (TRNGs). We provide the
first near-optimal total variation security characterization by interpolating
between optimal $\ell_{\infty}$ and $\ell_2$ norm results, expressed through
code weight enumerators and input bias parameters. Our bounds improve security
assessments by an order of magnitude over previous approximations. By scanning
~20,000 codes, we reveal fundamental trade-offs between compression efficiency
and cryptographic security. For instance, we show that achieving 80 bits of
security can require sacrificing more than 50\% of the code rate when
correcting 10\% input bias. Our bounds enhance security evaluation of TRNG
post-processing schemes and quantify the inherent cost of randomness extraction
in hardware implementations.

</details>


### [15] [SeedPrints: Fingerprints Can Even Tell Which Seed Your Large Language Model Was Trained From](https://arxiv.org/abs/2509.26404)
*Yao Tong,Haonan Wang,Siquan Li,Kenji Kawaguchi,Tianyang Hu*

Main category: cs.CR

TL;DR: SeedPrints introduces a novel LLM fingerprinting method using initialization biases as persistent, seed-dependent identifiers detectable before training, offering a robust alternative to post-hoc techniques.


<details>
  <summary>Details</summary>
Motivation: Existing LLM fingerprinting methods rely on post-training dynamics/data, which are unreliable before convergence and vulnerable to distribution shifts. SeedPrints addresses this by leveraging inherent initialization biases to establish early, persistent identity markers.

Method: Exploits reproducible token selection biases in untrained models caused by parameter initialization. Statistical detection tracks these stable biases through training, enabling seed-level identification immune to domain shifts or parameter changes.

Result: Experiments on LLaMA/Qwen-style models show SeedPrints achieves high-confidence lifecycle fingerprinting, outperforming prior methods in distinguishing seed-dependent identities and maintaining effectiveness during training.

Conclusion: Initialization itself creates a persistent, Galtonian-like fingerprint in LLMs, enabling birth-to-convergence biometric identification without reliance on training dynamics or data exposure.

Abstract: Fingerprinting Large Language Models (LLMs) is essential for provenance
verification and model attribution. Existing methods typically extract post-hoc
signatures based on training dynamics, data exposure, or hyperparameters --
properties that only emerge after training begins. In contrast, we propose a
stronger and more intrinsic notion of LLM fingerprinting: SeedPrints, a method
that leverages random initialization biases as persistent, seed-dependent
identifiers present even before training. We show that untrained models exhibit
reproducible token selection biases conditioned solely on their parameters at
initialization. These biases are stable and measurable throughout training,
enabling our statistical detection method to recover a model's lineage with
high confidence. Unlike prior techniques, unreliable before convergence and
vulnerable to distribution shifts, SeedPrints remains effective across all
training stages and robust under domain shifts or parameter modifications.
Experiments on LLaMA-style and Qwen-style models show that SeedPrints achieves
seed-level distinguishability and can provide birth-to-lifecycle identity
verification akin to a biometric fingerprint. Evaluations on large-scale
pretrained models and fingerprinting benchmarks further confirm its
effectiveness under practical deployment scenarios. These results suggest that
initialization itself imprints a unique and persistent identity on neural
language models, forming a true ''Galtonian'' fingerprint.

</details>


### [16] [Logic Solver Guided Directed Fuzzing for Hardware Designs](https://arxiv.org/abs/2509.26509)
*Raghul Saravanan,Sai Manoj P D*

Main category: cs.CR

TL;DR: TargetFuzz is a new directed hardware fuzzing tool that uses SAT-based techniques to improve bug detection in complex IC designs by targeting specific regions without relying on SW models.


<details>
  <summary>Details</summary>
Motivation: The increasing complexity of modern IC design specifications makes early bug detection challenging. Traditional hardware fuzzing methods rely on SW equivalent models which can miss hardware-specific characteristics, leading to inefficient verification.

Method: TargetFuzz employs SAT-based techniques to perform targeted fuzzing directly at the native hardware abstraction level, eliminating the need for SW models. This approach allows it to focus on specific regions of a hardware design for more efficient and accurate verification.

Result: Evaluation on various IP core RTL designs showed TargetFuzz can target a wide range of sites with 100% state coverage and 1.5x faster site coverage than Coverage-Guided Fuzzing. It also achieved 90x improvement in target state coverage.

Conclusion: TargetFuzz represents a significant advancement in directed hardware fuzzing, offering scalable and precise verification without the drawbacks of SW model dependencies.

Abstract: The ever-increasing complexity of design specifications for processors and
intellectual property (IP) presents a formidable challenge for early bug
detection in the modern IC design cycle. The recent advancements in hardware
fuzzing have proven effective in detecting bugs in RTL designs of cutting-edge
processors. The modern IC design flow involves incremental updates and
modifications to the hardware designs necessitating rigorous verification and
extending the overall verification period. To accelerate this process, directed
fuzzing has emerged focusing on generating targeted stimuli for specific
regions of the design, avoiding the need for exhaustive, full-scale
verification. However, a significant limitation of these hardware fuzzers lies
in their reliance on an equivalent SW model of the hardware which fails to
capture intrinsic hardware characteristics. To circumvent the aforementioned
challenges, this work introduces TargetFuzz, an innovative and scalable
targeted hardware fuzzing mechanism. It leverages SAT-based techniques to focus
on specific regions of the hardware design while operating at its native
hardware abstraction level, ensuring a more precise and comprehensive
verification process. We evaluated this approach across a diverse range of RTL
designs for various IP cores. Our experimental results demonstrate its
capability to effectively target and fuzz a broad spectrum of sites within
these designs, showcasing its extensive coverage and precision in addressing
targeted regions. TargetFuzz demonstrates its capability to effectively scale
30x greater in terms of handling target sites, achieving 100% state coverage
and 1.5x faster in terms of site coverage, and shows 90x improvement in target
state coverage compared to Coverage-Guided Fuzzing, demonstrating its potential
to advance the state-of-the-art in directed hardware fuzzing.

</details>


### [17] [Explainable and Resilient ML-Based Physical-Layer Attack Detectors](https://arxiv.org/abs/2509.26530)
*Aleksandra Knapińska,Marija Furdek*

Main category: cs.CR

TL;DR: This paper proposes explainable machine learning methods for physical-layer attack detection, analyzing model interpretability and resilience trade-offs to guide fast, robust detector design.


<details>
  <summary>Details</summary>
Motivation: Modern network threats require automated detection via ML, but complex models lack transparency. Explainable methods improve interpretability and efficiency for physical-layer intrusion detection.

Method: 1) Analyze classifier parameter influence on attack detection for interpretability and design optimization. 2）Evaluate detectors' resilience against parameter noising to identify speed-robustness trade-offs.

Result: Reveals inherent trade-off between model speed and resilience to adversarial parameter perturbations. Provides design principles for balancing these factors in network monitoring systems.

Conclusion: The work establishes critical guidelines for developing explainable, high-performance detectors leveraging network monitoring data while maintaining robustness against evasion attacks.

Abstract: Detection of emerging attacks on network infrastructure is a critical aspect
of security management. To meet the growing scale and complexity of modern
threats, machine learning (ML) techniques offer valuable tools for automating
the detection of malicious activities. However, as these techniques become more
complex, their internal operations grow increasingly opaque. In this context,
we address the need for explainable physical-layer attack detection methods.
First, we analyze the inner workings of various classifiers trained to alert
about physical layer intrusions, examining how the influence of different
monitored parameters varies depending on the type of attack being detected.
This analysis not only improves the interpretability of the models but also
suggests ways to enhance their design for increased speed. In the second part,
we evaluate the detectors' resilience to malicious parameter noising. The
results highlight a key trade-off between model speed and resilience. This work
serves as a design guideline for developing fast and robust detectors trained
on available network monitoring data.

</details>


### [18] [DeepProv: Behavioral Characterization and Repair of Neural Networks via Inference Provenance Graph Analysis](https://arxiv.org/abs/2509.26562)
*Firas Ben Hmida,Abderrahmen Amich,Ata Kaboudi,Birhanu Eshete*

Main category: cs.CR

TL;DR: DeepProv introduces Inference Provenance Graphs (IPGs) to model DNN runtime behavior, enabling targeted repairs to improve robustness and adaptability across tasks like privacy and fairness.


<details>
  <summary>Details</summary>
Motivation: DNNs fail reliably in real-world applications (e.g., self-driving, biometrics) due to unpredictable behavior, requiring new methods for characterizing and repairing their runtime behavior.

Method: Uses graph-based IPGs to capture computational information flow during inference, enabling node/edge-level analysis and systematic repairs (e.g., adversarial robustness improvement).

Result: Achieves 55%% average improvement in adversarial accuracy with single-layer repairs; demonstrates scalability across tasks and model complexities; complements existing defenses effectively.

Conclusion: DeepProv establishes a versatile framework for auditing and repairing DNNs, with broad applicability beyond robustness to privacy auditing and fairness analysis.

Abstract: Deep neural networks (DNNs) are increasingly being deployed in high-stakes
applications, from self-driving cars to biometric authentication. However,
their unpredictable and unreliable behaviors in real-world settings require new
approaches to characterize and ensure their reliability.
  This paper introduces DeepProv, a novel and customizable system designed to
capture and characterize the runtime behavior of DNNs during inference by using
their underlying graph structure. Inspired by system audit provenance graphs,
DeepProv models the computational information flow of a DNN's inference process
through Inference Provenance Graphs (IPGs). These graphs provide a detailed
structural representation of the behavior of DNN, allowing both empirical and
structural analysis. DeepProv uses these insights to systematically repair DNNs
for specific objectives, such as improving robustness, privacy, or fairness.
  We instantiate DeepProv with adversarial robustness as the goal of model
repair and conduct extensive case studies to evaluate its effectiveness. Our
results demonstrate its effectiveness and scalability across diverse
classification tasks, attack scenarios, and model complexities. DeepProv
automatically identifies repair actions at the node and edge-level within IPGs,
significantly enhancing the robustness of the model. In particular, applying
DeepProv repair strategies to just a single layer of a DNN yields an average
55% improvement in adversarial accuracy. Moreover, DeepProv complements
existing defenses, achieving substantial gains in adversarial robustness.
Beyond robustness, we demonstrate the broader potential of DeepProv as an
adaptable system to characterize DNN behavior in other critical areas, such as
privacy auditing and fairness analysis.

</details>


### [19] [Are Robust LLM Fingerprints Adversarially Robust?](https://arxiv.org/abs/2509.26598)
*Anshul Nasery,Edoardo Contente,Alkin Kaz,Pramod Viswanath,Sewoong Oh*

Main category: cs.CR

TL;DR: This paper reveals critical vulnerabilities in 10 recent model fingerprinting schemes by developing adversarial attacks that bypass ownership authentication while maintaining model utility, emphasizing the need for adversarial robustness in fingerprint design.


<details>
  <summary>Details</summary>
Motivation: Existing model fingerprinting evaluations focus on benign perturbations, leaving adversarial robustness against malicious attacks unaddressed. This creates vulnerabilities in ownership claim systems.

Method: The researchers (1) defined a practical threat model for adversarial robustness, (2) analyzed vulnerabilities in 10 fingerprinting schemes, and (3) developed tailored adversarial attacks against these vulnerabilities.

Result: Demonstrated complete bypass of ownership authentication for all 10 schemes using adversarial attacks while maintaining high model utility for end users, validating the critical vulnerabilities in current fingerprinting methods.

Conclusion: Current fingerprinting systems require adversarial robustness by design. The authors recommend future methods should prioritize defending against such attacks to ensure secure ownership verification.

Abstract: Model fingerprinting has emerged as a promising paradigm for claiming model
ownership. However, robustness evaluations of these schemes have mostly focused
on benign perturbations such as incremental fine-tuning, model merging, and
prompting. Lack of systematic investigations into {\em adversarial robustness}
against a malicious model host leaves current systems vulnerable. To bridge
this gap, we first define a concrete, practical threat model against model
fingerprinting. We then take a critical look at existing model fingerprinting
schemes to identify their fundamental vulnerabilities. Based on these, we
develop adaptive adversarial attacks tailored for each vulnerability, and
demonstrate that these can bypass model authentication completely for ten
recently proposed fingerprinting schemes while maintaining high utility of the
model for the end users. Our work encourages fingerprint designers to adopt
adversarial robustness by design. We end with recommendations for future
fingerprinting methods.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [20] [WARP -- Web-Augmented Real-time Program Repairer: A Real-Time Compilation Error Resolution using LLMs and Web-Augmented Synthesis](https://arxiv.org/abs/2509.25192)
*Anderson de Lima Luiz*

Main category: cs.SE

TL;DR:  Compilation errors are a significant productivity issue in software development. This paper introduces WARP, a real-time program repair system that combines Code-LLMs with up-to-date web sources to resolve errors efficiently. Benchmarks show WARP outperforms existing LLM-only and traditional IDE methods. Despite challenges with noisy web data, WARP is a promising solution for improving error resolution in software development.


<details>
  <summary>Details</summary>
Motivation: Fixing compilation errors is a time-consuming part of software development, causing delays and frustration. Traditional error resolution methods, such as IDE quick-fixes or manual web searches, are often inefficient and not as accurate as required. This paper seeks to present a system that efficiently and accurately resolves these errors in real time.

Method: WARP uses a fine-tuned Code-LLM for understanding and contextual analysis of compilation errors, alongside dynamic web-augmented code synthesis. This involves monitoring developer terminals, detecting errors, and synthesizing real-time fixes by combining the model’s reasoning with up-to-date code snippets, explanations, and solutions retrieved from web sources.

Result: On the CGP benchmark, which includes C/C++, Python, and Go errors, WARP achieved a compilation success rate of 72.5% and demonstrated higher semantic correctness compared to both LLM-only approaches and traditional IDE quick-fixes.

Conclusion: WARP offers a more effective method for addressing compilation errors by integrating code understanding and synthesis from Code-LLMs and web sources. While challenges remain with synthesizing accurate information from noisy web data, the system represents a promising direction for improving real-time error resolution in development tools.

Abstract: Compilation errors represent a significant bottleneck in software development
productivity. This paper introduces WARP (Web-Augmented Real-time Program
Repairer), a novel system that leverages Large Language Models (LLMs) and
dynamic web-augmented synthesis for real-time resolution of these errors. WARP
actively monitors developer terminals, intelligently detects compilation
errors, and synergistically combines the understanding of a fine-tuned Code-LLM
with relevant solutions, explanations, and code snippets retrieved from
up-to-date web sources like developer forums and official documentation.
Experimental results on our curated benchmark, CGP (featuring C/C++, Python,
and Go errors), demonstrate WARP achieves a superior fix rate (72.5 % Compiles
correctly) and higher semantic correctness compared to baseline LLM-only
approaches and traditional IDE quick-fixes. Key technical challenges in
achieving high-accuracy synthesis from noisy web data.

</details>


### [21] [Devstral: Fine-tuning Language Models for Coding Agent Applications](https://arxiv.org/abs/2509.25193)
*Abhinav Rastogi,Adam Yang,Albert Q. Jiang,Alexander H. Liu,Alexandre Sablayrolles,Amélie Héliou,Amélie Martin,Anmol Agarwal,Andy Ehrenberg,Andy Lo,Antoine Roux,Arthur Darcet,Arthur Mensch,Baptiste Bout,Baptiste Rozière,Baudouin De Monicault,Chris Bamford,Christian Wallenwein,Christophe Renaudin,Clémence Lanfranchi,Clément Denoix,Corentin Barreau,Darius Dabert Devon Mizelle,Diego de las Casas,Elliot Chane-Sane,Emilien Fugier,Emma Bou Hanna,Gabrielle Berrada,Gauthier Delerce,Gauthier Guinet,Georgii Novikov,Graham Neubig,Guillaume Lample,Guillaume Martin,Himanshu Jaju,Jan Ludziejewski,Jason Rute,Jean-Malo Delignon,JeanHadrien Chabran,Joachim Studnia,Joep Barmentlo,Jonas Amar,Josselin Somerville Roberts,Julien Denize,Karan Saxena,Karmesh Yadav,Kartik Khandelwal,Khyathi Raghavi Chandu,Kush Jain,Lélio Renard Lavaud,Léonard Blier,Lingxiao Zhao,Louis Martin,Lucile Saulnier,Luyu Gao,Marie Pellat,Mathilde Guillaumin,Mathis Felardos,Matthieu Dinot,Maxime Darrin,Maximilian Augustin,Mickaël Seznec,Neha Gupta,Nikhil Raghuraman,Olivier Duchenne,Patricia Wang,Patrick von Platen,Patryk Saffer,Paul Jacob,Paul Wambergue,Paula Kurylowicz,Philomène Chagniot,Pierre Stock,Pravesh Agrawal,Rémi Delacourt,Roman Soletskyi,Romain Sauvestre,Sagar Vaze,Sanchit Gandhi,Sandeep Subramanian,Shashwat Dalal,Siddharth Gandhi,Soham Ghosh,Srijan Mishra,Sumukh Aithal,Szymon Antoniak,Teven Le Scao,Thibaut Lavril,Thibault Schueller,Thomas Foubert,Thomas Robert,Thomas Wang,Timothée Lacroix,Tom Bewley,Valeriia Nemychnikova,Victor Paltz,Virgile Richard,Wen-Ding Li,William Marshall,Xingyao Wang,Xuanyu Zhang,Yihan Wan,Yunhao Tang*

Main category: cs.SE

TL;DR: Devstral-Small is a compact open-source code agent model (24B parameters) with state-of-the-art performance for models under 100B size.


<details>
  <summary>Details</summary>
Motivation: Address the need for efficient, high-performance code agents by challenging the assumption that larger models are inherently better.

Method: Designed and developed a specialized 24B model optimized for agentic software development tasks through architecture and training innovations.

Result: Achieved competitive performance relative to models over ten times larger while maintaining fast inference and ease of deployment.

Conclusion: Devstral-Small demonstrates that small models can achieve strong code agent capabilities, enabling accessible and scalable agentic software development.

Abstract: We introduce Devstral-Small, a lightweight open source model for code agents
with the best performance among models below 100B size. In this technical
report, we give an overview of how we design and develop a model and craft
specializations in agentic software development. The resulting model,
Devstral-Small is a small 24B model, fast and easy to serve. Despite its size,
Devstral-Small still attains competitive performance compared to models more
than an order of magnitude larger.

</details>


### [22] [Automated Code Development for PDE Solvers Using Large Language Models](https://arxiv.org/abs/2509.25194)
*Haoyang Wu,Xinxin Zhang,Lailai Zhu*

Main category: cs.SE

TL;DR: LLM-PDEveloper is a zero-shot multi-agent framework that automates code development for PDE libraries by translating mathematical/algorithmic descriptions into code, expanding library capabilities through an end-to-end math-to-code pipeline.


<details>
  <summary>Details</summary>
Motivation: Existing LLM applications in scientific libraries focus on automating user workflows, but lack systematic code development for secondary developers. This limits expansion of PDE solver libraries despite LLMs’ cross-domain reasoning potential.

Method: The framework employs a multi-agent LLM architecture to (1’ translate mathematical specifications into source code, (2) adapt existing solvers/modules via code generation, and (3’ create self-augmenting pipelines for iterative library expansion through generated code.

Result: Three tasks demonstrated automated code generation: new PDE solver development, boundary condition implementation, and solver modification with additional terms. Achieved moderate success rates with detailed analysis of syntactic/semantic error mechanisms and proposed fixes for common LLM-generated syntactic errors.

Conclusion: LLM-PDEveloper establishes a viable architecture for automating scientific library development through math-to-code translation, while identifying technical barriers (error mechanisms) that guide future research in robust scientific code generation.

Abstract: Foundation models -- large language models (LLMs) in particular -- have
become ubiquitous, shaping daily life and driving breakthroughs across science,
engineering, and technology. Harnessing their broad cross-domain knowledge,
text-processing, and reasoning abilities for software development, e.g.,
numerical libraries for solving partial differential equations (PDEs), is
therefore attracting growing interest. Yet existing studies mainly automate
case setup and execution for end users. We introduce LLM-PDEveloper, a
zero-shot, multi-agent LLM framework that automates code development for PDE
libraries, specifically targeting secondary developers. By translating
mathematical and algorithmic descriptions directly into source code,
LLM-PDEveloper generates new solvers/modules and adapts existing ones. This
end-to-end math-to-code approach enables a self-augmenting pipeline that
continuously expands the codebase of a library, extends its capacities, and
broadens its scope. We demonstrate LLM-PDEveloper on three tasks: 1) build a
solver for a new PDE, 2) implement new BCs for a given PDE, and 3) modify an
existing solver to incorporate additional terms, achieving moderate success
rates. Failures due to syntactic errors made by LLMs are analyzed and we
propose effective fixes. We also identify the mechanisms underlying certain
semantic errors, guiding future research.

</details>


### [23] [Understanding Practitioners Perspectives on Monitoring Machine Learning Systems](https://arxiv.org/abs/2509.25195)
*Hira Naveed,John Grundy,Chetan Arora,Hourieh Khalajzadeh,Omar Haggag*

Main category: cs.SE

TL;DR: A survey of 91 ML practitioners reveals key monitoring challenges (runtime issues, manual workflows, setup complexity) and desired improvements (automation, performance/fairness support) to guide future ML monitoring tool development.


<details>
  <summary>Details</summary>
Motivation: ML systems' non-deterministic nature leads to unpredictable production behaviors, necessitating effective monitoring to prevent financial and reputational harm. Existing research lacks practitioner-focused analysis of monitoring practices.

Method: The paper conducted a global survey of 91 ML practitioners to gather insights on monitoring practices, followed by qualitative and quantitative analysis of the data to identify trends, challenges, and desired improvements.

Result: Findings highlight struggles with runtime issues (model performance decline, latency, security violations), reliance on manual monitoring due to automation gaps, challenges in tool setup/configuration, and desired improvements: automated monitor deployment, enhanced performance/fairness monitoring, and runtime issue resolution guidance.

Conclusion: The insights from the survey provide a roadmap for developing ML monitoring tools that better meet practitioners' needs by addressing current challenges and enhancing automation and support features.

Abstract: Given the inherent non-deterministic nature of machine learning (ML) systems,
their behavior in production environments can lead to unforeseen and
potentially dangerous outcomes. For a timely detection of unwanted behavior and
to prevent organizations from financial and reputational damage, monitoring
these systems is essential. This paper explores the strategies, challenges, and
improvement opportunities for monitoring ML systems from the practitioners
perspective. We conducted a global survey of 91 ML practitioners to collect
diverse insights into current monitoring practices for ML systems. We aim to
complement existing research through our qualitative and quantitative analyses,
focusing on prevalent runtime issues, industrial monitoring and mitigation
practices, key challenges, and desired enhancements in future monitoring tools.
Our findings reveal that practitioners frequently struggle with runtime issues
related to declining model performance, exceeding latency, and security
violations. While most prefer automated monitoring for its increased
efficiency, many still rely on manual approaches due to the complexity or lack
of appropriate automation solutions. Practitioners report that the initial
setup and configuration of monitoring tools is often complicated and
challenging, particularly when integrating with ML systems and setting alert
thresholds. Moreover, practitioners find that monitoring adds extra workload,
strains resources, and causes alert fatigue. The desired improvements from the
practitioners perspective are: automated generation and deployment of monitors,
improved support for performance and fairness monitoring, and recommendations
for resolving runtime issues. These insights offer valuable guidance for the
future development of ML monitoring tools that are better aligned with
practitioners needs.

</details>


### [24] [APRIL: API Synthesis with Automatic Prompt Optimization and Reinforcement Learning](https://arxiv.org/abs/2509.25196)
*Hua Zhong,Shan Jiang,Sarfraz Khurshid*

Main category: cs.SE

TL;DR: The paper introduces APRIL, a method that combines LLM-based synthesis with APO and RLVR for efficient API composition, showing significant improvements over existing models.


<details>
  <summary>Details</summary>
Motivation: Composing new APIs from large libraries is challenging due to exponential search spaces and limitations in traditional synthesis methods and LLMs, such as hallucinations and lack of up-to-date context.

Method: APRIL integrates LLM-based synthesis with Automatic Prompt Optimization (APO) to refine prompts for a frozen model and Reinforcement Learning from Verifiable Rewards (RLVR) to fine-tune the policy towards functional correctness, creating an efficient synthesis pipeline.

Result: APRIL was evaluated on 81 real-world APIs from popular scientific Python libraries and outperformed instruction-tuned but unfine-tuned LLMs guided by expert prompts in terms of effectiveness and scalability.

Conclusion: The integration of APO and RLVR in APRIL provides a robust and scalable solution for component-based API synthesis in large libraries, demonstrating significant improvements in accuracy and efficiency.

Abstract: APIs are central to modern software development, yet composing new APIs from
large libraries is difficult due to the exponential search space; traditional
component-based synthesis relies on costly exploration and hand-crafted
specifications. While large language models (LLMs) can generate implementations
from natural language, hallucinations and limited access to up-to-date
contextual information often yield incorrect code. In this paper, we present
APRIL, an approach that combines LLM-based synthesis with Automatic Prompt
Optimization (APO) and Reinforcement Learning from Verifiable Rewards (RLVR):
APO iteratively refines prompts for a frozen model, while RLVR fine-tunes the
policy toward functional correctness, producing an efficient synthesis
pipeline. Evaluated on 81 real-world APIs from widely used scientific Python
libraries and benchmarked against instruction-tuned but unfine-tuned LLMs
guided by expert prompts, APRIL achieves substantial improvements. These
results indicate that integrating APO and RLVR provides a robust, scalable path
for component-based API synthesis in large libraries.

</details>


### [25] [Towards Repository-Level Program Verification with Large Language Models](https://arxiv.org/abs/2509.25197)
*Si Cheng Zhong,Xujie Si*

Main category: cs.SE

TL;DR: RVBench and RagVerus address repository-level verification: RVBench challenges LLMs with real-world software, while RagVerus improves proof synthesis via retrieval and context-aware prompts, showing significant performance boosts.


<details>
  <summary>Details</summary>
Motivation: Existing LLM-based methods focus on isolated, function-level tasks, overlooking real-world challenges like cross-module dependencies and global contexts in automated formal verification.

Method: RVBench is a repository-level verification benchmark constructed from four Verus projects, and RagVerus combines retrieval-augmented generation with context-aware prompting for scalable proof synthesis.

Result: RagVerus triples proof pass rates on existing benchmarks and achieves 27% relative improvement on RVBench under constrained model inference budgets.

Conclusion: The paper introduces RVBench and RagVerus, addressing repository-level verification challenges by handling cross-module dependencies and global contexts, with significant improvements in proof pass rates.

Abstract: Recent advancements in large language models (LLMs) suggest great promises in
code and proof generations. However, scaling automated formal verification to
real-world projects requires resolving cross-module dependencies and global
contexts, which are crucial challenges overlooked by existing LLM-based methods
with a special focus on targeting isolated, function-level verification tasks.
To systematically explore and address the significant challenges of verifying
entire software repositories, we introduce RVBench, the first verification
benchmark explicitly designed for repository-level evaluation, constructed from
four diverse and complex open-source Verus projects.
  We further introduce RagVerus, an extensible framework that synergizes
retrieval-augmented generation with context-aware prompting to automate proof
synthesis for multi-module repositories. RagVerus triples proof pass rates on
existing benchmarks under constrained model inference budgets, and achieves a
27% relative improvement on the more challenging RVBench benchmark,
demonstrating a scalable and sample-efficient verification solution.

</details>


### [26] [CircInspect: Integrating Visual Circuit Analysis, Abstraction, and Real-Time Development in Quantum Debugging](https://arxiv.org/abs/2509.25199)
*Mushahid Khan,Prashant J. Nair,Olivia Di Matteo*

Main category: cs.SE

TL;DR: CircInspect is a debugging tool for quantum programs in Python and PennyLane, offering features like breakpoints and real-time monitoring to analyze quantum circuits and improve understanding.


<details>
  <summary>Details</summary>
Motivation: Quantum software development introduces complexities due to the probabilistic nature of quantum computing, distinct algorithmic primitives, and potential hardware noise.

Method: CircInspect uses breakpoints and real-time software development features to allow users to analyze isolated quantum circuit components, monitor program output, and visualize structural changes.

Result: The result of developing CircInspect is the introduction of a new debugging tool that can be used for quantum programs in Python and PennyLane.

Conclusion: CircInspect is an interactive tool that addresses the unique challenges of quantum software debugging by providing useful features for component analysis, output monitoring, and structural visualization.

Abstract: Software bugs typically result from errors in specifications or code
translation. While classical software engineering has evolved with various
tools and methodologies to tackle such bugs, the emergence of quantum computing
presents unique challenges. Quantum software development introduces
complexities due to the probabilistic nature of quantum computing, distinct
algorithmic primitives, and potential hardware noise. In this paper, we
introduce CircInspect, an interactive tool tailored for debugging quantum
programs in Python and PennyLane. By leveraging breakpoints and real-time
software development features, \toolname~empowers users to analyze isolated
quantum circuit components, monitor program output, visualize structural
changes, and abstract information to enhance comprehension.

</details>


### [27] [Generating High-Quality Datasets for Code Editing via Open-Source Language Models](https://arxiv.org/abs/2509.25203)
*Zekai Zhang,Mingwei Liu,Zhenxi Chen,Linxi Liang,Yuxuan Chen,Guangsheng Ou,Yanlin Wang,Dan Li,Xin Peng,Zibin Zheng*

Main category: cs.SE

TL;DR: The paper introduces CanItEdit, a pipeline for synthesizing realistic code-edit triplets using multiple LLMs, and presents OCEDataFT, a curated dataset. Fine-tuning models on this dataset significantly improves performance, reducing the gap to GPT-4.


<details>
  <summary>Details</summary>
Motivation: Commit-based datasets for code editing are noisy, lack diversity, and do not reflect real-world edit instructions' style, limiting model performance improvements.

Method: CanItEdit uses multiple LLMs to generate both concise and detailed code-edit instructions, followed by filtering based on diffs and topics to ensure data quality and variety. The pipeline produces a curated dataset of 20K samples, OCEDataFT.

Result: Fine-tuning three advanced base models on OCEDataFT resulted in performance boosts on the CanItEdit benchmark. The relative pass@1 improvements ranged from 4.50% to 20.79%, with the resulting models achieving performance within 3.54% of GPT-4.

Conclusion: The proposed CanItEdit pipeline and OCEDataFT dataset effectively enhance code editing model performance, bridging the gap to closed-source systems like GPT-4 without proprietary resources or manual annotation.

Abstract: Code editing plays a vital role in software engineering, requiring developers
to adjust existing code according to natural language instructions while
keeping functionality intact and avoiding unnecessary modifications. However,
commit-based datasets commonly used for this task are often noisy, lack
diversity, and fail to reflect the style of real-world edit instructions. To
address this, we introduce CanItEdit, an open-source pipeline that leverages
multiple LLMs to synthesize realistic code-edit triplets. The pipeline produces
both concise "lazy" instructions and more detailed "descriptive" ones, and
applies filtering based on diffs and topics to guarantee data quality and
variety. Using this process, we construct OCEDataFT, a curated dataset of 20K
samples. Fine-tuning three advanced base models on OCEDataFT leads to
significant performance boosts on the CanItEdit benchmark, with relative pass@1
improvements ranging from 4.50% to 20.79%. Notably, the resulting models
achieve performance close to closed-source systems, narrowing the gap to GPT-4
to just 3.54%, without relying on proprietary resources or manual annotation.

</details>


### [28] [A Benchmark for Localizing Code and Non-Code Issues in Software Projects](https://arxiv.org/abs/2509.25242)
*Zejun Zhang,Jian Wang,Qingyun Yang,Yifan Pan,Yi Tang,Yi Li,Zhenchang Xing,Tian Zhang,Xuandong Li,Guoan Zhang*

Main category: cs.SE

TL;DR: MULocBench addresses gaps in issue localization benchmarks by introducing a diverse dataset showing current methods' poor performance (Acc@5, F1 <40%), emphasizing real-world generalization challenges.


<details>
  <summary>Details</summary>
Motivation: Existing benchmarks like SWE-Bench and LocBench focus narrowly on code locations and pull-requests, neglecting critical evidence such as commits, comments, and documentation, hindering realistic evaluation of issue localization.

Method: The authors created MULocBench, a dataset of 1,100 issues from 46 GitHub projects, and evaluated state-of-the-art localization methods and LLM-based prompting strategies to analyze their limitations.

Result: Current methods achieve below 40% accuracy at the file level, demonstrating significant limitations in handling diverse, multifaceted issues despite the inclusion of varied root causes and file types in MULocBench.

Conclusion: The paper highlights the challenges in generalizing issue resolution methods and introduces MULocBench to enable future research on project localization by providing a more realistic evaluation framework.

Abstract: Accurate project localization (e.g., files and functions) for issue
resolution is a critical first step in software maintenance. However, existing
benchmarks for issue localization, such as SWE-Bench and LocBench, are limited.
They focus predominantly on pull-request issues and code locations, ignoring
other evidence and non-code files such as commits, comments, configurations,
and documentation. To address this gap, we introduce MULocBench, a
comprehensive dataset of 1,100 issues from 46 popular GitHub Python projects.
Comparing with existing benchmarks, MULocBench offers greater diversity in
issue types, root causes, location scopes, and file types, providing a more
realistic testbed for evaluation. Using this benchmark, we assess the
performance of state-of-the-art localization methods and five LLM-based
prompting strategies. Our results reveal significant limitations in current
techniques: even at the file level, performance metrics (Acc@5, F1) remain
below 40%. This underscores the challenge of generalizing to realistic,
multi-faceted issue resolution. To enable future research on project
localization for issue resolution, we publicly release MULocBench at
https://huggingface.co/datasets/somethingone/MULocBench.

</details>


### [29] [Reinforcement Learning-Guided Chain-of-Draft for Token-Efficient Code Generation](https://arxiv.org/abs/2509.25243)
*Xunzhu Tang,Iyiola Emmanuel Olatunji,Tiezhu Sun,Jacques Klein,Tegawende F. Bissyande*

Main category: cs.SE

TL;DR: MultiCoD: Uses RL to select top code generation solutions from CoD candidates, reducing costs by 50% and boosting quality across benchmarks like MBPP and BigCodeBench.


<details>
  <summary>Details</summary>
Motivation: While Chain-of-Thought (CoT) and Chain-of-Draft (CoD) prompting improve code generation through structured reasoning, they suffer from verbosity (CoT) and stochastic quality variation (CoD), making optimal solution selection challenging. This limits their practical scalability and cost-effectiveness.

Method: MultiCoD employs a reinforcement learning framework that models solution selection as a contextual bandit problem. It uses strategy-guided prompting to generate diverse reasoning styles and optimizes interpretable features (code complexity, reasoning structure, strategic metadata) via a reward function balancing correctness, efficiency, and clarity.

Result: Experiments on MBPP, BigCodeBench, SWE-bench Verified, and Defects4J demonstrate MultiCoD outperforms or matches standard prompting, CoT, and CoD baselines. The framework reduces user billing by >50% through a multi-candidate design that only charges for the selected output, while improving LLM response quality.

Conclusion: MultiCoD is presented as a more sustainable and scalable solution for real-world deployment in code generation tasks due to its cost efficiency and improved response quality.

Abstract: LLMs demonstrate surface-level fluency in code generation but struggle with
structured reasoning tasks requiring correctness and semantic alignment. While
Chain-of-Thought (CoT) prompting enhances reasoning through intermediate steps,
it suffers from verbosity and inefficiency. Chain-of-Draft (CoD) prompting
offers more concise reasoning, but the stochastic nature of LLMs produces
varying solution quality, making optimal selection challenging. We propose
\multicod, a reinforcement learning framework that learns to select the most
promising candidate from CoD-generated solutions. Our approach uses
strategy-guided prompting to encourage diverse reasoning styles and models
solution selection as a contextual bandit problem. The framework optimizes
interpretable features including code complexity, reasoning structure, and
strategic metadata through a reward function balancing correctness, efficiency,
and clarity. Experiments on MBPP, BigCodeBench, SWE-bench Verified, and
Defects4J show \multicod~outperforms and in some cases, on par with standard
prompting, CoT, and CoD baselines while achieving cost and token efficiency
from the user's perspective through a multi-candidate design that charges only
for the selected output, reducing user billing by over 50\% and improving LLM
response quality, making \multicod~more sustainable and scalable for real-world
deployment. Our code is available: https://anonymous.4open.science/r/MultiCoD.

</details>


### [30] [Protocode: Prototype-Driven Interpretability for Code Generation in LLMs](https://arxiv.org/abs/2509.25247)
*Krishna Vamshi Bodla,Haizhao Yang*

Main category: cs.SE

TL;DR: This paper investigates how In-Context Learning (ICL)$ demonstrations impact LLM code generation, showing high-quality ICL samples improve performance and interpretability while poor samples reduce model accuracy.


<details>
  <summary>Details</summary>
Motivation: Reliance on LLM code generation increases developer productivity but introduces risks of suboptimal solutions and insecure code. Understanding ICL demonstration impact is critical for improving reliability.

Method: The study uses AST-based analysis of MBPP test set outputs to identify code regions influenced by ICL demonstrations, experimenting with quality-based sampling strategies for pass@10 metric evaluation.

Result: High-quality ICL demonstrations improved pass@10 scores and code interpretability, while poor demonstrations caused performance degradation compared to base models.

Conclusion: Effective ICL sampling strategies significantly affect LLM performance and code quality, highlighting the need for robust demonstration selection mechanisms in code generation tasks.

Abstract: Since the introduction of Large Language Models (LLMs), they have been widely
adopted for various tasks such as text summarization, question answering,
speech-to-text translation, and more. In recent times, the use of LLMs for code
generation has gained significant attention, with tools such as Cursor and
Windsurf demonstrating the ability to analyze massive code repositories and
recommend relevant changes. Big tech companies have also acknowledged the
growing reliance on LLMs for code generation within their codebases. Although
these advances significantly improve developer productivity, increasing
reliance on automated code generation can proportionally increase the risk of
suboptimal solutions and insecure code. Our work focuses on automatically
sampling In-Context Learning (ICL) demonstrations which can improve model
performance and enhance the interpretability of the generated code. Using
AST-based analysis on outputs from the MBPP test set, we identify regions of
code most influenced by the chosen demonstrations. In our experiments, we show
that high-quality ICL demonstrations not only make outputs easier to interpret
but also yield a positive performance improvement on the pass@10 metric.
Conversely, poorly chosen ICL demonstrations affected the LLM performance on
the pass@10 metric negatively compared to the base model. Overall, our approach
highlights the importance of efficient sampling strategies for ICL, which can
affect the performance of the model on any given task.

</details>


### [31] [BuildBench: Benchmarking LLM Agents on Compiling Real-World Open-Source Software](https://arxiv.org/abs/2509.25248)
*Zehua Zhang,Ati Priya Bajaj,Divij Handa,Siyu Liu,Arvind S Raj,Hongkai Chen,Hulin Wang,Yibo Liu,Zion Leonahenahe Basque,Souradip Nath,Vishal Juneja,Nikhil Chapre,Yan Shoshitaishvili,Adam Doupé,Chitta Baral,Ruoyu Wang*

Main category: cs.SE

TL;DR: This paper introduces BUILD-BENCH, a realistic benchmark for compiling open-source software (OSS) and proposes an LLM-based agent, OSS-BUILD-AGENT, to address the challenges of automated OSS compilation.


<details>
  <summary>Details</summary>
Motivation: Compiling OSS is a labor-intensive and complex task, and current methods using manually curated rules or selective evaluation fail to address the diverse and realistic challenges of automated compilation.

Method: The paper presents BUILD-BENCH, a new benchmark featuring diverse-quality OSS projects for realistic compilation tasks, and proposes the OSS-BUILD-AGENT, an LLM agent with an enhanced build instruction retrieval module designed for adaptability and performance.

Result: OSS-BUILD-AGENT achieves state-of-the-art performance on BUILD-BENCH and demonstrates adaptability to different OSS characteristics, with analysis provided on compilation design choices impacting task effectiveness.

Conclusion: The proposed benchmark and agent set a new standard for evaluating automated OSS compilation, with the potential to drive innovation and support downstream software development and security applications.

Abstract: Automatically compiling open-source software (OSS) projects is a vital,
labor-intensive, and complex task, which makes it a good challenge for LLM
Agents. Existing methods rely on manually curated rules and workflows, which
cannot adapt to OSS that requires customized configuration or environment
setup. Recent attempts using Large Language Models (LLMs) used selective
evaluation on a subset of highly rated OSS, a practice that underestimates the
realistic challenges of OSS compilation. In practice, compilation instructions
are often absent, dependencies are undocumented, and successful builds may even
require patching source files or modifying build scripts. We propose a more
challenging and realistic benchmark, BUILD-BENCH, comprising OSS that are more
diverse in quality, scale, and characteristics. Furthermore, we propose a
strong baseline LLM-based agent, OSS-BUILD-AGENT, an effective system with
enhanced build instruction retrieval module that achieves state-of-the-art
performance on BUILD-BENCH and is adaptable to heterogeneous OSS
characteristics. We also provide detailed analysis regarding different
compilation method design choices and their influence to the whole task,
offering insights to guide future advances. We believe performance on
BUILD-BENCH can faithfully reflect an agent's ability to tackle compilation as
a complex software engineering tasks, and, as such, our benchmark will spur
innovation with a significant impact on downstream applications in the fields
of software development and software security.

</details>


### [32] [RANGER -- Repository-Level Agent for Graph-Enhanced Retrieval](https://arxiv.org/abs/2509.25257)
*Pratik Shah,Rajat Ghosh,Aryan Singhal,Debojyoti Dutta*

Main category: cs.SE

TL;DR: RANGER is a repository-level code retrieval agent that addresses both code entity and natural language queries with a comprehensive knowledge graph and a dual-stage retrieval pipeline. It outperforms embedding-based baselines in code search and question answering and improves cross-file dependency retrieval and code completion.


<details>
  <summary>Details</summary>
Motivation: Existing methods for automated software engineering tasks primarily focus on code entity queries, leaving a gap in handling general natural language queries effectively. Additionally, gaps still exist in cross-file dependency retrieval and repository-level code completion.

Method: 1. Construct a comprehensive knowledge graph of the entire repository with hierarchical and cross-file dependencies down to the variable level;
2. Augment graph nodes with textual descriptions and embeddings for code-NLP integration;
3. Implement a dual-stage retrieval pipeline where entity queries are addressed with Cypher lookups and natural language queries with MCTS-guided exploration.

Result: RANGER achieves state-of-the-art performance in code search (CodeSearchNet), question answering (RepoQA), and cross-file dependency retrieval (RepoBench). When paired with BM25, it delivers the highest exact match rate in repository-level code completion on CrossCodeEval.

Conclusion: RANGER is a versatile and efficient repository-level code retrieval agent that bridges code and natural language interactions, offering a robust solution for a wide range of ASE tasks with superior performance across four diverse benchmarks.

Abstract: General-purpose automated software engineering (ASE) includes tasks such as
code completion, retrieval, repair, QA, and summarization. These tasks require
a code retrieval system that can handle specific queries about code entities,
or code entity queries (for example, locating a specific class or retrieving
the dependencies of a function), as well as general queries without explicit
code entities, or natural language queries (for example, describing a task and
retrieving the corresponding code). We present RANGER, a repository-level code
retrieval agent designed to address both query types, filling a gap in recent
works that have focused primarily on code-entity queries. We first present a
tool that constructs a comprehensive knowledge graph of the entire repository,
capturing hierarchical and cross-file dependencies down to the variable level,
and augments graph nodes with textual descriptions and embeddings to bridge the
gap between code and natural language. RANGER then operates on this graph
through a dual-stage retrieval pipeline. Entity-based queries are answered
through fast Cypher lookups, while natural language queries are handled by
MCTS-guided graph exploration. We evaluate RANGER across four diverse
benchmarks that represent core ASE tasks including code search, question
answering, cross-file dependency retrieval, and repository-level code
completion. On CodeSearchNet and RepoQA it outperforms retrieval baselines that
use embeddings from strong models such as Qwen3-8B. On RepoBench, it achieves
superior cross-file dependency retrieval over baselines, and on CrossCodeEval,
pairing RANGER with BM25 delivers the highest exact match rate in code
completion compared to other RAG methods.

</details>


### [33] [Automatically Generating Web Applications from Requirements Via Multi-Agent Test-Driven Development](https://arxiv.org/abs/2509.25297)
*Yuxuan Wan,Tingshuo Liang,Jiakai Xu,Jingyu Xiao,Yintong Huo,Michael R. Lyu*

Main category: cs.SE

TL;DR: This paper introduces TDDev, the first test-driven development (TDD)-enabled LLM-agent framework for end-to-end full-stack web application generation, achieving higher accuracy than existing solutions.


<details>
  <summary>Details</summary>
Motivation: Current MLLMs for web development focus only on front-end tasks and lack test-driven approaches, leading to underspecified requirements, fragmented code dependencies, and functional/visual fidelity challenges in automation.

Method: TDDev automatically (1) generates executable test cases from natural language/images, (2) creates front-end/back-end code, (3)f simulates user interactions, and (4)f iteratively refines implementation until test requirements are met, addressing cross-file dependencies and UI/UX expectations.

Result: Experiments show TDDev improves overall accuracy by 14.4 percentage points compared to state-of-the-art baselines across diverse application scenarios.

Conclusion: TDDev demonstrates the feasibility of test-driven automated full-stack web development, producing reliable applications with minimal manual intervention, opening new directions for LLM-agent based software engineering pipelines.

Abstract: Developing full-stack web applications is complex and time-intensive,
demanding proficiency across diverse technologies and frameworks. Although
recent advances in multimodal large language models (MLLMs) enable automated
webpage generation from visual inputs, current solutions remain limited to
front-end tasks and fail to deliver fully functional applications. In this
work, we introduce TDDev, the first test-driven development (TDD)-enabled
LLM-agent framework for end-to-end full-stack web application generation. Given
a natural language description or design image, TDDev automatically derives
executable test cases, generates front-end and back-end code, simulates user
interactions, and iteratively refines the implementation until all requirements
are satisfied. Our framework addresses key challenges in full-stack automation,
including underspecified user requirements, complex interdependencies among
multiple files, and the need for both functional correctness and visual
fidelity. Through extensive experiments on diverse application scenarios, TDDev
achieves a 14.4% improvement on overall accuracy compared to state-of-the-art
baselines, demonstrating its effectiveness in producing reliable, high-quality
web applications without requiring manual intervention.

</details>


### [34] [Detecting and Fixing API Misuses of Data Science Libraries Using Large Language Models](https://arxiv.org/abs/2509.25378)
*Akalanka Galappaththi,Francisco Ribeiro,Sarah Nadi*

Main category: cs.SE

TL;DR: DSCHECKER, an LLM-based tool for detecting and fixing API misuses in data science libraries, demonstrates strong performance (up to 61.18% detection F1-score) and effective adaptability in real-world scenarios, offering a promising solution to a challenging problem.


<details>
  <summary>Details</summary>
Motivation: The data-centric nature of libraries like scikit-learn and pandas complicates API misuse detection. Traditional methods struggle with this complexity, necessitating new approaches.

Method: DSCHECKER is an LLM-based approach that leverages API directives and data-specific information. It uses three LLMs, misuses from five libraries, and adaptive function calling mechanisms to simulate real-world conditions.

Result: The best model achieved 61.18% detection F1-score and fixed 51.28% of misuses. The DSCHECKER agent achieved 48.65% detection F1-score and resolved 39.47% of misuses in real-world simulations.

Conclusion: The paper concludes that LLM-based approaches like DSCHECKER show promise in detecting and fixing API misuses in data science libraries, even in real-world scenarios where misuse information is unknown in advance.

Abstract: Data science libraries, such as scikit-learn and pandas, specialize in
processing and manipulating data. The data-centric nature of these libraries
makes the detection of API misuse in them more challenging. This paper
introduces DSCHECKER, an LLM-based approach designed for detecting and fixing
API misuses of data science libraries. We identify two key pieces of
information, API directives and data information, that may be beneficial for
API misuse detection and fixing. Using three LLMs and misuses from five data
science libraries, we experiment with various prompts. We find that
incorporating API directives and data-specific details enhances Dschecker's
ability to detect and fix API misuses, with the best-performing model achieving
a detection F1-score of 61.18 percent and fixing 51.28 percent of the misuses.
Building on these results, we implement Dschecker agent which includes an
adaptive function calling mechanism to access information on demand, simulating
a real-world setting where information about the misuse is unknown in advance.
We find that Dschecker agent achieves 48.65 percent detection F1-score and
fixes 39.47 percent of the misuses, demonstrating the promise of LLM-based API
misuse detection and fixing in real-world scenarios.

</details>


### [35] [A Cartography of Open Collaboration in Open Source AI: Mapping Practices, Motivations, and Governance in 14 Open Large Language Model Projects](https://arxiv.org/abs/2509.25397)
*Johan Linåker,Cailean Osborne,Jennifer Ding,Ben Burtenshaw*

Main category: cs.SE

TL;DR: This paper analyzes collaboration patterns in open LLM development through 14 case studies across global organizations, revealing diverse collaboration types, developer motivations, and organizational models.


<details>
  <summary>Details</summary>
Motivation: Prior research has not comprehensively examined how open LLM projects are collaboratively developed and governed, limiting opportunities to enhance the open AI ecosystem.

Method: Semi-structured interviews with developers from 14 open LLM projects (including grassroots, research, startups, and Big Tech) across North America, Europe, Africa, and Asia.

Result: Three findings: (1)demonstration of multi-dimensional collaboration beyond models (e.g., datasets, frameworks), (2)diverse developer motivations (democratizing AI, regional ecosystems), (3)identification of five organizational models differing in centralization and community engagement.

Conclusion: Provides practical recommendations for stakeholders to support open LLM ecosystem growth, emphasizing varied collaboration strategies and governance models.

Abstract: The proliferation of open large language models (LLMs) is fostering a vibrant
ecosystem of research and innovation in artificial intelligence (AI). However,
the methods of collaboration used to develop open LLMs both before and after
their public release have not yet been comprehensively studied, limiting our
understanding of how open LLM projects are initiated, organized, and governed
as well as what opportunities there are to foster this ecosystem even further.
We address this gap through an exploratory analysis of open collaboration
throughout the development and reuse lifecycle of open LLMs, drawing on
semi-structured interviews with the developers of 14 open LLMs from grassroots
projects, research institutes, startups, and Big Tech companies in North
America, Europe, Africa, and Asia. We make three key contributions to research
and practice. First, collaboration in open LLM projects extends far beyond the
LLMs themselves, encompassing datasets, benchmarks, open source frameworks,
leaderboards, knowledge sharing and discussion forums, and compute
partnerships, among others. Second, open LLM developers have a variety of
social, economic, and technological motivations, from democratizing AI access
and promoting open science to building regional ecosystems and expanding
language representation. Third, the sampled open LLM projects exhibit five
distinct organizational models, ranging from single company projects to
non-profit-sponsored grassroots projects, which vary in their centralization of
control and community engagement strategies used throughout the open LLM
lifecycle. We conclude with practical recommendations for stakeholders seeking
to support the global community building a more open future for AI.

</details>


### [36] [PIPer: On-Device Environment Setup via Online Reinforcement Learning](https://arxiv.org/abs/2509.25455)
*Alexander Kovrigin,Aleksandra Eliseeva,Konstantin Grotov,Egor Bogomolov,Yaroslav Zharov*

Main category: cs.SE

TL;DR: This paper introduces a specialized LLM training approach combining RLVR and supervised fine-tuning to improve environment setup automation, achieving state-of-the-art performance with smaller models.


<details>
  <summary>Details</summary>
Motivation: Current LLM-based methods struggle with environment setup automation, creating a need for improved solutions to reduce developers' manual efforts and enable scalable benchmarking in software engineering research.

Method: The authors employ supervised fine-tuning to generate correct Bash scripts and implement Reinforcement Learning with Verifiable Rewards (RLVR) to adapt the model to environment setup tasks.

Result: On EnvBench-Python, the method enables Qwen3-8B to match the performance of larger models (Qwen3-32B, GPT-4o) in environment setup tasks while being hardware-efficient.

Conclusion: The study demonstrates that a specialized model trained with RLVR and supervised fine-tuning can significantly enhance environment setup automation. The approach achieves comparable performance to larger models with open-source accessibility.

Abstract: Environment setup-the process of configuring the system to work with a
specific software project-represents a persistent challenge in Software
Engineering (SE). Automated environment setup methods could assist developers
by providing fully configured environments for arbitrary repositories without
manual effort. This also helps SE researchers to scale execution-based
benchmarks. However, recent studies reveal that even state-of-the-art Large
Language Models (LLMs) achieve limited success in automating this task. To
address this limitation, we tune a specialized model for environment setup. We
combine supervised fine-tuning for generating correct Bash scripts and
Reinforcement Learning with Verifiable Rewards (RLVR) to adapt it to the task
of environment setup. On EnvBench-Python, our method enables Qwen3-8B (a model
runnable on consumer hardware) to perform on par with larger models-Qwen3-32B
and GPT-4o. The training code and model checkpoints are available online:
https://github.com/JetBrains-Research/PIPer.

</details>


### [37] [BloomAPR: A Bloom's Taxonomy-based Framework for Assessing the Capabilities of LLM-Powered APR Solutions](https://arxiv.org/abs/2509.25465)
*Yinghang Ma,Jiho Shin,Leuson Da Silva,Zhen Ming,Jiang,Song Wang,Foutse Khomh,Shin Hwei Tan*

Main category: cs.SE

TL;DR: BloomAPR: A dynamic evaluation framework for LLM-driven APR systems reveals performance gaps under synthetic/real-world conditions, stressing the need for evolving benchmarks to accurately assess cognitive capabilities.


<details>
  <summary>Details</summary>
Motivation: Static benchmarks (e.g., Defects4J, SWE-bench) face issues of data contamination and limited ability to assess APR systems in dynamic, context-diverse environments, leading to inflated and unreliable evaluation results.

Method: The authors proposed BloomAPR, a dynamic evaluation framework based on Bloom's Taxonomy, and evaluated state-of-the-art LLM-powered APR systems (ChatRepair and CigaR) across three LLMs (GPT-3.5-Turbo, Llama-3.1, StarCoder-2) using Defects4J as a case study.

Result: Results show APR systems excel in memorizing patterns (81.57% at 'Remember' layer), perform better with synthetic bugs (60.66% increase at 'Understand'), but struggle with syntactic changes (43.32% at 'Apply') and real-world scenarios (13.46%-41.34% at 'Analyze'), highlighting significant room for improvement.

Conclusion: The paper concludes that current static benchmarks for evaluating LLM-powered APR systems are insufficient, emphasizing the need for dynamic evaluation frameworks like BloomAPR to ensure more trustworthy assessments of such solutions.

Abstract: Recent advances in large language models (LLMs) have accelerated the
development of AI-driven automated program repair (APR) solutions. However,
these solutions are typically evaluated using static benchmarks such as
Defects4J and SWE-bench, which suffer from two key limitations: (1) the risk of
data contamination, potentially inflating evaluation results due to overlap
with LLM training data, and (2) limited ability to assess the APR capabilities
in dynamic and diverse contexts. In this paper, we introduced BloomAPR, a novel
dynamic evaluation framework grounded in Bloom's Taxonomy. Our framework offers
a structured approach to assess the cognitive capabilities of LLM-powered APR
solutions across progressively complex reasoning levels. Using Defects4J as a
case study, we evaluated two state-of-the-art LLM-powered APR solutions,
ChatRepair and CigaR, under three different LLMs: GPT-3.5-Turbo, Llama-3.1, and
StarCoder-2. Our findings show that while these solutions exhibit basic
reasoning skills and effectively memorize bug-fixing patterns (fixing up to
81.57% of bugs at the Remember layer), their performance increases with
synthetically generated bugs (up to 60.66% increase at the Understand layer).
However, they perform worse on minor syntactic changes (fixing up to 43.32% at
the Apply layer), and they struggle to repair similar bugs when injected into
real-world projects (solving only 13.46% to 41.34% bugs at the Analyze layer).
These results underscore the urgent need for evolving benchmarks and provide a
foundation for more trustworthy evaluation of LLM-powered software engineering
solutions.

</details>


### [38] [AGNOMIN -- Architecture Agnostic Multi-Label Function Name Prediction](https://arxiv.org/abs/2509.25514)
*Yonatan Gizachew Achamyeleh,Tongtao Zhang,Joshua Hyunki Kim,Gabriel Garcia,Shih-Yuan Yu,Anton Kocheturov,Mohammad Abdullah Al Faruque*

Main category: cs.SE

TL;DR: AGNOMIN tackles stripped binary reverse engineering via architecture-agnostic graph neural networks, achieving state-of-the-art performance (27%+ precision, 56%+ recall gains) and verified practicality in real-world security assessments.


<details>
  <summary>Details</summary>
Motivation: Existing methods for function name prediction in stripped binaries face architecture-specific constraints, data scarcity, and inconsistent naming conventions, limiting their scalability and effectiveness in vulnerability analysis and patching across heterogeneous architectures.

Method: AGNOMIN constructs Feature-Enriched Hierarchical Graphs (FEHGs) combining CFGs, FCGs, and PCode features, processed by a hierarchical GNN to create architecture-agnostic function representations. It uses a Renée-inspired decoder with attention mechanisms and algorithmic optimizations.

Result: AGNOMIN outperforms state-of-the-art approaches by 27.17% in precision and 55.86% in recall on 9,000+ ELF binaries across three architectures. It achieves 5.89% higher recall on unseen architectures and demonstrates practical utility in security hackathons for vulnerability analysis.

Conclusion: AGNOMIN offers a scalable, architecture-agnostic solution for multi-label function name prediction, effectively addressing limitations of prior methods and demonstrating significant improvements in precision, recall, and cross-architecture generalizability.

Abstract: Function name prediction is crucial for understanding stripped binaries in
software reverse engineering, a key step for \textbf{enabling subsequent
vulnerability analysis and patching}. However, existing approaches often
struggle with architecture-specific limitations, data scarcity, and diverse
naming conventions. We present AGNOMIN, a novel architecture-agnostic approach
for multi-label function name prediction in stripped binaries. AGNOMIN builds
Feature-Enriched Hierarchical Graphs (FEHGs), combining Control Flow Graphs,
Function Call Graphs, and dynamically learned \texttt{PCode} features. A
hierarchical graph neural network processes this enriched structure to generate
consistent function representations across architectures, vital for
\textbf{scalable security assessments}. For function name prediction, AGNOMIN
employs a Ren\'ee-inspired decoder, enhanced with an attention-based head layer
and algorithmic improvements.
  We evaluate AGNOMIN on a comprehensive dataset of 9,000 ELF executable
binaries across three architectures, demonstrating its superior performance
compared to state-of-the-art approaches, with improvements of up to 27.17\% in
precision and 55.86\% in recall across the testing dataset. Moreover, AGNOMIN
generalizes well to unseen architectures, achieving 5.89\% higher recall than
the closest baseline. AGNOMIN's practical utility has been validated through
security hackathons, where it successfully aided reverse engineers in analyzing
and patching vulnerable binaries across different architectures.

</details>


### [39] [M&SCheck: Towards a Checklist to Support Software Engineering Newcomers to the Modeling and Simulation Area](https://arxiv.org/abs/2509.25625)
*Luiza Martins de Freitas Cintra,Philipp Zech,Mohamad Kassab,Eliomar Araújo Lima,Sofia Larissa da Costa Paiva,Valdemar Vicente Graciano Neto*

Main category: cs.SE

TL;DR: This paper proposes a checklist to help beginners choose modeling/simulation formalisms (DEVS, System Dynamics, Agent-Based), validated via pilot studies and expert feedback. The checklist shows promise in aligning with existing solutions and aiding decision-making.


<details>
  <summary>Details</summary>
Motivation: The increasing complexity of systems like digital twins and Industry 4.0 requires modeling and simulation (M&S), but newcomers struggle to choose the appropriate formalism, creating a need for guidance tools.

Method: The authors developed a checklist based on three formalisms (DEVS, System Dynamics, Agent-Based Simulation) and evaluated it through a pilot study, comparing its suggestions to formalisms in original studies and using expert consultation for validation.

Result: The checklist demonstrated (i) alignment with formalisms selected in original studies used for evaluation, and (ii) positive feedback from an expert, validating its preliminary effectiveness.

Conclusion: The paper concludes that the proposed checklist effectively assists beginners in selecting appropriate modeling and simulation formalisms, showing alignment with existing studies and positive expert feedback. Further validation with a larger sample is recommended.

Abstract: The advent of increasingly complex and dynamic ecosystems, such as digital
twins (DT), smart cities and Industry 4.0 and 5.0, has made evident the need to
include modeling and simulation (M&S) in the software development life cycle.
Such disruptive systems include simulation models in their own architecture
(such as DT) or require the use of simulation models to represent the high
degree of movement and the multiplicity of interactions that occur between the
involved systems. However, when software engineers (particularly the newcomers)
need to use M&S in their projects, they often pose themselves an important
question: which formalism should I use? In this direction, the main
contribution of this paper is the establishment of a preliminary checklist with
questions to assist beginners in M&S in choosing the most appropriate paradigm
to solve their problems. The checklist is based on three main formalisms: DEVS,
System Dynamics and Agent-Based Simulation. A pilot study was carried out and
an expert was consulted. The preliminary results show (i) conformance between
the suggestion given by the checklist and the formalism selected in the
original studies used as input for evaluating the checklist, and (ii) a
positive feedback from the expert.

</details>


### [40] [Explainable Fault Localization for Programming Assignments via LLM-Guided Annotation](https://arxiv.org/abs/2509.25676)
*Fang Liu,Tianze Wang,Li Zhang,Zheyu Yang,Jing Jiang,Zian Sun*

Main category: cs.SE

TL;DR: FLAME is a fine-grained, explainable fault localization method for programming assignments using LLM-guided annotation and model ensemble, achieving state-of-the-art performance in both educational and general software contexts.


<details>
  <summary>Details</summary>
Motivation: Existing fault localization techniques lack granularity and explanatory power needed for educational settings, while line-level approaches struggle with LLM compatibility due to direct numerical predictions.

Method: FLAME employs LLMs to annotate faulty lines with contextual explanations instead of predicting line numbers directly. Combines this with a weighted multi-model voting strategy to enhance reliability through multiple LLMs' collective analysis.

Result: Outperforms existing methods by localizing 207 more faults at top-1 in programming assignments, and achieves superior performance on the Defects4J benchmark for general software codebases.

Conclusion: FLAME addresses critical limitations of current fault localization approaches in educational contexts, providing both technical improvement through LLM-annotation and pedagogical value via explanatory feedback, with proven generalization to standard software defects.

Abstract: Providing timely and personalized guidance for students' programming
assignments, offers significant practical value for helping students complete
assignments and enhance their learning. In recent years, various automated
Fault Localization (FL) techniques have demonstrated promising results in
identifying errors in programs. However, existing FL techniques face challenges
when applied to educational contexts. Most approaches operate at the method
level without explanatory feedback, resulting in granularity too coarse for
students who need actionable insights to identify and fix their errors. While
some approaches attempt line-level fault localization, they often depend on
predicting line numbers directly in numerical form, which is ill-suited to
LLMs. To address these challenges, we propose FLAME, a fine-grained,
explainable Fault Localization method tailored for programming assignments via
LLM-guided Annotation and Model Ensemble. FLAME leverages rich contextual
information specific to programming assignments to guide LLMs in identifying
faulty code lines. Instead of directly predicting line numbers, we prompt the
LLM to annotate faulty code lines with detailed explanations, enhancing both
localization accuracy and educational value. To further improve reliability, we
introduce a weighted multi-model voting strategy that aggregates results from
multiple LLMs to determine the suspiciousness of each code line. Extensive
experimental results demonstrate that FLAME outperforms state-of-the-art fault
localization baselines on programming assignments, successfully localizing 207
more faults at top-1 over the best-performing baseline. Beyond educational
contexts, FLAME also generalizes effectively to general-purpose software
codebases, outperforming all baselines on the Defects4J benchmark.

</details>


### [41] [DeepCodeSeek: Real-Time API Retrieval for Context-Aware Code Generation](https://arxiv.org/abs/2509.25716)
*Esakkivel Esakkiraja,Denis Akhiyarov,Aditya Shanmugham,Chitra Ganapathy*

Main category: cs.SE

TL;DR: This paper introduces an efficient API prediction method with a compact reranker that outperforms larger models, enabling high-quality code generation with reduced latency using a novel dataset and training pipeline.


<details>
  <summary>Details</summary>
Motivation: Current search techniques are limited to standard RAG applications, and code-to-code benchmarks suffer from API leaks and unclear intent in API usage.

Method: Developed a novel technique to expand code/index for API prediction, introduced a real-world ServiceNow dataset to address API leaks, and created a post-training pipeline (synthetic dataset generation, supervised fine-tuning, and reinforcement learning) for a compact 0.6B reranker.

Result: Achieved 87.86% top-40 retrieval accuracy; the compact reranker outperformed an 8B model with 2.5x reduced latency.

Conclusion: The proposed method effectively addresses API prediction for code generation with a compact reranker that outperforms larger models while maintaining reduced latency, offering a computationally efficient solution for enterprise-specific code challenges.

Abstract: Current search techniques are limited to standard RAG query-document
applications. In this paper, we propose a novel technique to expand the code
and index for predicting the required APIs, directly enabling high-quality,
end-to-end code generation for auto-completion and agentic AI applications. We
address the problem of API leaks in current code-to-code benchmark datasets by
introducing a new dataset built from real-world ServiceNow Script Includes that
capture the challenge of unclear API usage intent in the code. Our evaluation
metrics show that this method achieves 87.86% top-40 retrieval accuracy,
allowing the critical context with APIs needed for successful downstream code
generation. To enable real-time predictions, we develop a comprehensive
post-training pipeline that optimizes a compact 0.6B reranker through synthetic
dataset generation, supervised fine-tuning, and reinforcement learning. This
approach enables our compact reranker to outperform a much larger 8B model
while maintaining 2.5x reduced latency, effectively addressing the nuances of
enterprise-specific code without the computational overhead of larger models.

</details>


### [42] [Are Classical Clone Detectors Good Enough For the AI Era?](https://arxiv.org/abs/2509.25754)
*Ajmain Inqiad Alam,Palash Roy,Farouq Al-omari,Chanchal Roy,Banani Roy,Kevin Schneider*

Main category: cs.SE

TL;DR: This paper evaluates nine classical code clone detection (CCD) tools on AI-generated clones from GPTCloneBench and human-authored benchmarks, finding that normalization techniques enhance their performance, though results vary compared to traditional setups.


<details>
  <summary>Details</summary>
Motivation: The adoption of AI-generated code introduces new syntactic and semantic clone patterns that challenge classical CCD tools, necessitating an update to their evaluation beyond traditional human-authored code benchmarks.

Method: The study systematically assesses nine leading CCD tools on a GPTCloneBench dataset of GPT-3-generated clones, comparing their performance to established human-authored benchmarks like BigCloneBench and SemanticCloneBench. The evaluation emphasizes detection effectiveness and computational efficiency.

Result: Classical CCD tools maintain considerable effectiveness against AI clones, particularly when using normalization techniques. However, their performance metrics show variability when compared to traditional clone detection benchmarks.

Conclusion: While classical CCD tools remain largely effective for AI-generated clones, normalization enhances accuracy, and scalability analyses guide tool selection. Traditional benchmarks do not fully reflect AI clone challenges, necessitating updated evaluation methods.

Abstract: The increasing adoption of AI-generated code has reshaped modern software
development, introducing syntactic and semantic variations in cloned code.
Unlike traditional human-written clones, AI-generated clones exhibit systematic
syntactic patterns and semantic differences learned from large-scale training
data. This shift presents new challenges for classical code clone detection
(CCD) tools, which have historically been validated primarily on human-authored
codebases and optimized to detect syntactic (Type 1-3) and limited semantic
clones. Given that AI-generated code can produce both syntactic and complex
semantic clones, it is essential to evaluate the effectiveness of classical CCD
tools within this new paradigm. In this paper, we systematically evaluate nine
widely used CCD tools using GPTCloneBench, a benchmark containing
GPT-3-generated clones. To contextualize and validate our results, we further
test these detectors on established human-authored benchmarks, BigCloneBench
and SemanticCloneBench, to measure differences in performance between
traditional and AI-generated clones. Our analysis demonstrates that classical
CCD tools, particularly those enhanced by effective normalization techniques,
retain considerable effectiveness against AI-generated clones, while some
exhibit notable performance variation compared to traditional benchmarks. This
paper contributes by (1) evaluating classical CCD tools against AI-generated
clones, providing critical insights into their current strengths and
limitations; (2) highlighting the role of normalization techniques in improving
detection accuracy; and (3) delivering detailed scalability and execution-time
analyses to support practical CCD tool selection.

</details>


### [43] [LogPilot: Intent-aware and Scalable Alert Diagnosis for Large-scale Online Service Systems](https://arxiv.org/abs/2509.25874)
*Zhihan Jiang,Jinyang Liu,Yichen Li,Haiyu Huang,Xiao He,Tieying Zhang,Jianjun Chen,Yi Li,Rui Shi,Michael R. Lyu*

Main category: cs.SE

TL;DR: LogPilot is an intent-aware, scalable LLM-based...


<details>
  <summary>Details</summary>
Motivation: On-call engineers face challenges...

Method: The framework...

Result: Evaluated on real-world alerts...

Conclusion: LogPilot's efficiency and accuracy...

Abstract: Effective alert diagnosis is essential for ensuring the reliability of
large-scale online service systems. However, on-call engineers are often
burdened with manually inspecting massive volumes of logs to identify root
causes. While various automated tools have been proposed, they struggle in
practice due to alert-agnostic log scoping and the inability to organize
complex data effectively for reasoning. To overcome these limitations, we
introduce LogPilot, an intent-aware and scalable framework powered by Large
Language Models (LLMs) for automated log-based alert diagnosis. LogPilot
introduces an intent-aware approach, interpreting the logic in alert
definitions (e.g., PromQL) to precisely identify causally related logs and
requests. To achieve scalability, it reconstructs each request's execution into
a spatiotemporal log chain, clusters similar chains to identify recurring
execution patterns, and provides representative samples to the LLMs for
diagnosis. This clustering-based approach ensures the input is both rich in
diagnostic detail and compact enough to fit within the LLM's context window.
Evaluated on real-world alerts from Volcano Engine Cloud, LogPilot improves the
usefulness of root cause summarization by 50.34% and exact localization
accuracy by 54.79% over state-of-the-art methods. With a diagnosis time under
one minute and a cost of only $0.074 per alert, LogPilot has been successfully
deployed in production, offering an automated and practical solution for
service alert diagnosis.

</details>


### [44] [Red Teaming Program Repair Agents: When Correct Patches can Hide Vulnerabilities](https://arxiv.org/abs/2509.25894)
*Simin Chen,Yixin He,Suman Jana,Baishakhi Ray*

Main category: cs.SE

TL;DR: This paper shows LLM-based APR agents can be tricked into generating secure but vulnerable code via adversarial GitHub issues, exposing critical flaws in their evaluation paradigm.


<details>
  <summary>Details</summary>
Motivation: Existing APR agents focus on functional correctness but ignore security risks. The study explores whether adversarial GitHub issues can trick agents into generating functionally correct yet vulnerable patches.

Method: SWExploit uses three steps: program analysis to identify injection points, adversarial issue generation (preserving original semantics while misleading), and iterative refinement based on APR agent outputs.

Result: SWExploit achieves an attack success rate of 0.91 on correct patches (vs. baselines below 0.20 across three agent pipelines and five LLMs), showing vulnerability introduction without affecting functional correctness.

Conclusion: The paper challenges the assumption that functionally correct patches from APR agents are inherently secure, demonstrating vulnerabilities via adversarial issues and highlighting flaws in existing evaluation paradigms.

Abstract: LLM-based agents are increasingly deployed for software maintenance tasks
such as automated program repair (APR). APR agents automatically fetch GitHub
issues and use backend LLMs to generate patches that fix the reported bugs.
However, existing work primarily focuses on the functional correctness of
APR-generated patches, whether they pass hidden or regression tests, while
largely ignoring potential security risks. Given the openness of platforms like
GitHub, where any user can raise issues and participate in discussions, an
important question arises: Can an adversarial user submit a valid issue on
GitHub that misleads an LLM-based agent into generating a functionally correct
but vulnerable patch? To answer this question, we propose SWExploit, which
generates adversarial issue statements designed to make APR agents produce
patches that are functionally correct yet vulnerable. SWExploit operates in
three main steps: (1) program analysis to identify potential injection points
for vulnerable payloads; (2) adversarial issue generation to provide misleading
reproduction and error information while preserving the original issue
semantics; and (3) iterative refinement of the adversarial issue statements
based on the outputs of the APR agents. Empirical evaluation on three agent
pipelines and five backend LLMs shows that SWExploit can produce patches that
are both functionally correct and vulnerable (the attack success rate on the
correct patch could reach 0.91, whereas the baseline ASRs are all below 0.20).
Based on our evaluation, we are the first to challenge the traditional
assumption that a patch passing all tests is inherently reliable and secure,
highlighting critical limitations in the current evaluation paradigm for APR
agents.

</details>


### [45] [R-Log: Incentivizing Log Analysis Capability in LLMs via Reasoning-based Reinforcement Learning](https://arxiv.org/abs/2509.25987)
*Yilun Liu,Ziang Chen,Song Xu,Minggui He,Shimin Tao,Weibin Meng,Yuming Xie,Tao Han,Chunguang Zhao,Jingzhou Du,Daimeng Wei,Shenglin Zhang,Yongqian Sun*

Main category: cs.SE

TL;DR: R-Log uses human-like reasoning and RL to improve LLM log analysis, outperforming SFT methods with better generalization and reduced hallucinations.


<details>
  <summary>Details</summary>
Motivation: Current SFT methods for log analysis fail due to domain gaps causing overfitting, imbalanced loss computation that prioritizes lengthy contexts over critical details, and resulting hallucinations in model outputs.

Method: The paper proposes R-Log, a reasoning-based paradigm that pre-trains on 2k+ expert reasoning trajectories guided by 13 O&M strategies, followed by RL refinement in a simulated environment with joint reward functions.

Result: R-Log achieves 228.05% improvement in unseen scenarios over existing methods and introduces R-Log-fast with 5x acceleration while retaining 93% of effectiveness, validated across five real-world log analysis tasks.

Conclusion: R-Log effectively addresses domain discrepancy and hallucination issues in log analysis using LLMs through reasoning-based learning and RL optimization, achieving significant performance improvements.

Abstract: The growing complexity of log data in modern software systems has prompted
the use of Large Language Models (LLMs) for automated log analysis. Current
approaches typically rely on direct supervised fine-tuning (SFT) on log-label
pairs. However, this exacerbates the domain discrepancy between general-purpose
LLMs and specialized log data, causing overfitting. Furthermore, SFT's
imbalanced loss computation often allows lengthy contexts to overwhelm
critical, concise details in model answers, leading to hallucinations. To
address these limitations, we propose R-Log, a novel reasoning-based paradigm
that mirrors the structured, step-by-step analytical process of human
engineers. This approach enhances generalizability by learning the underlying
rules behind conclusions. We further employ Reinforcement Learning (RL) to
optimize the model within a simulated O&M environment, thereby reducing
hallucinations by directly rewarding correct outcomes. R-Log is first
cold-started on a curated dataset of 2k+ reasoning trajectories, guided by 13
strategies from manual O&M practices, to establish an initial reasoning
capability. This ability is then refined via RL using a joint reward function.
Empirical evaluations on real-world logs show that R-Log outperforms existing
methods across five log analysis tasks, particularly in unseen scenarios (by
228.05%). We also designed R-Log-fast with 5x speedup while keeping 93% of the
efficacy.

</details>


### [46] [Using GPT to build a Project Management assistant for Jira environments](https://arxiv.org/abs/2509.26014)
*Joel Garcia-Escribano,Arkaitz Carbajo,Mikel Egaña Aranguren,Unai Lopez-Novoa*

Main category: cs.SE

TL;DR: JiraGPT Next, a natural language interface for Jira, is presented to help project managers access data efficiently, avoiding complex programming.


<details>
  <summary>Details</summary>
Motivation: Managing large data volumes in project management tools is challenging; many tools require complex programming which could be complicated for project managers.

Method: Design of JiraGPT Next as a Jira add-on utilizing the GPT Large Language Model for natural language data retrieval and evaluation of GPT's accuracy with various prompts.

Result: The software was designed and tested, demonstrating potential for efficient data handling in project management through natural language interaction.

Conclusion: JiraGPT Next offers a solution to simplify data management in Jira, enhancing accessibility and efficiency for project managers through GPT-based natural language interface.

Abstract: In the domain of Project Management, the sheer volume of data is a challenge
that project managers continually have to deal with. Effectively steering
projects from inception to completion requires handling of diverse information
streams, including timelines, budgetary considerations, and task dependencies.
To navigate this data-driven landscape with precision and agility, project
managers must rely on efficient and sophisticated tools. These tools have
become essential, as they enable project managers to streamline communication,
optimize resource allocation, and make informed decisions in real-time.
However, many of these tools have steep learning curves and require using
complex programming languages to retrieve the exact data that project managers
need. In this work we present JiraGPT Next, a software that uses the GPT Large
Language Model to ease the process by which project managers deal with large
amounts of data. It is conceived as an add-on for Jira, one of the most popular
Project Management tools, and provides a natural language interface to retrieve
information. This work presents the design decisions behind JiraGPT Next and an
evaluation of the accuracy of GPT in this context, including the effects of
providing different prompts to complete a particular task.

</details>


### [47] [Evaluating the impact of code smell refactoring on the energy consumption of Android applications](https://arxiv.org/abs/2509.26031)
*Hina Anwar,Dietmar Pfahl,Satish N. Srirama*

Main category: cs.SE

TL;DR: Refactoring code smells in Android apps can reduce energy use by up to 10.8%, but the relationship between energy savings, execution time, and refactoring order is complex and merits further study.


<details>
  <summary>Details</summary>
Motivation: Mobile app energy efficiency is critical for device performance. Code refactorings offer a potential method to improve energy consumption by addressing code smells like duplication and type checking.

Method: The study experimentally analyzed the energy impact of various code refactorings (e.g., 'Duplicated code', 'Type checking') on Android apps, testing permutations of refactorings and correlating results with execution time and code smells.

Result: Refactorings reduced energy consumption by up to 10.8%, though energy savings were not strictly tied to changes in execution time. Refactoring order also influenced energy impact, with some permutations increasing consumption.

Conclusion: The paper concludes that code refactoring can significantly reduce energy consumption in Android apps by up to 10.8%, but further research is needed to understand correlations between app development factors and refactoring outcomes.

Abstract: Energy consumption of mobile apps is a domain that is receiving a lot of
attention from researchers. Recent studies indicate that the energy consumption
of mobile devices could be improved by improving the quality of mobile apps.
Frequent refactoring is one way of achieving this goal. In this paper, we
explore the performance and energy impact of several common code refactorings
in Android apps. Experimental results indicate that some code smell
refactorings positively impact the energy consumption of Android apps.
Refactoring of the code smells "Duplicated code" and "Type checking" reduce
energy consumption by up to 10.8%. Significant reduction in energy consumption,
however, does not seem to be directly related to the increase or decrease of
execution time. In addition, the energy impact over permutations of code smell
refactorings in the selected Android apps was small. When analyzing the order
in which refactorings were made across code smell types, it turned out that
some permutations resulted in a reduction and some in an increase of energy
consumption for the analyzed apps. More research needs to be done to
investigate how factors like size and age of software apps, experience, and
number of contributors to app development correlate with (a) the number and
type of code smells found and (b) the impact of energy consumption and
performance after refactoring.

</details>


### [48] [Agent-based code generation for the Gammapy framework](https://arxiv.org/abs/2509.26110)
*Dmitriy Kostunin,Vladimir Sotnikov,Sergo Golovachev,Abhay Mehta,Tim Lukas Holch,Elisa Jones*

Main category: cs.SE

TL;DR: This paper addresses the challenges of applying Large Language Models (LLMs), such as code generation, to specialized scientific libraries due to limited documentation and unstable APIs. The researchers developed an agent to autonomously write, execute, and validate code for the Gammapy library, providing a web demo and benchmarking suite to demonstrate their approach.


<details>
  <summary>Details</summary>
Motivation: Modern LLMs excel at code generation for well-documented frameworks but struggle with scientific libraries that lack documentation, community resources, and have unstable APIs. This hampers their utility in scientific domains requiring specialized tools.

Method: The authors developed an agent trained to write, execute, and validate code within a controlled environment tailored to the Gammapy library. This system enables iterative testing and validation of generated code to address unstable APIs and limited documentation.

Result: A minimal web demo and benchmarking suite were created to showcase the agent's capabilities. The approach demonstrates effectiveness in handling scientific library challenges, though ongoing development is noted.

Conclusion: The work highlights a successful adaptation of LLM-powered agents for scientific domains, addressing gaps in documentation and API stability. Future work includes expanding the benchmarking suite and improving agent robustness.

Abstract: Software code generation using Large Language Models (LLMs) is one of the
most successful applications of modern artificial intelligence. Foundational
models are very effective for popular frameworks that benefit from
documentation, examples, and strong community support. In contrast, specialized
scientific libraries often lack these resources and may expose unstable APIs
under active development, making it difficult for models trained on limited or
outdated data. We address these issues for the Gammapy library by developing an
agent capable of writing, executing, and validating code in a controlled
environment. We present a minimal web demo and an accompanying benchmarking
suite. This contribution summarizes the design, reports our current status, and
outlines next steps.

</details>


### [49] [A Multi-Language Object-Oriented Programming Benchmark for Large Language Models](https://arxiv.org/abs/2509.26111)
*Shuai Wang,Liang Ding,Li Shen,Yong Luo,Han Hu,Lefei Zhang,Fu Lin*

Main category: cs.SE

TL;DR: The paper introduces MultiOOP, a multi-language OOP benchmark for evaluating code generation models, revealing substantial performance drops across tasks and languages compared to existing benchmarks.


<details>
  <summary>Details</summary>
Motivation: Existing benchmarks for evaluating LLM code generation are imbalanced, focusing narrowly on single languages (85.7%), low-level tasks (94.3%), and small test sets (80% with fewer than 10 cases), limiting robust evaluation.

Method: Proposed MultiOOP covering 6 languages (Python, PHP, C++, C#, Java, JS) with 267 tasks per language, designed a multilingual translator and pass@o metric extension, and developed an automated framework for test case augmentation.

Result: 1) Performance degradation of up to 65.6 pp in pass@1 scores compared to function-level benchmarks. 2) GPT-4o mini's cross-language variability (48.06% in Python vs. 0.12%-15.26% in others). 3) Conceptual gaps with pass@o scores 1.1-19.2 points lower than pass@k, indicating incomplete OOP concept understanding.

Conclusion: MultiOOP provides a comprehensive benchmark for OOP evaluation across multiple languages. The authors plan to release datasets, metrics, and evaluation tools at specified repositories to foster fair, multilingual LLM code generation assessment.

Abstract: Establishing fair and robust benchmarks is essential for evaluating
intelligent code generation by large language models (LLMs). Our survey of 35
existing benchmarks uncovers three major imbalances: 85.7% focus on a single
programming language; 94.3% target only function-level or statement-level
tasks; and over 80% include fewer than ten test cases on average. To address
these gaps, we propose MultiOOP, a multi-language object-oriented programming
benchmark covering six popular languages (Python, PHP, C++, C#, Java,
JavaScript) with 267 tasks per language. We design a translator that extends an
existing single-language OOP benchmark and the pass@o metric to a multilingual
setting. Moreover, we propose an automated framework for augmenting test cases
to ensure the reliability of the evaluation results. We evaluate 14 mainstream
LLMs under zero-shot prompting and report three key findings: 1) Substantial
performance degradation: pass@1 scores on MultiOOP drop by up to 65.6
percentage points compared to function-level tasks (e.g., HumanEval). 2)
Cross-language variability: GPT-4o mini achieves pass@1 of 48.06% in Python but
only 0.12%-15.26% in other languages, indicating limited multilingual
generalization. 3) Conceptual gaps: pass@o scores are consistently 1.1-19.2
points lower than pass@k, demonstrating that LLMs often generate executable
code without fully capturing core OOP concepts. Our benchmark, metric
extensions, and evaluation scripts will be publicly released to foster a more
balanced and comprehensive assessment of LLMs in object-oriented code
generation. Our code and data will be released at
https://github.com/alphadl/OOP-eval and
https://huggingface.co/datasets/codeai-dteam/MultiOOP respectively.

</details>


### [50] [Understanding Collective Social Behavior in OSS Communities: A Co-editing Network Analysis of Activity Cascades](https://arxiv.org/abs/2509.26173)
*Lisi Qarkaxhija,Maximilian Carparo,Stefan Menzel,Bernhard Sendhoff,Ingo Scholtes*

Main category: cs.SE

TL;DR: This paper investigates the bursty activity patterns in open-source software (OSS), showing that developer interactions in co-editing networks generate activity cascades, which help predict developer churn and explain community dynamics.


<details>
  <summary>Details</summary>
Motivation: Understanding how developers interact is critical for modeling the sustainability of OSS communities. The bursty nature of commit activity raises the need to uncover its social mechanisms.

Method: A network-based framework uses co-editing interactions to model cascading activity. Over 50 OSS communities are analyzed to identify cascades and develop a churn prediction method.

Result: Activity cascades are statistically significant in over half the projects. The proposed method predicts developer churn with practical effectiveness.

Conclusion: Activity cascades are key to understanding developer retention and churn in OSS. Modeling social interactions through co-editing networks provides actionable insights for community sustainability.

Abstract: Understanding the collective social behavior of software developers is
crucial to model and predict the long-term dynamics and sustainability of Open
Source Software (OSS) communities. To this end, we analyze temporal activity
patterns of developers, revealing an inherently ``bursty'' nature of commit
contributions. To investigate the social mechanisms behind this phenomenon, we
adopt a network-based modelling framework that captures developer interactions
through co-editing networks. Our framework models social interactions, where a
developer editing the code of other developers triggers accelerated activity
among collaborators. Using a large data set on 50 major OSS communities, we
further develop a method that identifies activity cascades, i.e. the
propagation of developer activity in the underlying co-editing network. Our
results suggest that activity cascades are a statistically significant
phenomenon in more than half of the studied projects. We further show that our
insights can be used to develop a simple yet practical churn prediction method
that forecasts which developers are likely to leave a project. Our work sheds
light on the emergent collective social dynamics in OSS communities and
highlights the importance of activity cascades to understand developer churn
and retention in collaborative software projects.

</details>


### [51] [Hamster: A Large-Scale Study and Characterization of Developer-Written Tests](https://arxiv.org/abs/2509.26204)
*Rangeet Pan,Tyler Stennett,Raju Pavuluri,Nate Levin,Alessandro Orso,Saurabh Sinha*

Main category: cs.SE

TL;DR: This paper bridges the gap between developer-written tests and Automated Test Generation (ATG). Using 1.7 million Java tests, it compares ATG tools to real-world developer practices, revealing that current ATG tools struggle to replicate key test characteristics. It proposes research directions to improve tool capabilities.


<details>
  <summary>Details</summary>
Motivation: Prior ATG research lacks understanding of developer test characteristics, hampering assessment of tool effectiveness. This study addresses this gap to improve alignment between ATG tools and developer needs.

Method: An empirical analysis of 1.7M open-source Java test cases, focusing on test scope, fixtures, inputs, and mocking. Existing tests are compared to those generated by two state-of-the-art ATG tools.

Result: Most developer-written tests exhibit characteristics (e.g., complex fixtures, input handling, mocking) that current ATG tools cannot replicate effectively, highlighting a significant gap in tool capabilities.

Conclusion: The study identifies actionable research directions to enable ATG tools to better match developer testing practices, advocating for advances that align tool outputs with real-world test creation patterns.

Abstract: Automated test generation (ATG), which aims to reduce the cost of manual test
suite development, has been investigated for decades and has produced countless
techniques based on a variety of approaches: symbolic analysis, search-based,
random and adaptive-random, learning-based, and, most recently,
large-language-model-based approaches. However, despite this large body of
research, there is still a gap in our understanding of the characteristics of
developer-written tests and, consequently, in our assessment of how well ATG
techniques and tools can generate realistic and representative tests. To bridge
this gap, we conducted an extensive empirical study of developer-written tests
for Java applications, covering 1.7 million test cases from open-source
repositories. Our study is the first of its kind in studying aspects of
developer-written tests that are mostly neglected in the existing literature,
such as test scope, test fixtures and assertions, types of inputs, and use of
mocking. Based on the characterization, we then compare existing tests with
those generated by two state-of-the-art ATG tools. Our results highlight that a
vast majority of developer-written tests exhibit characteristics that are
beyond the capabilities of current ATG tools. Finally, based on the insights
gained from the study, we identify promising research directions that can help
bridge the gap between current tool capabilities and more effective tool
support for developer testing practices. We hope that this work can set the
stage for new advances in the field and bring ATG tools closer to generating
the types of tests developers write.

</details>


### [52] [UniSage: A Unified and Post-Analysis-Aware Sampling for Microservices](https://arxiv.org/abs/2509.26336)
*Zhouruixing Zhu,Zhihan Jiang,Tianyi Yang,Pinjia He*

Main category: cs.SE

TL;DR: UniSage enables accurate failure diagnosis while reducing storage requirements using post-analysis-aware trace/log sampling in distributed systems.


<details>
  <summary>Details</summary>
Motivation: Modern distributed systems generate massive volume of traces/logs for observability, but traditional sample-before-analysis approaches inevitably discard failure-related data, reducing diagnostic transparency and system behavior visibility. This information loss hinders effective fault diagnosis.

Method: Introduces UniSage, a unified framework that first performs lightweight multi-modal anomaly detection and root cause analysis (RCA) on the full telemetry data stream. It then applies a dual-pillar sampling strategy: analysis-guided (prioritizes data implicated by RCA) and edge-case-based (captures rare critical behaviors). This post-analysis approach preserves failure-related information discarded by pre-sampling methods.

Result: At 2.5% sampling rate, captures 56.5% of critical traces and 96.25% of relevant logs, achieving 42.45% improvement in root cause analysis accuracy over state-of-the-art. Processes 10m of telemetry data in <5s, demonstrating practical deployment feasibility.

Conclusion: UniSage addresses the limitations of traditional pre-sampling methods by using post-analysis-aware sampling, achieving comprehensive coverage of critical failure signals at ultra-low sampling rates while maintaining high diagnostic accuracy and efficiency for production systems.

Abstract: Traces and logs are essential for observability and fault diagnosis in modern
distributed systems. However, their ever-growing volume introduces substantial
storage overhead and complicates troubleshooting. Existing approaches typically
adopt a sample-before-analysis paradigm: even when guided by data heuristics,
they inevitably discard failure-related information and hinder transparency in
diagnosing system behavior. To address this, we introduce UniSage, the first
unified framework to sample both traces and logs using a post-analysis-aware
paradigm. Instead of discarding data upfront, UniSagefirst performs lightweight
and multi-modal anomaly detection and root cause analysis (RCA) on the complete
data stream. This process yields fine-grained, service-level diagnostic
insights that guide a dual-pillar sampling strategy for handling both normal
and anomalous scenarios: an analysis-guided sampler prioritizes data implicated
by RCA, while an edge-case-based sampler ensures rare but critical behaviors
are captured. Together, these pillars ensure comprehensive coverage of critical
signals without excessive redundancy. Extensive experiments demonstrate that
UniSage significantly outperforms state-of-the-art baselines. At a 2.5%
sampling rate, it captures 56.5% of critical traces and 96.25% of relevant
logs, while improving the accuracy (AC@1) of downstream root cause analysis by
42.45%. Furthermore, its efficient pipeline processes 10 minutes of telemetry
data in under 5 seconds, demonstrating its practicality for production
environments.

</details>


### [53] [Institutional Policy Pathways for Supporting Research Software: Global Trends and Local Practices](https://arxiv.org/abs/2509.26422)
*Michelle Barker,Jeremy Cohen,Pedro Hernández Serrano,Daniel S. Katz,Kim Martin,Dan Rudmann,Hugh Shanahan*

Main category: cs.SE

TL;DR: The paper addresses the lack of institutional policies for research software sustainability, reviewing challenges in current ad hoc management approaches and proposing systemic reforms via the PRO4RS Working Group's global policy analysis.


<details>
  <summary>Details</summary>
Motivation: Research software is critical to modern science but faces institutional neglect in training, recognition, and sustainability. Existing policies fail to address technical role support, research assessment reforms, and alignment with FAIR/open science principles.

Method: The PRO4RS Working Group (ReSA-RDA collaboration, 2020-2023+) conducted global research software policy analysis, identifying gaps through stakeholder engagement and institutional case studies focused on research assessment reforms.

Result: Identified critical policy gaps: (1缺少针对研究软件人员的职业发展路径; (2缺乏将软件贡献纳入学术评估体系; (3未将FAIR原则充分整合到软件管理中; (4机构层面缺乏技术基础设施长期支持机制.

Conclusion: Institutions must adopt systemic policies to sustain research software ecosystems. PRO4RS demonstrates that structured policy development is essential for competitive research institutions to maintain technical excellence, attract funding, and uphold scientific rigor in the digital age.

Abstract: As research software becomes increasingly central to modern science,
research-performing organisations (RPOs) need to ensure that their investment
in people, skills and infrastructure around research software produces
sustainable and maintainable software that improves the research they perform,
which in turn improves the overall institution and its reputation and funding,
for example, by competing with peers who lack this approach. However, research
institution management and recognition of research software and its personnel
has mostly often developed in an ad hoc manner. RPO training infrastructures,
recognition and reward structures, have not developed at a sufficient rate to
support and encourage both the widespread use of research software best
practices and the long-term support for technical roles that is required. To
begin to address this fundamental problem for modern research environments,
RPOs must implement and adopt robust policies to support research software
development, use, and sustainability. Despite growing momentum from funders and
publishers around FAIR and open science principles, research
institutional-level policies specifically addressing research software remain
limited or lacking in breadth.
  This article outlines the work of the Policies in Research Organisations for
Research Software (PRO4RS) Working Group (WG), a joint initiative of the
Research Software Alliance (ReSA) and the Research Data Alliance (RDA), which
examined and advanced research software policy development across institutions
worldwide. After consideration of the rationale for institutional policies on
research software, the PRO4RS WG outputs and analysis are utilised to highlight
critical policy gaps, particularly related to consideration of research
software personnel in policy work focused on reform of research assessment.

</details>


### [54] [EQ-Robin: Generating Multiple Minimal Unique-Cause MC/DC Test Suites](https://arxiv.org/abs/2509.26458)
*Robin Lee,Youngho Nam*

Main category: cs.SE

TL;DR: EQ-Robin enhances test suite reliability for MC/DC by generating multiple minimal SBE variants, overcoming risks in deterministic single-solution approaches.


<details>
  <summary>Details</summary>
Motivation: Existing Robin's Rule produces only one test suite, risking 100% MC/DC coverage failure if any test case is invalid based on system constraints. This hinders verification in safety-critical domains.

Method: The approach generates semantically equivalent Singular Boolean Expressions (SBEs) via algebraic AST-based rearrangements, then applies Robin's Rule to each variant to create multiple test suite options while preserving N+1 minimality.

Result: EQ-Robin's evaluation plan on TCAS-II-derived SBEs demonstrates its ability to produce minimal valid test suites through structural expression diversity, ensuring resilience to constraint violations.

Conclusion: EQ-Robin provides a systematic method for generating diverse minimal test suites, ensuring robust Unique-Cause MC/DC coverage for safety-critical software despite system constraints.

Abstract: Modified Condition/Decision Coverage (MC/DC), particularly its strict
Unique-Cause form, is a cornerstone of safety-critical software verification. A
recent algorithm, "Robin's Rule," introduced a deterministic method to
construct the theoretical minimum of N+1 test cases for Singular Boolean
Expressions (SBEs). However, this approach yields only a single test suite,
introducing a critical risk: if a test case forming a required 'independence
pair' is an illegal input forbidden by system constraints, the suite fails to
achieve 100% coverage. This paper proposes EQ-Robin, a lightweight pipeline
that systematically generates a family of minimal Unique-Cause MC/DC suites to
mitigate this risk. We introduce a method for systematically generating
semantically equivalent SBEs by applying algebraic rearrangements to an
Abstract Syntax Tree (AST) representation of the expression. By applying
Robin's Rule to each structural variant, a diverse set of test suites can be
produced. This provides a resilient path to discovering a valid test suite that
preserves the N+1 minimality guarantee while navigating real-world constraints.
We outline an evaluation plan on TCAS-II-derived SBEs to demonstrate how
EQ-Robin offers a practical solution for ensuring robust MC/DC coverage.

</details>


### [55] [ErrorPrism: Reconstructing Error Propagation Paths in Cloud Service Systems](https://arxiv.org/abs/2509.26463)
*Junsong Pu,Yichen Li,Zhuangbin Chen,Jinyang Liu,Zhihan Jiang,Jianjun Chen,Rui Shi,Zibin Zheng,Tieying Zhang*

Main category: cs.SE

TL;DR: ErrorPrism is introduced to address the traceability problem of error propagation in microservice systems. It combines static code analysis and an LLM agent for accurate path reconstruction with high accuracy in real-world errors.


<details>
  <summary>Details</summary>
Motivation: Failure cascading in cloud systems hinders reliability management, and existing methods struggle with reconstructing error propagation paths from logs.

Method: ErrorPrism first uses static analysis to build a function call graph and map logs to functions; then, an LLM agent performs backward search based on the initial mapping and error signals for multi-hop error path reconstruction.

Result: ByteDance's evaluation on 67 microservices for 102 real errors achieved 97.0% accuracy, outperforming static and LLM-based methods.

Conclusion: ErrorPrism effectively automates root cause analysis for industrial microservice systems by reducing search space and accurate path reconstruction.

Abstract: Reliability management in cloud service systems is challenging due to the
cascading effect of failures. Error wrapping, a practice prevalent in modern
microservice development, enriches errors with context at each layer of the
function call stack, constructing an error chain that describes a failure from
its technical origin to its business impact. However, this also presents a
significant traceability problem when recovering the complete error propagation
path from the final log message back to its source. Existing approaches are
ineffective at addressing this problem. To fill this gap, we present ErrorPrism
in this work for automated reconstruction of error propagation paths in
production microservice systems. ErrorPrism first performs static analysis on
service code repositories to build a function call graph and map log strings to
relevant candidate functions. This significantly reduces the path search space
for subsequent analysis. Then, ErrorPrism employs an LLM agent to perform an
iterative backward search to accurately reconstruct the complete, multi-hop
error path. Evaluated on 67 production microservices at ByteDance, ErrorPrism
achieves 97.0% accuracy in reconstructing paths for 102 real-world errors,
outperforming existing static analysis and LLM-based approaches. ErrorPrism
provides an effective and practical tool for root cause analysis in industrial
microservice systems.

</details>


### [56] [Towards Verified Code Reasoning by LLMs](https://arxiv.org/abs/2509.26546)
*Meghana Sistla,Gogul Balakrishnan,Pat Rondon,José Cambronero,Michele Tufano,Satish Chandra*

Main category: cs.SE

TL;DR: Error


<details>
  <summary>Details</summary>
Motivation: Error

Method: Error

Result: Error

Conclusion: Error

Abstract: While LLM-based agents are able to tackle a wide variety of code reasoning
questions, the answers are not always correct. This prevents the agent from
being useful in situations where high precision is desired: (1) helping a
software engineer understand a new code base, (2) helping a software engineer
during code review sessions, and (3) ensuring that the code generated by an
automated code generation system meets certain requirements (e.g. fixes a bug,
improves readability, implements a feature).
  As a result of this lack of trustworthiness, the agent's answers need to be
manually verified before they can be trusted. Manually confirming responses
from a code reasoning agent requires human effort and can result in slower
developer productivity, which weakens the assistance benefits of the agent. In
this paper, we describe a method to automatically validate the answers provided
by a code reasoning agent by verifying its reasoning steps. At a very high
level, the method consists of extracting a formal representation of the agent's
response and, subsequently, using formal verification and program analysis
tools to verify the agent's reasoning steps.
  We applied this approach to a benchmark set of 20 uninitialized variable
errors detected by sanitizers and 20 program equivalence queries. For the
uninitialized variable errors, the formal verification step was able to
validate the agent's reasoning on 13/20 examples, and for the program
equivalence queries, the formal verification step successfully caught 6/8
incorrect judgments made by the agent.

</details>


### [57] [Black-box Context-free Grammar Inference for Readable & Natural Grammars](https://arxiv.org/abs/2509.26616)
*Mohammad Rifat Arefin,Shanto Rahman,Christoph Csallner*

Main category: cs.SE

TL;DR: NatGI: An LLM-guided context-free grammar inference framework for improving scalability, readability, and accuracy.


<details>
  <summary>Details</summary>
Motivation: existing tools struggle with scalability, readability, and accuracy on large, complex languages

Method: extend TreeVada with bracket-guided bubble exploration, LLM-driven bubble generation and non-terminal labeling, and HDD for simplification

Result: NatGI consistently outperforms baselines. F1 score average of 0.57, 25pp higher than TreeVada, and better interpretability

Conclusion: NatGI improves accuracy and interpretability, benefiting developers and researchers in program analysis and security.

Abstract: Black-box context-free grammar inference is crucial for program analysis,
reverse engineering, and security, yet existing tools such as Arvada, TreeVada,
and Kedavra struggle with scalability, readability, and accuracy on large,
complex languages. We present NatGI, a novel LLM-guided grammar inference
framework that extends TreeVada's parse tree recovery with three key
innovations: bracket-guided bubble exploration, LLM-driven bubble generation
and non-terminal labeling, and hierarchical delta debugging (HDD) for
systematic tree simplification. Bracket-guided exploration leverages syntactic
cues such as parentheses to propose well-structured grammar fragments, while
LLM guidance produces meaningful non-terminal names and selects more promising
merges. Finally, HDD incrementally reduces unnecessary rules, which makes the
grammars both compact and interpretable. In our experiments, we evaluate NatGI
on a comprehensive benchmark suite ranging from small languages to larger ones
such as lua, c, and mysql. Our results show that NatGI consistently outperforms
strong baselines in terms of F1 score. On average, NatGI achieves an F1 score
of 0.57, which is 25pp (percentage points) higher than the best-performing
baseline, TreeVada. In the case of interpretability, our generated grammars
perform significantly better than those produced by existing approaches.
Leveraging LLM-based node renaming and bubble exploration, NatGI produces rules
with meaningful non-terminal names and compact structures that align more
closely with human intuition. As a result, developers and researchers can
achieve higher accuracy while still being able to easily inspect, verify, and
reason about the structure and semantics of the induced grammars.

</details>
