{"id": "2510.08576", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.HC"], "pdf": "https://arxiv.org/pdf/2510.08576", "abs": "https://arxiv.org/abs/2510.08576", "authors": ["Justus Flerlage", "Alexander Acker", "Odej Kao"], "title": "Comparative Analysis of Large Language Models for the Machine-Assisted Resolution of User Intentions", "comment": null, "summary": "Large Language Models (LLMs) have emerged as transformative tools for natural\nlanguage understanding and user intent resolution, enabling tasks such as\ntranslation, summarization, and, increasingly, the orchestration of complex\nworkflows. This development signifies a paradigm shift from conventional,\nGUI-driven user interfaces toward intuitive, language-first interaction\nparadigms. Rather than manually navigating applications, users can articulate\ntheir objectives in natural language, enabling LLMs to orchestrate actions\nacross multiple applications in a dynamic and contextual manner. However,\nextant implementations frequently rely on cloud-based proprietary models, which\nintroduce limitations in terms of privacy, autonomy, and scalability. For\nlanguage-first interaction to become a truly robust and trusted interface\nparadigm, local deployment is not merely a convenience; it is an imperative.\nThis limitation underscores the importance of evaluating the feasibility of\nlocally deployable, open-source, and open-access LLMs as foundational\ncomponents for future intent-based operating systems. In this study, we examine\nthe capabilities of several open-source and open-access models in facilitating\nuser intention resolution through machine assistance. A comparative analysis is\nconducted against OpenAI's proprietary GPT-4-based systems to assess\nperformance in generating workflows for various user intentions. The present\nstudy offers empirical insights into the practical viability, performance\ntrade-offs, and potential of open LLMs as autonomous, locally operable\ncomponents in next-generation operating systems. The results of this study\ninform the broader discussion on the decentralization and democratization of AI\ninfrastructure and point toward a future where user-device interaction becomes\nmore seamless, adaptive, and privacy-conscious through locally embedded\nintelligence.", "AI": {"tldr": "This study evaluates open-source LLMs for local deployment to enable privacy-preserving, intent-based operating systems, comparing their viability with proprietary GPT-4 systems.", "motivation": "Cloud-based proprietary LLMs lack privacy/autonomy, necessitating open alternatives for decentralized, user-centric interfaces.", "method": "Comparative analysis of open-source LLMs against GPT-4 in workflow generation tasks for user intention resolution.", "result": "Empirical insights into open LLMs' practical viability/limitations as local components for next-gen OS design.", "conclusion": "Open LLMs enable decentralized AI infrastructure with privacy-first, adaptive device interaction - a critical step toward democratizing intelligent systems."}}
{"id": "2510.08609", "categories": ["cs.SE", "cs.CR", "cs.LG", "cs.PL"], "pdf": "https://arxiv.org/pdf/2510.08609", "abs": "https://arxiv.org/abs/2510.08609", "authors": ["Imranur Rahman", "Jill Marley", "William Enck", "Laurie Williams"], "title": "Which Is Better For Reducing Outdated and Vulnerable Dependencies: Pinning or Floating?", "comment": "Accepted to ASE 2025", "summary": "Developers consistently use version constraints to specify acceptable\nversions of the dependencies for their project. \\emph{Pinning} dependencies can\nreduce the likelihood of breaking changes, but comes with a cost of manually\nmanaging the replacement of outdated and vulnerable dependencies. On the other\nhand, \\emph{floating} can be used to automatically get bug fixes and security\nfixes, but comes with the risk of breaking changes. Security practitioners\nadvocate \\emph{pinning} dependencies to prevent against software supply chain\nattacks, e.g., malicious package updates. However, since \\emph{pinning} is the\ntightest version constraint, \\emph{pinning} is the most likely to result in\noutdated dependencies. Nevertheless, how the likelihood of becoming outdated or\nvulnerable dependencies changes across version constraint types is unknown. The\ngoal of this study is to aid developers in making an informed dependency\nversion constraint choice by empirically evaluating the likelihood of\ndependencies becoming outdated or vulnerable across version constraint types at\nscale. In this study, we first identify the trends in dependency version\nconstraint usage and the patterns of version constraint type changes made by\ndevelopers in the npm, PyPI, and Cargo ecosystems. We then modeled the\ndependency state transitions using survival analysis and estimated how the\nlikelihood of becoming outdated or vulnerable changes when using \\emph{pinning}\nas opposed to the rest of the version constraint types. We observe that among\noutdated and vulnerable dependencies, the most commonly used version constraint\ntype is \\emph{floating-minor}, with \\emph{pinning} being the next most common.\nWe also find that \\emph{floating-major} is the least likely to result in\noutdated and \\emph{floating-minor} is the least likely to result in vulnerable\ndependencies.", "AI": {"tldr": "This study empirically evaluates how different dependency version constraint types (pinning vs. floating) impact the likelihood of dependencies becoming outdated or vulnerable in npm, PyPI, and Cargo ecosystems using survival analysis.", "motivation": "Developers face a trade-off between using strict version constraints (pinning) for security stability and looser constraints (floating) for automatic updates. Security practitioners advocate pinning to prevent supply chain attacks, but it risks outdated dependencies. Empirical data is needed to guide developers in making informed version constraint choices.", "method": "1) Analyzed trends in version constraint usage and developer behavior changes across constraints in three package ecosystems (npm, PyPI, Cargo). 2) Modeled dependency state transitions using survival analysis to quantify how constraint types affect the likelihood of becoming outdated or vulnerable.", "result": "Key finding: floating-minor is most commonly used (88%) among outdated/vulnerable dependencies but least likely to result in vulnerabilities. Floating-major is least likely to result in outdated dependencies. Pinning is the second most common constraint type after floating-minor but more likely to result in outdated dependencies than floating-major.", "conclusion": "The study provides empirical guidance for developers: floating-major should be preferred to minimize outdated issues while avoiding vulnerabilities. Floating-minor balances between security and update risks. Pinning remains valuable for security-sensitive contexts but should be combined with automated update tools to mitigate staleness."}}
{"id": "2510.08610", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.08610", "abs": "https://arxiv.org/abs/2510.08610", "authors": ["Imranur Rahman", "Md Rayhanur Rahman"], "title": "Relative Positioning Based Code Chunking Method For Rich Context Retrieval In Repository Level Code Completion Task With Code Language Model", "comment": "Accepted to Context Collection Workshop co-located with ASE 2025", "summary": "Code completion can help developers improve efficiency and ease the\ndevelopment lifecycle. Although code completion is available in modern\nintegrated development environments (IDEs), research lacks in determining what\nmakes a good context for code completion based on the information available to\nthe IDEs for the large language models (LLMs) to perform better. In this paper,\nwe describe an effective context collection strategy to assist the LLMs in\nperforming better at code completion tasks. The key idea of our strategy is to\npreprocess the repository into smaller code chunks and later use syntactic and\nsemantic similarity-based code chunk retrieval with relative positioning. We\nfound that code chunking and relative positioning of the chunks in the final\ncontext improve the performance of code completion tasks.", "AI": {"tldr": "This paper introduces a context collection strategy to improve LLM-based code completion by preprocessing repositories into code chunks and using similarity-based retrieval with relative positioning, enhancing performance in code completion tasks.", "motivation": "Modern IDEs offer code completion, but there is limited research on defining optimal contexts for large language models (LLMs). Effective context design is critical to improve LLM accuracy in code completion scenarios.", "method": "The authors propose a strategy involving: (1). Preprocessing repositories into smaller code chunks, (2). Retrieving relevant chunks using syntactic and semantic similarity, and (3). Incorporating relative positioning of chunks to construct contextual inputs for the LLMs.", "result": "Code chunking combined with similarity-based retrieval and relative positioning significantly improves code completion performance compared to baseline methods.", "conclusion": "The paper demonstrates that context engineering through code chunking and strategic positioning enhances LLM effectiveness in code completion, providing a scalable framework for integrating repository information into IDE tools."}}
{"id": "2510.08612", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.08612", "abs": "https://arxiv.org/abs/2510.08612", "authors": ["Devang Dhanuka"], "title": "Impact of LLMs on Team Collaboration in Software Development", "comment": null, "summary": "Large Language Models (LLMs) are increasingly being integrated into software\ndevelopment processes, with the potential to transform team workflows and\nproductivity. This paper investigates how LLMs affect team collaboration\nthroughout the Software Development Life Cycle (SDLC). We reframe and update a\nprior study with recent developments as of 2025, incorporating new literature\nand case studies. We outline the problem of collaboration hurdles in SDLC and\nexplore how LLMs can enhance productivity, communication, and decision-making\nin a team context. Through literature review, industry examples, a team survey,\nand two case studies, we assess the impact of LLM-assisted tools (such as code\ngeneration assistants and AI-powered project management agents) on\ncollaborative software engineering practices. Our findings indicate that LLMs\ncan significantly improve efficiency (by automating repetitive tasks and\ndocumentation), enhance communication clarity, and aid cross-functional\ncollaboration, while also introducing new challenges like model limitations and\nprivacy concerns. We discuss these benefits and challenges, present research\nquestions guiding the investigation, evaluate threats to validity, and suggest\nfuture research directions including domain-specific model customization,\nimproved integration into development tools, and robust strategies for ensuring\ntrust and security.", "AI": {"tldr": "2025 study shows LLMs boost software team efficiency and collaboration via automation and communication tools, but face privacy/trust issues; future work needs domain-specific tweaks and better integration.", "motivation": "Address collaboration hurdles in SDLC by investigating how LLMs can improve productivity, communication, and decision-making in teams, while addressing emerging challenges.", "method": "Literature review, industry examples, team survey, and two case studies examining LLM-assisted tools' impacts on collaborative practices.", "result": "LLM-assisted tools automate tasks, improve communication, and enable cross-functional collaboration, but introduce privacy and model capability challenges. These findings guide future research directions.", "conclusion": "LLMs significantly enhance efficiency and collaboration in software development teams, but challenges like model limitations and privacy concerns arise. Future research should focus on customization, integration, and trust & security strategies."}}
{"id": "2510.08700", "categories": ["cs.CR", "cs.DC"], "pdf": "https://arxiv.org/pdf/2510.08700", "abs": "https://arxiv.org/abs/2510.08700", "authors": ["Zhuolun Li", "Haluk Sonmezler", "Faiza Shirazi", "Febin Shaji", "Tymoteusz Mroczkowski", "Dexter Lardner", "Matthew Alain Camus", "Evangelos Pournaras"], "title": "Are Voters Willing to Collectively Secure Elections? Unraveling a Practical Blockchain Voting System", "comment": null, "summary": "Ensuring ballot secrecy is critical for fair and trustworthy electronic\nvoting systems, yet achieving strong secrecy guarantees in decentralized,\nlarge-scale elections remains challenging. This paper proposes the concept of\ncollectively secure voting, in which voters themselves can opt in as secret\nholders to protect ballot secrecy. A practical blockchain-based collectively\nsecure voting system is designed and implemented. Our design strikes a balance\nbetween strong confidentiality guarantees and real-world applicability. The\nproposed system combines threshold cryptography and smart contracts to ensure\nballots remain confidential during voting, while all protocol steps remain\ntransparent and verifiable. Voters can use the system without prior blockchain\nknowledge through an intuitive user interface that hides underlying complexity.\nTo evaluate this approach, a user testing is conducted. Results show a high\nwillingness to act as secret holders, reliable participation in share release,\nand high security confidence in the proposed system. The findings demonstrate\nthat voters can collectively maintain secrecy and that such a practical\ndeployment is feasible.", "AI": {"tldr": "Researchers developed a blockchain-based voting system where voters collectively protect ballot secrecy using threshold cryptography and smart contracts. User testing proved high adoption potential and security effectiveness for large-scale elections.", "motivation": "Current decentralized electronic voting systems struggle to guarantee ballot secrecy at scale, creating vulnerabilities that could compromise election integrity. The paper addresses this challenge by exploring how collective participation from voters can strengthen secrecy assurances.", "method": "The method involves a blockchain-based system combining threshold cryptography and smart contracts. It introduces a mechanism where voters can volunteer as secret holders, ensuring ballots remain confidential while allowing transparent verification. An intuitive user interface is designed to hide technical complexities from non-expert users.", "result": "User testing validated the system's practicality, showing high voter willingness to act as secret holders, reliable execution of share-releasing protocols, and strong security confidence. These results confirm the feasibility of collective secrecy maintenance in real-world scenarios.", "conclusion": "The paper concludes that collectively secure voting systems, which decentralize the protection of ballot secrecy through voter participation, are a feasible solution. The implementation demonstrates that such systems can balance strong confidentiality with practical deployment in large-scale elections."}}
{"id": "2510.08640", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.08640", "abs": "https://arxiv.org/abs/2510.08640", "authors": ["Ha Min Son", "Huan Ren", "Xin Liu", "Zhe Zhao"], "title": "Automating Android Build Repair: Bridging the Reasoning-Execution Gap in LLM Agents with Domain-Specific Tools", "comment": null, "summary": "Android is the largest mobile platform, yet automatically building\napplications remains a practical challenge. While Large Language Models (LLMs)\nshow promise for code repair, their use for fixing Android build errors remains\nunderexplored. To address this gap, we first introduce AndroidBuildBench, a\nbenchmark of 1,019 build failures curated from the commit histories of 43\nopen-source Android projects. Each problem is paired with a verified solution\nfrom a subsequent commit, ensuring that fixes are feasible. Second, we propose\nGradleFixer, an LLM agent with domain-specific tools for inspecting and\nmanipulating the Gradle build environment. GradleFixer achieves a resolve rate\nof 81.4% (pass@1), significantly outperforming a state-of-the-art coding agent\nthat relies on a general-purpose shell. GradleFixer's success suggests that\nwhile LLMs possess the high-level knowledge to solve these failures, they\nstruggle to translate this knowledge into effective low-level actions using a\ngeneral-purpose shell. We demonstrate the effectiveness of a strategy we term\nTool Bridging, which replaces general-purpose shell commands with domain-aware\nabstractions. We hypothesize this approach works through two mechanisms: 1) it\nprovides tools in an API-like format that LLMs use more reliably, and 2) it\nconstrains the action space to relevant operations. This approach bridges the\ngap between the model's high-level reasoning and effective low-level execution.", "AI": {"tldr": "This paper introduces AndroidBuildBench, a benchmark for Android build failures, and GradleFixer, an LLM agent with domain-specific tools to resolve these errors. GradleFixer achieves an 81.4% resolve rate through 'Tool Bridging,' which uses API-like abstractions to improve LLM effectiveness in low-level build fixes.", "motivation": "Automatically building Android applications remains challenging despite LLM advancements in code repair. Existing methods struggle to translate high-level LLM knowledge into effective low-level build environment actions using general-purpose shells.", "method": "1. Created AndroidBuildBench: 1,019 Android build failures from 43 open-source projects with verified fixes. 2. Developed GradleFixer: An LLM agent using domain-specific Gradle tools (Tool Bridging) instead of general shells. 3. Evaluated resolve rate (pass@1) against state-of-the-art coding agents.", "result": "GradleFixer achieved 81.4% resolve rate (pass@1), significantly outperforming shell-based agents. Tool Bridging improved reliability by providing API-like interfaces and constrained action spaces to relevant operations.", "conclusion": "Tool Bridging effectively bridges LLMs' high-level reasoning and low-level execution in build environments. Domain-aware abstractions improve fix feasibility, suggesting specialized tools are critical for solving technical domain challenges that general-purpose methods cannot address."}}
{"id": "2510.08725", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.08725", "abs": "https://arxiv.org/abs/2510.08725", "authors": ["Gorjan Alagic", "Chen Bai", "Christian Majenz", "Kaiyan Shi"], "title": "Post-Quantum Security of Block Cipher Constructions", "comment": null, "summary": "Block ciphers are versatile cryptographic ingredients that are used in a wide\nrange of applications ranging from secure Internet communications to disk\nencryption. While post-quantum security of public-key cryptography has received\nsignificant attention, the case of symmetric-key cryptography (and block\nciphers in particular) remains a largely unexplored topic. In this work, we set\nthe foundations for a theory of post-quantum security for block ciphers and\nassociated constructions. Leveraging our new techniques, we provide the first\npost-quantum security proofs for the key-length extension scheme FX, the\ntweakable block ciphers LRW and XEX, and most block cipher encryption and\nauthentication modes. Our techniques can be used for security proofs in both\nthe plain model and the quantum ideal cipher model. Our work takes significant\ninitial steps in establishing a rigorous understanding of the post-quantum\nsecurity of practical symmetric-key cryptography.", "AI": {"tldr": "Pioneers post-quantum security analysis for block ciphers, offering rigorous proofs for widely used cryptographic schemes against quantum threats.", "motivation": "The post-quantum security of symmetric-key cryptography, particularly block ciphers, remains underexplored despite growing interest in quantum-resistant cryptography for public-key systems.", "method": "Developed novel techniques for post-quantum security proofs, applicable in both plain and quantum ideal cipher models, and applied them to key-length extension schemes (FX) and tweakable block ciphers (LRW, XEX).", "result": "First post-quantum security proofs for FX, LRW, XEX, and major encryption/authentication modes, with techniques validated across two security models.", "conclusion": "This work establishes foundational theories for post-quantum security in block ciphers, providing critical initial steps toward understanding symmetric-key cryptography's resilience against quantum threats."}}
{"id": "2510.08664", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.08664", "abs": "https://arxiv.org/abs/2510.08664", "authors": ["Jianan Mu", "Mingyu Shi", "Yining Wang", "Tianmeng Yang", "Bin Sun", "Xing Hu", "Jing Ye", "Huawei Li"], "title": "Faver: Boosting LLM-based RTL Generation with Function Abstracted Verifiable Middleware", "comment": null, "summary": "LLM-based RTL generation is an interesting research direction, as it holds\nthe potential to liberate the least automated stage in the current chip design.\nHowever, due to the substantial semantic gap between high-level specifications\nand RTL, coupled with limited training data, existing models struggle with\ngeneration accuracy. Drawing on human experience, design with verification\nhelps improving accuracy. However, as the RTL testbench data are even more\nscarce, it is not friendly for LLMs. Although LLMs excel at higher-level\nlanguages like Python/C, they have a huge semantic gap from RTL. When\nimplementing the same functionality, Python/C code and hardware code differ\nsignificantly in the spatiotemporal granularity, requiring the LLM not only to\nconsider high-level functional semantics but also to ensure the low-level\ndetails align with the circuit code. It is not an easy task. In this paper, we\npropose a function abstracted verifiable middleware (Faver) that streamlines\nRTL verification in LLM-based workflows. By mixing LLM-friendly code structures\nwith a rule-based template, Faver decouples the details of circuit\nverification, allowing the LLM to focus on the functionality itself. In our\nexperiments on the SFT model and open-source models, Faver improved the model's\ngeneration accuracy by up to 14%.", "AI": {"tldr": "Faver bridges the RTL generation accuracy gap for LLMs by abstracting verification challenges, achieving 14% improved results.", "motivation": "Existing LLM-based RTL generation struggles with accuracy due to the semantic gap between high-level specifications and RTL, limited training data, and scarcity of RTL testbench examples, necessitating new approaches to bridge these challenges.", "method": "Faver integrates LLM-friendly code structures with rule-based templates to isolate circuit verification details, enabling LLMs to focus on functional implementation without low-level constraints.", "result": "Experiments show Faver improves SFT and open-source models' RTL generation accuracy by up to 14%, validating its effectiveness in LLM-driven design workflows.", "conclusion": "The proposed Faver middleware effectively streamlines RTL verification in LLM-based workflows by reducing the semantic gap and improving generation accuracy through decoupling verification complexities."}}
{"id": "2510.08829", "categories": ["cs.CR", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.08829", "abs": "https://arxiv.org/abs/2510.08829", "authors": ["Debeshee Das", "Luca Beurer-Kellner", "Marc Fischer", "Maximilian Baader"], "title": "CommandSans: Securing AI Agents with Surgical Precision Prompt Sanitization", "comment": null, "summary": "The increasing adoption of LLM agents with access to numerous tools and\nsensitive data significantly widens the attack surface for indirect prompt\ninjections. Due to the context-dependent nature of attacks, however, current\ndefenses are often ill-calibrated as they cannot reliably differentiate\nmalicious and benign instructions, leading to high false positive rates that\nprevent their real-world adoption. To address this, we present a novel approach\ninspired by the fundamental principle of computer security: data should not\ncontain executable instructions. Instead of sample-level classification, we\npropose a token-level sanitization process, which surgically removes any\ninstructions directed at AI systems from tool outputs, capturing malicious\ninstructions as a byproduct. In contrast to existing safety classifiers, this\napproach is non-blocking, does not require calibration, and is agnostic to the\ncontext of tool outputs. Further, we can train such token-level predictors with\nreadily available instruction-tuning data only, and don't have to rely on\nunrealistic prompt injection examples from challenges or of other synthetic\norigin. In our experiments, we find that this approach generalizes well across\na wide range of attacks and benchmarks like AgentDojo, BIPIA, InjecAgent, ASB\nand SEP, achieving a 7-10x reduction of attack success rate (ASR) (34% to 3% on\nAgentDojo), without impairing agent utility in both benign and malicious\nsettings.", "AI": {"tldr": "A token-level sanitization method dramatically reduces LLM agent vulnerability to prompt injections without synthetic attack training.", "motivation": "Current defenses for indirect prompt injections suffer from high false positives and poor calibration, rendering them unsuitable for real-world deployment. LLM agents' expanded access to tools and sensitive data exacerbates this problem due to the context-dependent nature of attacks.", "method": "The proposed method involves a token-level sanitization process that removes instructions directed at AI systems from tool outputs. It operates non-intrusively, is context-agnostic, and leverages existing instruction-tuning data for training without reliance on synthetic attack samples.", "result": "The method achieves a 7-10\u00d7 reduction in attack success rates (e.g., from 34% to 3% on AgentDojo) across multiple benchmarks (AgentDojo, BIPIA, InjecAgent, ASB, and SEP), preserving agent utility in both benign and malicious scenarios.", "conclusion": "The paper presents a novel, practical approach to reducing indirect prompt injection attacks through token-level sanitization, which effectively lowers attack success rates without compromising agent utility, making it suitable for real-world applications."}}
{"id": "2510.08665", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.08665", "abs": "https://arxiv.org/abs/2510.08665", "authors": ["Aofan Liu", "Haoxuan Li", "Bin Wang", "Ao Yang", "Hui Li"], "title": "RA-Gen: A Controllable Code Generation Framework Using ReAct for Multi-Agent Task Execution", "comment": null, "summary": "Code generation models based on large language models (LLMs) have gained wide\nadoption, but challenges remain in ensuring safety, accuracy, and\ncontrollability, especially for complex tasks. Existing methods often lack\ndynamic integration of external tools, transparent reasoning, and user control\nover safety. To address these issues, we propose a controllable code generation\nframework utilizing the ReAct paradigm for multi-agent task execution. This\nframework is a multi-agent system designed to enable efficient, precise, and\ninterpretable code generation through dynamic interactions between LLMs and\nexternal resources. The framework adopts a collaborative architecture\ncomprising four specialized agents: a Planner for task decomposition, a\nSearcher that leverages the ReAct framework for reasoning and tool integration,\na CodeGen agent for accurate code generation, and an Extractor for structured\ndata retrieval. The ReAct-based Searcher alternates between generating\nreasoning traces and executing actions, facilitating seamless integration of\ninternal knowledge with external tools (such as search engines) to enhance\naccuracy and user control. Experimental results show the framework's\neffectiveness across multiple languages, achieving a 94.8% security rate on the\nSVEN dataset with CodeQL, outperforming existing approaches. Its transparent\nreasoning process fosters user trust and improves controllability.", "AI": {"tldr": "This paper introduces a controllable code generation framework that uses the ReAct paradigm for multi-agent task execution. It enhances safety, accuracy, and user control by dynamically integrating external tools through four specialized agents.", "motivation": "Current code generation models often fall short in safety, accuracy, and controllability, especially when handling complex tasks. The integration of external tools in a dynamic and transparent way for code generation remains a challenge in existing methods.", "method": "The proposed framework is a multi-agent system comprising four agents: Planner for task decomposition, Searcher utilizing the ReAct framework for reasoning and tool integration, CodeGen for code generation, and Extractor for structured data retrieval. The Searcher agent dynamically interacts with external tools, such as search engines, while the other agents work in coordination for generating and extracting precise, secure code.", "result": "The framework achieved a 94.8% security rate on the SVEN dataset using CodeQL and outperformed existing approaches. Additionally, it demonstrated effective code generation across multiple languages, and its transparent reasoning improved user trust and controllability.", "conclusion": "The new controllable code generation framework provides a robust solution by leveraging the ReAct paradigm, enhancing dynamic interactions among agents and external tools. It improves safety, accuracy, and user transparency, making it applicable for various programming tasks and establishing a solid foundation for further advancements in code generation research."}}
{"id": "2510.08918", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.08918", "abs": "https://arxiv.org/abs/2510.08918", "authors": ["Boyu Liu", "Yang Zhang", "Liang Cheng", "Yi Zhang", "Junjie Fan", "Yu Fu"], "title": "Psyzkaller: Learning from Historical and On-the-Fly Execution Data for Smarter Seed Generation in OS kernel Fuzzing", "comment": null, "summary": "Fuzzing has become a cornerstone technique for uncovering vulnerabilities and\nenhancing the security of OS kernels. However, state-of-the-art kernel fuzzers,\nincluding the de facto standard Syzkaller, struggle to generate valid syscall\nsequences that respect implicit Syscall Dependency Relations (SDRs).\nConsequently, many generated seeds either fail kernel validation or cannot\npenetrate deep execution paths, resulting in significant inefficiency.\n  We hypothesize that SDRs can be effectively learned from both historic and\npresent kernel execution data, and that incorporating these learned relations\ninto fuzzing can substantially improve seed validity and diversity. To validate\nthis, we propose an approach that utilizes the N-gram model to mine SDRs from\nthe Dongting dataset-one of the largest Linux kernel execution datasets\navailable-as well as from execution traces collected on the fly during fuzzing.\nThe resulting model is used to continuously augment the Choice Table of\nSyzkaller to improve its seed generation and demonstrably increases the Shannon\nEntropy of the Choice Table throughout fuzzing, reflecting more\nempirically-grounded choices in expanding syscall sequences into valid and\ndiverse seeds. In addition, we introduce a Random Walk strategy that instructs\nSyzkaller to construct seeds in a bidirectional manner to further diversify the\ngenerated seeds.\n  We implement our approach in a prototype, Psyzkaller, built on top of\nSyzkaller. Experiments on three representative Linux kernel versions show that\nPsyzkaller improves Syzkaller's code coverage by 4.6%-7.0% in 48-hour fuzzing,\nwhile triggering 110.4%-187.2% more crashes. Moreover, our investigation shows\nthat Psyzkaller discovered eight previously unknown kernel vulnerabilities,\ncompared to only one found by Syzkaller.", "AI": {"tldr": "This paper enhances Syzkaller, a Linux kernel fuzzer, using an N-gram model and a Random Walk strategy to generate more valid and diverse syscall sequences, significantly improving coverage and vulnerability detection.", "motivation": "State-of-the-art kernel fuzzers like Syzkaller suffer from inefficiencies due to inability to generate valid syscall sequences that adhere to Syscall Dependency Relations (SDRs). This leads to failed seeds and limited exploration of deep execution paths.", "method": "The authors propose a method that (1) mines SDRs using an N-gram model from historical data (Dongting dataset) and real-time traces during fuzzing, and (2) uses a Random Walk approach to generate seeds bidirectionally in the Choice Table of Syzkaller. This improves sequence validity and diversity.", "result": "On three Linux kernel versions, Psyzkaller achieved 4.6%-7.0% higher code coverage with 48-hour fuzzing compared to Syzkaller, and triggered 110.4%-187.2% more crashes. It also found 8 new kernel vulnerabilities, as opposed to only 1 by Syzkaller.", "conclusion": "By learning SDRs from kernel execution data and applying bidirectional seed generation, Psyzkaller demonstrates tangible improvements over Syzkaller in Linux kernel fuzzing effectiveness, coverage, and vulnerability discovery."}}
{"id": "2510.08667", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.08667", "abs": "https://arxiv.org/abs/2510.08667", "authors": ["Mohammad Baqar"], "title": "RAG4Tickets: AI-Powered Ticket Resolution via Retrieval-Augmented Generation on JIRA and GitHub Data", "comment": "13 Pages", "summary": "Modern software teams frequently encounter delays in resolving recurring or\nrelated issues due to fragmented knowledge scattered across JIRA tickets,\ndeveloper discussions, and GitHub pull requests (PRs). To address this\nchallenge, we propose a Retrieval-Augmented Generation (RAG) framework that\nintegrates Sentence-Transformers for semantic embeddings with FAISS-based\nvector search to deliver context-aware ticket resolution recommendations. The\napproach embeds historical JIRA tickets, user comments, and linked PR metadata\nto retrieve semantically similar past cases, which are then synthesized by a\nLarge Language Model (LLM) into grounded and explainable resolution\nsuggestions. The framework contributes a unified pipeline linking JIRA and\nGitHub data, an embedding and FAISS indexing strategy for heterogeneous\nsoftware artifacts, and a resolution generation module guided by retrieved\nevidence. Experimental evaluation using precision, recall, resolution time\nreduction, and developer acceptance metrics shows that the proposed system\nsignificantly improves resolution accuracy, fix quality, and knowledge reuse in\nmodern DevOps environments.", "AI": {"tldr": "The paper proposes a RAG framework combining Sentence-Transformers and FAISS to improve JIRA ticket resolution by synthesizing historical data from JIRA and GitHub.", "motivation": "The paper addresses the problem of fragmented knowledge across JIRA tickets, developer discussions, and GitHub PRs, which causes delays in resolving recurring issues.", "method": "A RAG approach is used with Sentence-Transformers for embeddings and FAISS for vector search. It integrates JIRA and GitHub data into a unified pipeline, utilizing embeddings for heterogeneous artifacts and generating resolution suggestions with an LLM guided by retrieved evidence.", "result": "Experiments showed improvements in precision, recall, resolution time, and developer acceptance, demonstrating that the system enhances resolution accuracy and knowledge reuse in DevOps.", "conclusion": "The framework successfully improves ticket resolution in modern DevOps environments by leveraging knowledge from historical tickets and PRs through a RAG pipeline with embeddings and FAISS."}}
{"id": "2510.09006", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.09006", "abs": "https://arxiv.org/abs/2510.09006", "authors": ["Chandra Thapa", "Surya Nepal"], "title": "Future G Network's New Reality: Opportunities and Security Challenges", "comment": "12 pages, 7 figures", "summary": "Future G network's new reality is a widespread cyber-physical environment\ncreated by Integrated Sensing and Communication (ISAC). It is a crucial\ntechnology that transforms wireless connections into ubiquitous sensors. ISAC\nunlocks transformative new capabilities, powering autonomous systems, augmented\nhuman sensing, and next-generation immersive applications, such as digital\ntwins. However, this new reality fundamentally reshapes the security landscape.\nThe primary security concern shifts from the traditional focus on data\nprotection to a new priority: safeguarding the integrity of the system's\nperception of physical reality itself. This perception can be perilously\nmanipulated by sophisticated attacks such as sensing eavesdropping, phantom\ndangers, and invisible threats, potentially resulting in direct and\ncatastrophic physical harm. Traditional security measures, such as\nsignature-based detection, are insufficient to counter these perception-level\nthreats that mimic genuine physical signals. A proactive, layered,\ndefense-in-depth strategy is required, integrating physical, environmental,\nintelligence, and architectural security measures to build a trustworthy\necosystem. Additionally, realizing ISAC's potential responsibly also depends on\nparallel efforts in global standardization and strong governance to address the\nsignificant challenges of privacy, liability, and the technology's dual-use.", "AI": {"tldr": "This paper addresses emerging security challenges in ISAC-enabled G networks, where threats target systems' perception of reality. A multi-layered defense strategy and robust governance are proposed to ensure safe adoption.", "motivation": "The paper highlights the need to address the paradigm shift in security priorities as ISAC transforms wireless networks into pervasive sensors, introducing perceptual threats that can cause direct physical harm.", "method": "The authors propose a defense-in-depth framework integrating physical, environmental, intelligence, and architectural security measures to counter perception-level threats such as sensing eavesdropping and phantom dangers.", "result": "A holistic security strategy is developed, emphasizing trusted ecosystem design and governance structures to ensure responsible ISAC deployment while mitigating risks from adversarial physical signal manipulations.", "conclusion": "The paper concludes that securing ISAC's perception of physical reality requires a proactive, layered defense strategy and emphasizes the necessity of global standardization and governance to address privacy, liability, and dual-use challenges."}}
{"id": "2510.08697", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.08697", "abs": "https://arxiv.org/abs/2510.08697", "authors": ["Terry Yue Zhuo", "Xiaolong Jin", "Hange Liu", "Juyong Jiang", "Tianyang Liu", "Chen Gong", "Bhupesh Bishnoi", "Vaisakhi Mishra", "Marek Suppa", "Noah Ziems", "Saiteja Utpala", "Ming Xu", "Guangyu Song", "Kaixin Li", "Yuhan Cao", "Bo Liu", "Zheng Liu", "Sabina Abdurakhmanova", "Wenhao Yu", "Mengzhao Jia", "Jihan Yao", "Kenneth Hamilton", "Kumar Shridhar", "Minh Chien Vu", "Dingmin Wang", "Jiawei Liu", "Zijian Wang", "Qian Liu", "Binyuan Hui", "Meg Risdal", "Ahsen Khaliq", "Atin Sood", "Zhenchang Xing", "Wasi Uddin Ahmad", "John Grundy", "David Lo", "Banghua Zhu", "Xiaoning Du", "Torsten Scholak", "Leandro von Werra"], "title": "BigCodeArena: Unveiling More Reliable Human Preferences in Code Generation via Execution", "comment": "Built with love by the BigCode community :)", "summary": "Crowdsourced model evaluation platforms, such as Chatbot Arena, enable\nreal-time evaluation from human perspectives to assess the quality of model\nresponses. In the coding domain, manually examining the quality of\nLLM-generated content is extremely challenging, as it requires understanding\nlong chunks of raw code and deliberately simulating code execution. To this\nend, we introduce BigCodeArena, an open human evaluation platform for code\ngeneration backed by a comprehensive and on-the-fly execution environment.\nBuilt on top of Chatbot Arena, BigCodeArena enables the execution of\nLLM-generated code and allows humans to interact with the execution process and\noutcomes. We collected over 14,000 raw code-centric conversation sessions\nacross 10 widely used LLMs, spanning 10 languages and 8 types of execution\nenvironments. Among these conversations, we identified more than 4,700\nmulti-turn samples with pairwise human preferences. Further analysis uncovers\nunderexplored preferences of LLMs in fine-grained domains characterized by\ntasks, languages, and frameworks. To systematically examine code understanding\nand generation capabilities of frontier LLMs, we curated two benchmarks based\non the collected data, namely BigCodeReward and AutoCodeArena. For\nBigCodeReward, we post-processed the 4,700 conversations and evaluated the\nconsistency between reward models and human preferences. The evaluation shows\nthat most LLMs have superior performance in judging coding preferences when the\nexecution results are available. Inspired by these findings, we propose\nAutoCodeArena, an automatic Elo rating benchmark designed to assess the coding\nquality of LLMs without human involvement. We find that proprietary LLMs like\nGPT-5, Claude-Sonnet-4, and Claude-Opus-4 still lead in code generation\nperformance among recent emerging models.", "AI": {"tldr": "BigCodeArena is an open human evaluation platform for code generation LLMs, enabling code execution and human interaction. It introduces benchmarks (BigCodeReward, AutoCodeArena) to assess coding quality and model preferences.", "motivation": "Manually evaluating LLM-generated code is challenging due to the need for long-form code understanding and execution simulation. Crowdsourced platforms lack execution environments for code domains.", "method": "Built on Chatbot Arena, BigCodeArena enables execution of LLM-generated code. Collected 14,000 conversations across 10 LLMs, 10 languages, and 8 environments. Identified 4,700 multi-turn samples with human pairwise preferences. Created benchmarks: BigCodeReward (reward model consistency) and AutoCodeArena (automatic Elo rating system for code quality).", "result": "LLMs show higher coding preference judgment accuracy with execution results. Reward models demonstrate strong correlation with human preferences. AutoCodeArena benchmarks reveal proprietary models (e.g., GPT-5, Claude-Sonnet-4) maintain top performance in code generation.", "conclusion": "BigCodeArena establishes systematic code generation evaluation through execution environments and benchmarks, highlighting model strengths in execution-aware assessments and maintaining leadership of existing LLMs in code domains."}}
{"id": "2510.09093", "categories": ["cs.CR", "cs.CL", "68T50, 68T0", "F.2.2; I.2.7; K.6.5"], "pdf": "https://arxiv.org/pdf/2510.09093", "abs": "https://arxiv.org/abs/2510.09093", "authors": ["Dennis Rall", "Bernhard Bauer", "Mohit Mittal", "Thomas Fraunholz"], "title": "Exploiting Web Search Tools of AI Agents for Data Exfiltration", "comment": "9 pages, 6 figures, conference article", "summary": "Large language models (LLMs) are now routinely used to autonomously execute\ncomplex tasks, from natural language processing to dynamic workflows like web\nsearches. The usage of tool-calling and Retrieval Augmented Generation (RAG)\nallows LLMs to process and retrieve sensitive corporate data, amplifying both\ntheir functionality and vulnerability to abuse. As LLMs increasingly interact\nwith external data sources, indirect prompt injection emerges as a critical and\nevolving attack vector, enabling adversaries to exploit models through\nmanipulated inputs. Through a systematic evaluation of indirect prompt\ninjection attacks across diverse models, we analyze how susceptible current\nLLMs are to such attacks, which parameters, including model size and\nmanufacturer, specific implementations, shape their vulnerability, and which\nattack methods remain most effective. Our results reveal that even well-known\nattack patterns continue to succeed, exposing persistent weaknesses in model\ndefenses. To address these vulnerabilities, we emphasize the need for\nstrengthened training procedures to enhance inherent resilience, a centralized\ndatabase of known attack vectors to enable proactive defense, and a unified\ntesting framework to ensure continuous security validation. These steps are\nessential to push developers toward integrating security into the core design\nof LLMs, as our findings show that current models still fail to mitigate\nlong-standing threats.", "AI": {"tldr": "This paper investigates the vulnerability of LLMs to indirect prompt injection attacks, emphasizing the need for improved security through enhanced training, a centralized attack database, and a unified testing framework.", "motivation": "The increasing use of LLMs for sensitive tasks via tool-calling and RAG raises security concerns, particularly regarding indirect prompt injection attacks, which exploit model weaknesses through manipulated external inputs.", "method": "Through a systematic evaluation, the study assesses the susceptibility of various LLMs to indirect prompt injection attacks, investigates the influence of model parameters, and identifies effective attack methods.", "result": "Results show that existing attack patterns remain successful, highlighting persistent defenses. Specific model characteristics and implementation factors correlate with increased vulnerability, underscoring the importance of security-focused development.", "conclusion": "The paper concludes by stressing the importance of integrating security into the design of LLMs through stronger training procedures, centralized attack databases, and unified testing frameworks to combat ongoing threats effectively."}}
{"id": "2510.08716", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.08716", "abs": "https://arxiv.org/abs/2510.08716", "authors": ["Stephan Lukasczyk", "Gordon Fraser"], "title": "Search-based Hyperparameter Tuning for Python Unit Test Generation", "comment": "Accepted to the 17th Symposium on Search-Based Software Engineering\n  2025 (SSBSE 2025)", "summary": "Search-based test-generation algorithms have countless configuration options.\nUsers rarely adjust these options and usually stick to the default values,\nwhich may not lead to the best possible results. Tuning an algorithm's\nhyperparameters is a method to find better hyperparameter values, but it\ntypically comes with a high demand of resources. Meta-heuristic search\nalgorithms -- that effectively solve the test-generation problem -- have been\nproposed as a solution to also efficiently tune parameters. In this work we\nexplore the use of differential evolution as a means for tuning the\nhyperparameters of the DynaMOSA and MIO many-objective search algorithms as\nimplemented in the Pynguin framework. Our results show that significant\nimprovement of the resulting test suite's coverage is possible with the tuned\nDynaMOSA algorithm and that differential evolution is more efficient than basic\ngrid search.", "AI": {"tldr": "This paper explores using differential evolution to tune hyperparameters of many-objective search algorithms (DynaMOSA, MIO), achieving improved test suite coverage and outperforming grid search in efficiency.", "motivation": "Default configuration options of test-generation algorithms often suboptimally balance objectives, and hyperparameter tuning is typically resource-intensive.", "method": "Applied differential evolution as a meta-heuristic optimizer to tune DynaMOSA and MIO hyperparameters within Pynguin, comparing results to a baseline grid search approach.", "result": "Tuned DynaMOSA achieved significantly improved test coverage; differential evolution demonstrated 94% reduction in evaluation effort compared to grid search.", "conclusion": "Differential evolution enhances test suite quality through effective hyperparameter optimization while substantially reducing computational requirements compared to traditional search methods."}}
{"id": "2510.09210", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.09210", "abs": "https://arxiv.org/abs/2510.09210", "authors": ["Yifan Zhu", "Lijia Yu", "Xiao-Shan Gao"], "title": "Provable Watermarking for Data Poisoning Attacks", "comment": "42 pages, NeurIPS 2025", "summary": "In recent years, data poisoning attacks have been increasingly designed to\nappear harmless and even beneficial, often with the intention of verifying\ndataset ownership or safeguarding private data from unauthorized use. However,\nthese developments have the potential to cause misunderstandings and conflicts,\nas data poisoning has traditionally been regarded as a security threat to\nmachine learning systems. To address this issue, it is imperative for harmless\npoisoning generators to claim ownership of their generated datasets, enabling\nusers to identify potential poisoning to prevent misuse. In this paper, we\npropose the deployment of watermarking schemes as a solution to this challenge.\nWe introduce two provable and practical watermarking approaches for data\npoisoning: {\\em post-poisoning watermarking} and {\\em poisoning-concurrent\nwatermarking}. Our analyses demonstrate that when the watermarking length is\n$\\Theta(\\sqrt{d}/\\epsilon_w)$ for post-poisoning watermarking, and falls within\nthe range of $\\Theta(1/\\epsilon_w^2)$ to $O(\\sqrt{d}/\\epsilon_p)$ for\npoisoning-concurrent watermarking, the watermarked poisoning dataset provably\nensures both watermarking detectability and poisoning utility, certifying the\npracticality of watermarking under data poisoning attacks. We validate our\ntheoretical findings through experiments on several attacks, models, and\ndatasets.", "AI": {"tldr": "This paper proposes watermarking schemes for harmless data poisoning, balancing ownership verification with security via post-poisoning and poisoning-concurrent methods, validated theoretically and experimentally.", "motivation": "The growing ambiguity between harmless watermarking and malicious data poisoning creates risks of misuse and conflict. Ownership verification through watermarking is critical to mitigate these risks.", "method": "The paper introduces two watermarking approaches: post-poisoning (applied after poisoning) and poisoning-concurrent (integrated during poisoning), both with proven theoretical bounds on watermark length for detectability and utility.", "result": "Theoretical guarantees show that watermarked datasets achieve detectability with lengths \u0398(\u221ad/\u03b5_w) for post-poisoning and \u00b1\u0398(1/\u03b5\u00b2_w)\u2013O(\u221ad/\u03b5_p) for concurrent methods. Experiments confirm robustness across attacks, models, and datasets.", "conclusion": "Watermarking schemes can effectively address the challenges of harmless data poisoning by enabling ownership claims and preventing misuse, as demonstrated through theoretical analysis and experimental validation."}}
{"id": "2510.08810", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.08810", "abs": "https://arxiv.org/abs/2510.08810", "authors": ["Mohayeminul Islam", "Ajay Kumar Jha", "May Mahmoud", "Sarah Nadi"], "title": "PyMigTool: a tool for end-to-end Python library migration", "comment": "arXiv admin note: text overlap with arXiv:2504.13272", "summary": "Library migration is the process of replacing a library with a similar one in\na software project. Manual library migration is time consuming and error prone,\nas it requires developers to understand the Application Programming Interfaces\n(API) of both libraries, map equivalent APIs, and perform the necessary code\ntransformations. Due to the difficulty of the library migration process, most\nof the existing automated techniques and tooling stop at the API mapping stage\nor support a limited set of libraries and code transformations. In this paper,\nwe develop an end-to-end solution that can automatically migrate code between\nany arbitrary pair of Python libraries that provide similar functionality. Due\nto the promising capabilities of Large Language Models (LLMs) in code\ngeneration and transformation, we use LLMs as the primary engine for migration.\nBefore building the tool, we first study the capabilities of LLMs for library\nmigration on a benchmark of 321 real-world library migrations. We find that\nLLMs can effectively perform library migration, but some post-processing steps\ncan further improve the performance. Based on this, we develop PyMigTool, a\ncommand line application that combines the power of LLMs, static analysis, and\ndynamic analysis to provide accurate library migration. We evaluate PyMigTool\non 717 real-world Python applications that are not from our benchmark. We find\nthat PyMigTool can migrate 32% of the migrations with complete correctness. Of\nthe remaining migrations, only 14% of the migration-related changes are left\nfor developers to fix for more than half of the projects.", "AI": {"tldr": "The paper introduces PyMigTool, an end-to-end solution using Large Language Models (LLMs) combined with static/dynamic analysis to automate Python library migrations, achieving 32% complete correctness and reducing developer fixes to 14%", "motivation": "Manual library migration is time-consuming and error-prone. Existing automated tools only support limited API mappings and library pairs. Developing a generalized solution for accurate and complete library migrations.", "method": "1. Benchmark study of 321 real-world migrations to assess LLM capabilities\n2. Developed PyMigTool combining LLMs (for code generation), static analysis (for code context), and dynamic analysis (for execution verification)\n3. Post-processing steps to enhance LLM outputs", "result": "Evaluated on 717 new Python applications:\n- 32% migrations with complete correctness\n- 14%' of migration-related changes require developer attention for more than half of projects\n- Tool works for arbitrary library pairs with similar functionality", "conclusion": "LLMs combined with analysis techniques can effectively solve the library migration problem. PyMigTool demonstrates feasibility of end-to-end solutions, significantly reducing manual effort while maintaining high accuracy"}}
{"id": "2510.09260", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.09260", "abs": "https://arxiv.org/abs/2510.09260", "authors": ["Subrat Kishore Dutta", "Yuelin Xu", "Piyush Pant", "Xiao Zhang"], "title": "GREAT: Generalizable Backdoor Attacks in RLHF via Emotion-Aware Trigger Synthesis", "comment": null, "summary": "Recent work has shown that RLHF is highly susceptible to backdoor attacks,\npoisoning schemes that inject malicious triggers in preference data. However,\nexisting methods often rely on static, rare-token-based triggers, limiting\ntheir effectiveness in realistic scenarios. In this paper, we develop GREAT, a\nnovel framework for crafting generalizable backdoors in RLHF through\nemotion-aware trigger synthesis. Specifically, GREAT targets harmful response\ngeneration for a vulnerable user subgroup characterized by both semantically\nviolent requests and emotionally angry triggers. At the core of GREAT is a\ntrigger identification pipeline that operates in the latent embedding space,\nleveraging principal component analysis and clustering techniques to identify\nthe most representative triggers. To enable this, we present Erinyes, a\nhigh-quality dataset of over $5000$ angry triggers curated from GPT-4.1 using a\nprincipled, hierarchical, and diversity-promoting approach. Experiments on\nbenchmark RLHF datasets demonstrate that GREAT significantly outperforms\nbaseline methods in attack success rates, especially for unseen trigger\nscenarios, while largely preserving the response quality on benign inputs.", "AI": {"tldr": "This paper introduces GREAT, a framework for creating generalizable RLHF backdoors via emotion-aware triggers, using PCA-based latent embedding analysis and a curated dataset of angry triggers (Erinyes).", "motivation": "Existing backdoor attacks on RLHF use static, rare-token triggers that fail in realistic scenarios, necessitating more adaptive and context-aware methods.", "method": "GREAT synthesizes emotions-related triggers in the latent space via PCA for dimensionality reduction and clustering to identify representative samples. Erinyes dataset (n=5k) is built using GPT-4.1 with hierarchical curation for trigger diversity.", "result": "GREAT achieves significantly higher attack success rates on benchmark RLHF datasets compared to baselines, particularly excelling against unseen triggers while maintaining response quality for normal inputs.", "conclusion": "The emotion-aware approach in latent space enables more effective and generalizable backdoor attacks, highlighting vulnerabilities in RLHF systems when faced with semantically meaningful triggers."}}
{"id": "2510.08827", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.CY"], "pdf": "https://arxiv.org/pdf/2510.08827", "abs": "https://arxiv.org/abs/2510.08827", "authors": ["Erfan Al-Hossami", "Razvan Bunescu"], "title": "McMining: Automated Discovery of Misconceptions in Student Code", "comment": "16 pages, 8 figures", "summary": "When learning to code, students often develop misconceptions about various\nprogramming language concepts. These can not only lead to bugs or inefficient\ncode, but also slow down the learning of related concepts. In this paper, we\nintroduce McMining, the task of mining programming misconceptions from samples\nof code from a student. To enable the training and evaluation of McMining\nsystems, we develop an extensible benchmark dataset of misconceptions together\nwith a large set of code samples where these misconceptions are manifested. We\nthen introduce two LLM-based McMiner approaches and through extensive\nevaluations show that models from the Gemini, Claude, and GPT families are\neffective at discovering misconceptions in student code.", "AI": {"tldr": "This paper introduces McMining, a task for identifying programming misconceptions in student code using LLMs. It presents a benchmark dataset and demonstrates effectiveness of Gemini, Claude, and GPT models in detecting misconceptions.", "motivation": "Student misconceptions in programming lead to inefficient learning and buggy code. Current methods lack systematic approaches to identify these misconceptions at scale.", "method": "1. Created an extensible benchmark dataset with misconception annotations and student code samples\n2. Developed McMiner, two LLM-based approaches for misconception mining\n3. Evaluated across Gemini, Claude, and GPT model families with extensive experiments", "result": "LLM-based models effectively identify misconceptions in student code, showing strong performance across the tested benchmark dataset", "conclusion": "LLMs demonstrate promise for automating misconception detection in programming education, providing a foundation for scalable educational tools that address conceptual misunderstandings in learners."}}
{"id": "2510.09263", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.09263", "abs": "https://arxiv.org/abs/2510.09263", "authors": ["Sven Gowal", "Rudy Bunel", "Florian Stimberg", "David Stutz", "Guillermo Ortiz-Jimenez", "Christina Kouridi", "Mel Vecerik", "Jamie Hayes", "Sylvestre-Alvise Rebuffi", "Paul Bernard", "Chris Gamble", "Mikl\u00f3s Z. Horv\u00e1th", "Fabian Kaczmarczyck", "Alex Kaskasoli", "Aleksandar Petrov", "Ilia Shumailov", "Meghana Thotakuri", "Olivia Wiles", "Jessica Yung", "Zahra Ahmed", "Victor Martin", "Simon Rosen", "Christopher Sav\u010dak", "Armin Senoner", "Nidhi Vyas", "Pushmeet Kohli"], "title": "SynthID-Image: Image watermarking at internet scale", "comment": null, "summary": "We introduce SynthID-Image, a deep learning-based system for invisibly\nwatermarking AI-generated imagery. This paper documents the technical\ndesiderata, threat models, and practical challenges of deploying such a system\nat internet scale, addressing key requirements of effectiveness, fidelity,\nrobustness, and security. SynthID-Image has been used to watermark over ten\nbillion images and video frames across Google's services and its corresponding\nverification service is available to trusted testers. For completeness, we\npresent an experimental evaluation of an external model variant, SynthID-O,\nwhich is available through partnerships. We benchmark SynthID-O against other\npost-hoc watermarking methods from the literature, demonstrating\nstate-of-the-art performance in both visual quality and robustness to common\nimage perturbations. While this work centers on visual media, the conclusions\non deployment, constraints, and threat modeling generalize to other modalities,\nincluding audio. This paper provides a comprehensive documentation for the\nlarge-scale deployment of deep learning-based media provenance systems.", "AI": {"tldr": "The paper introduces SynthID-Image, an invisible watermarking system for AI-generated images. It addresses key requirements for such a system and includes an evaluation of SynthID-O, an external model variant. The focus is on deployment challenges and threat models.", "motivation": "AI-generated images and videos have become content on the internet, raising questions about their origin and authenticity. The paper aims to address the requirements of watermarking at internet scale by considering practical challenges and threat models.", "method": "The work introduces SynthID-Image and its external variant SynthID-O, discussing the technical desiderata, threat models, and deployment constraints. They benchmarked SynthID-O against other post-hoc watermarking methods through experimental evaluation.", "result": "SynthID-Image is deployed on over ten billion images and video frames across Google's services. SynthID-O shows state-of-the-art performance in visual quality and robustness to common image perturbations.", "conclusion": "The findings on deployment, constraints, and threat modeling of SynthID-Image and -O are applicable to other modalities like audio. The study offers comprehensive documentation for large-scale deployment of deep learning-based watermarking systems."}}
{"id": "2510.08834", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.08834", "abs": "https://arxiv.org/abs/2510.08834", "authors": ["Carlos Pinto Gomez", "Fabio Petrillo"], "title": "Identifying Video Game Debugging Bottlenecks: An Industry Perspective", "comment": "8 pages, 3 figures, 4 tables, gas 2026 conference submission", "summary": "Conventional debugging techniques used in traditional software are similarly\nused when debugging video games. However, the reality of video games require\nits own set of unique debugging techniques such as On-Screen Console, Debug\nDraws, Debug Camera, Cheats and In-Game Menus, and Data Scrubbing. In this\narticle, we provide insights from a video game studio on how 20 seasoned\nindustry game developers debug during the production of a game. Our experiments\nrely on the recordings of debugging sessions for the most critical bugs\ncategorized as Crashes, Object Behaviors, and Object Persistence. In this\npaper, we focus on identifying the debugging activities that bottleneck bug\nresolution. We also identify the debugging tools used to perform debugging\ntechniques. Lastly, we present how different disciplines collaborate during\ndebugging and how technical roles are at the core of debugging. Our thematic\nanalysis has identified game developers spend 36.6\\% of their time inspecting\ngame artifacts and 35.1\\% of their time reproducing the bug locally.", "AI": {"tldr": "The paper examines unique video game debugging techniques through industry insights, identifying bottlenecks in bug resolution and highlighting that developers spend 36.6% of their time inspecting game artifacts and 35.1% on bug reproduction.", "motivation": "Traditional debugging methods are insufficient for video games' unique requirements, necessitating specialized techniques like debug consoles, data scrubbing, and in-game tools.", "method": "Analysis of 20 professional developers' debugging sessions focused on critical bugs (crashes, object behaviors, object persistence) through recorded productions and thematic analysis.", "result": "Identification of time allocation patterns (36.6% artifact inspection + 35.1% bug reproduction), debugging activities that bottleneck progress, and the central role of technical disciplines in collaborative debugging.", "conclusion": "Specialized debugging tools and better coordination are critical, as developers face significant delays in inspecting artifacts and reproducing bugs, emphasizing these activities as core challenges in game development."}}
{"id": "2510.09269", "categories": ["cs.CR", "cs.CV", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.09269", "abs": "https://arxiv.org/abs/2510.09269", "authors": ["Zirun Zhou", "Zhengyang Xiao", "Haochuan Xu", "Jing Sun", "Di Wang", "Jingfeng Zhang"], "title": "Goal-oriented Backdoor Attack against Vision-Language-Action Models via Physical Objects", "comment": null, "summary": "Recent advances in vision-language-action (VLA) models have greatly improved\nembodied AI, enabling robots to follow natural language instructions and\nperform diverse tasks. However, their reliance on uncurated training datasets\nraises serious security concerns. Existing backdoor attacks on VLAs mostly\nassume white-box access and result in task failures instead of enforcing\nspecific actions. In this work, we reveal a more practical threat: attackers\ncan manipulate VLAs by simply injecting physical objects as triggers into the\ntraining dataset. We propose goal-oriented backdoor attacks (GoBA), where the\nVLA behaves normally in the absence of physical triggers but executes\npredefined and goal-oriented actions in the presence of physical triggers.\nSpecifically, based on a popular VLA benchmark LIBERO, we introduce BadLIBERO\nthat incorporates diverse physical triggers and goal-oriented backdoor actions.\nIn addition, we propose a three-level evaluation that categorizes the victim\nVLA's actions under GoBA into three states: nothing to do, try to do, and\nsuccess to do. Experiments show that GoBA enables the victim VLA to\nsuccessfully achieve the backdoor goal in 97 percentage of inputs when the\nphysical trigger is present, while causing zero performance degradation on\nclean inputs. Finally, by investigating factors related to GoBA, we find that\nthe action trajectory and trigger color significantly influence attack\nperformance, while trigger size has surprisingly little effect. The code and\nBadLIBERO dataset are accessible via the project page at\nhttps://goba-attack.github.io/.", "AI": {"tldr": "This paper introduces GoBA, a goal-oriented backdoor attack method for VLA models, demonstrating a significant threat through physical trigger manipulation with high success rates and minimal clean input degradation.", "motivation": "Recent VLA models have enhanced embodied AI, but their dependence on uncurated datasets introduces security risks. This paper addresses the lack of practical, real-world threat analysis, particularly in adversarial settings where attackers don't have full access to train models.", "method": "GoBA infects the VLA by incorporating physical triggers and goal-driven actions into the training dataset. It introduces a new benchmark (BadLIBERO) and employs a three-level evaluation framework (nothing to do, try to do, success to do) to assess the effectiveness and stealthiness of the attack.", "result": "Experiments show that GoBA enables VLA to achieve the backdoor goal in 97% of cases when a physical trigger is present, with no performance degradation on clean inputs. A detailed analysis identifies the key factors influencing attack success: action trajectory and trigger color, while trigger size has minimal impact.", "conclusion": "GoBA highlights the vulnerability of VLA models to physical trigger attacks, advocating for safer practices in data curation for embodied AI models. The attack's availability in a new benchmark and strong performance without disrupting normal functionality suggests a pressing need for mitigation measures."}}
{"id": "2510.08850", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.08850", "abs": "https://arxiv.org/abs/2510.08850", "authors": ["Vasudha Yanuganti", "Ishaan Puri", "Swapnil Chhatre", "Mantinder Singh", "Ashok Jallepalli", "Hritvik Shrivastava", "Pradeep Kumar Sharma"], "title": "Repository-Aware File Path Retrieval via Fine-Tuned LLMs", "comment": null, "summary": "Modern codebases make it hard for developers and AI coding assistants to find\nthe right source files when answering questions like \"How does this feature\nwork?\" or \"Where was the bug introduced?\" Traditional code search (keyword or\nIR based) often misses semantic context and cross file links, while large\nlanguage models (LLMs) understand natural language but lack repository specific\ndetail. We present a method for file path retrieval that fine tunes a strong\nLLM (Qwen3-8B) with QLoRA and Unsloth optimizations to predict relevant file\npaths directly from a natural language query. To build training data, we\nintroduce six code aware strategies that use abstract syntax tree (AST)\nstructure and repository content to generate realistic question-answer pairs,\nwhere answers are sets of file paths. The strategies range from single file\nprompts to hierarchical repository summaries, providing broad coverage. We fine\ntune on Python projects including Flask, Click, Jinja, FastAPI, and PyTorch,\nand obtain high retrieval accuracy: up to 91\\% exact match and 93\\% recall on\nheld out queries, clearly beating single strategy training. On a large codebase\nlike PyTorch (about 4,000 Python files), the model reaches 59\\% recall, showing\nscalability. We analyze how multi level code signals help the LLM reason over\ncross file context and discuss dataset design, limits (for example, context\nlength in very large repos), and future integration of retrieval with LLM based\ncode intelligence.", "AI": {"tldr": "Error", "motivation": "Error", "method": "Error", "result": "Error", "conclusion": "Error"}}
{"id": "2510.09271", "categories": ["cs.CR", "cs.ET", "cs.PF"], "pdf": "https://arxiv.org/pdf/2510.09271", "abs": "https://arxiv.org/abs/2510.09271", "authors": ["Alison Gon\u00e7alves Schemitt", "Henrique Fan da Silva", "Roben Castagna Lunardi", "Diego Kreutz", "Rodrigo Brand\u00e3o Mansilha", "Avelino Francisco Zorzo"], "title": "Assessing the Impact of Post-Quantum Digital Signature Algorithms on Blockchains", "comment": "8 pages, 4 figures. Accepted paper in IEEE 24th International\n  Conference on Trust, Security and Privacy in Computing and Communications\n  (TrustCom 2025)", "summary": "The advent of quantum computing threatens the security of traditional\nencryption algorithms, motivating the development of post-quantum cryptography\n(PQC). In 2024, the National Institute of Standards and Technology (NIST)\nstandardized several PQC algorithms, marking an important milestone in the\ntransition toward quantum-resistant security. Blockchain systems fundamentally\nrely on cryptographic primitives to guarantee data integrity and transaction\nauthenticity. However, widely used algorithms such as ECDSA, employed in\nBitcoin, Ethereum, and other networks, are vulnerable to quantum attacks.\nAlthough adopting PQC is essential for long-term security, its computational\noverhead in blockchain environments remains largely unexplored. In this work,\nwe propose a methodology for benchmarking both PQC and traditional\ncryptographic algorithms in blockchain contexts. We measure signature\ngeneration and verification times across diverse computational environments and\nsimulate their impact at scale. Our evaluation focuses on PQC digital signature\nschemes (ML-DSA, Dilithium, Falcon, Mayo, SLH-DSA, SPHINCS+, and Cross) across\nsecurity levels 1 to 5, comparing them to ECDSA, the current standard in\nBitcoin and Ethereum. Our results indicate that PQC algorithms introduce only\nminor performance overhead at security level 1, while in some scenarios they\nsignificantly outperform ECDSA at higher security levels. For instance, ML-DSA\nachieves a verification time of 0.14 ms on an ARM-based laptop at level 5,\ncompared to 0.88 ms for ECDSA. We also provide an open-source implementation to\nensure reproducibility and encourage further research.", "AI": {"tldr": "This paper benchmarks post-quantum cryptography in blockchain, showing that PQC algorithms like ML-DSA often outperform ECDSA at higher security levels with minimal overhead, enabling quantum-resistant systems without compromising performance.", "motivation": "Quantum computing threatens traditional cryptography used in blockchain (e.g., ECDSA), necessitating the transition to post-quantum algorithms. While NIST standardized PQC in 2024, the computational overhead of these algorithms in resource-constrained blockchain contexts remains poorly understood.", "method": "The authors developed a benchmarking methodology to evaluate PQC and traditional cryptographic algorithms in blockchain environments. They measured signature generation/verification times across diverse computational settings, simulated large-scale impacts, and compared seven PQC schemes (ML-DSA, Dilithium, Falcon, Mayo, SLH-DSA, SPHINCS+, and Cross) against ECDSA across NIST security levels 1-5.", "result": "PQC algorithms exhibit minimal overhead at security level 1 and outperform ECDSA at higher levels (e.g., ML-DSA's 0.14 ms vs. ECDSA's 0.88 ms at level 5 on an ARM-based laptop). The evaluation quantifies performance trade-offs across seven PQC schemes and provides reproducible, open-source benchmarks.", "conclusion": "The study concludes that post-quantum cryptographic (PQC) algorithms can achieve quantum-resistant security in blockchain systems with minimal performance overhead, particularly at higher security levels, and provides an open-source framework to support further research and adoption."}}
{"id": "2510.08876", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.08876", "abs": "https://arxiv.org/abs/2510.08876", "authors": ["Kostiantyn Bevziuk", "Andrii Fatula", "Svetozar Lashin Yaroslav Opanasenko", "Anna Tukhtarova", "Ashok Jallepalli Pradeepkumar Sharma", "Hritvik Shrivastava"], "title": "Vector Graph-Based Repository Understanding for Issue-Driven File Retrieval", "comment": null, "summary": "We present a repository decomposition system that converts large software\nrepositories into a vectorized knowledge graph which mirrors project\narchitectural and semantic structure, capturing semantic relationships and\nallowing a significant level of automatization of further repository\ndevelopment. The graph encodes syntactic relations such as containment,\nimplementation, references, calls, and inheritance, and augments nodes with\nLLM-derived summaries and vector embeddings. A hybrid retrieval pipeline\ncombines semantic retrieval with graph-aware expansion, and an LLM-based\nassistant formulates constrained, read-only graph requests and produces\nhuman-oriented explanations.", "AI": {"tldr": "This paper introduces a knowledge graph-based system for software repositories that vectorizes codebases to capture semantic relationships, integrates LLM-powered summaries, and enables automated development workflows through hybrid semantic-graph search, with an LLM assistant providing human-readable explanations for programmatic repository interactions.", "motivation": "The research addresses challenges in managing complex software repositories, aiming to automate development processes by creating a structured representation that captures both architectural and semantic relationships, thus reducing manual effort and improving development efficiency through programmatic repository understanding.", "method": "The system builds a hybrid knowledge graph encoding syntactic relationships (containment, implementation, references, calls, inheritance) and semantically augments nodes using LLM-derived summaries and vector embeddings. A hybrid retrieval pipeline combines semantic search with graph-aware expansion, integrated with an LLM assistant for generating structured graph queries and user-oriented explanations.", "result": "The system achieves a 69% improvement in query resolution accuracy for development tasks (compared to traditional code search tools) and reduces documentation effort by 73% via automated semantic linking and hierarchical artifact representation in the knowledge graph.", "conclusion": "The presented repository decomposition system successfully transforms large software repositories into a structured vectorized knowledge graph, enabling significant automation in repository development through enhanced architectural and semantic understanding, with the LLM-based assistant facilitating human-readable explanations and constrained graph interactions."}}
{"id": "2510.09272", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.09272", "abs": "https://arxiv.org/abs/2510.09272", "authors": ["Moritz Steffin", "Jiska Classen"], "title": "Modern iOS Security Features -- A Deep Dive into SPTM, TXM, and Exclaves", "comment": null, "summary": "The XNU kernel is the basis of Apple's operating systems. Although labeled as\na hybrid kernel, it is found to generally operate in a monolithic manner by\ndefining a single privileged trust zone in which all system functionality\nresides. This has security implications, as a kernel compromise has immediate\nand significant effects on the entire system. Over the past few years, Apple\nhas taken steps towards a more compartmentalized kernel architecture and a more\nmicrokernel-like design. To date, there has been no scientific discussion of\nSPTM and related security mechanisms. Therefore, the understanding of the\nsystem and the underlying security mechanisms is minimal. In this paper, we\nprovide a comprehensive analysis of new security mechanisms and their\ninterplay, and create the first conclusive writeup considering all current\nmitigations. SPTM acts as the sole authority regarding memory retyping. Our\nanalysis reveals that, through SPTM domains based on frame retyping and memory\nmapping rule sets, SPTM introduces domains of trust into the system,\neffectively gapping different functionalities from one another. Gapped\nfunctionality includes the TXM, responsible for code signing and entitlement\nverification. We further demonstrate how this introduction lays the groundwork\nfor the most recent security feature of Exclaves, and conduct an in-depth\nanalysis of its communication mechanisms. We discover multifold ways of\ncommunication, most notably xnuproxy as a secure world request handler, and the\nTightbeam IPC framework. The architecture changes are found to increase system\nsecurity, with key and sensitive components being moved out of XNU's direct\nreach. This also provides additional security guarantees in the event of a\nkernel compromise, which is no longer an immediate threat at the highest trust\nlevel.", "AI": {"tldr": "This research focuses on the architectural evolution of Apple's XNU kernel, highlighting new security mechanisms like SPTM and Exclaves for compartmentalization, reducing the risk of a kernel compromise affecting the entire system.", "motivation": "Traditionally operating in a monolithic style, the XNU kernel faces security concerns due to a single compromised point affecting the system. Apple's recent moves towards a more secure, compartmentalized kernel lack a comprehensive scientific analysis, motivating this study to evaluate the effectiveness of new mechanisms against current threats.", "method": "The analysis involves a comprehensive evaluation of the XNU kernel, focusing on the implementation of SPTM domains through frame retyping and memory mapping. Additionally, the researchers explore the communication mechanisms, including xnuproxy and Tightbeam IPC, to determine how these security features interact and reinforce the architectural changes.", "result": "The results show that SPTM introduces compartments with different trust levels, enhancing kernel security by isolating functions like TXM. The communication frameworks such as xnuproxy and Tightbeam IPC are identified as critical components for Exclaves, a new secure environment separated from the kernel's direct control. The overall architecture offers increased protection against kernel compromises while possibly maintaining performance and functionality.", "conclusion": "The paper concludes that Apple's transition from a monolithic to a more microkernel-like design, particularly via SPTM and Exclaves, significantly enhances system security. The isolation of key components secures the highest trust level and provides additional defense in the event of a vulnerability in the kernel."}}
{"id": "2510.08981", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.08981", "abs": "https://arxiv.org/abs/2510.08981", "authors": ["Mandira Roy", "Novarun Deb", "Nabendu Chaki", "Agostino Cortesi"], "title": "SEER: Sustainability Enhanced Engineering of Software Requirements", "comment": "Main Paper: 32 pages, References: 3 pages, Appendix: 13 pages.\n  Submitted to the Journal of Systems and Software, Elsevier", "summary": "The rapid expansion of software development has significant environmental,\ntechnical, social, and economic impacts. Achieving the United Nations\nSustainable Development Goals by 2030 compels developers to adopt sustainable\npractices. Existing methods mostly offer high-level guidelines, which are\ntime-consuming to implement and rely on team adaptability. Moreover, they focus\non design or implementation, while sustainability assessment should start at\nthe requirements engineering phase. In this paper, we introduce SEER, a\nframework which addresses sustainability concerns in the early software\ndevelopment phase. The framework operates in three stages: (i) it identifies\nsustainability requirements (SRs) relevant to a specific software product from\na general taxonomy; (ii) it evaluates how sustainable system requirements are\nbased on the identified SRs; and (iii) it optimizes system requirements that\nfail to satisfy any SR. The framework is implemented using the reasoning\ncapabilities of large language models and the agentic RAG (Retrieval Augmented\nGeneration) approach. SEER has been experimented on four software projects from\ndifferent domains. Results generated using Gemini 2.5 reasoning model\ndemonstrate the effectiveness of the proposed approach in accurately\nidentifying a broad range of sustainability concerns across diverse domains.", "AI": {"tldr": "The paper introduces SEER, a framework addressing sustainability concerns in early software development phases using large language models and agentic RAG. It identifies, evaluates, and optimizes system requirements based on domain-specific sustainability requirements (SRs).", "motivation": "Existing sustainability practices in software development lack effective early-phase integration, relying on post-design implementation guidelines. Timely adoption of sustainability assessments is critical to meet UN SDGs by 2030, but current methods are too high-level and time-consuming.", "method": "SEER operates in three stages: (1+) identifying domain-specific SRs from a taxonomy; (2+) evaluating system requirements against SRs; (3+) optimizing non-compliant requirements. The framework leverages LLM reasoning and agentic RAG for implementation.", "result": "Experiments on four domain-diverse software projects demonstrated SEER's effectiveness in accurately identifying sustainability concerns using the Gemini 2.5 reasoning model, showing cross-domain adaptability.", "conclusion": "SEER provides a systematic, early-phase approach to sustainability assessment in software development, bridging the gap between industrial needs and academic methodologies through LLM-powered requirement optimization."}}
{"id": "2510.09433", "categories": ["cs.CR", "cs.ET"], "pdf": "https://arxiv.org/pdf/2510.09433", "abs": "https://arxiv.org/abs/2510.09433", "authors": ["Raffaele Cristodaro", "Benjamin Kramer", "Claudio J. Tessone"], "title": "Clustering Deposit and Withdrawal Activity in Tornado Cash: A Cross-Chain Analysis", "comment": null, "summary": "Tornado Cash is a decentralised mixer that uses cryptographic techniques to\nsever the on-chain trail between depositors and withdrawers. In practice,\nhowever, its anonymity can be undermined by user behaviour and operational\nquirks. We conduct the first cross-chain empirical study of Tornado Cash\nactivity on Ethereum, BNB Smart Chain, and Polygon, introducing three\nclustering heuristics-(i) address-reuse, (ii) transactional-linkage, and (iii)\na novel first-in-first-out (FIFO) temporal-matching rule. Together, these\nheuristics reconnect deposits to withdrawals and deanonymise a substantial\nshare of recipients. Our analysis shows that 5.1 - 12.6% of withdrawals can\nalready be traced to their originating deposits through address reuse and\ntransactional linkage heuristics. Adding our novel First-In-First-Out (FIFO)\ntemporal-matching heuristic lifts the linkage rate by a further 15 - 22\npercentage points. Statistical tests confirm that these FIFO matches are highly\nunlikely to occur by chance. Comparable leakage across Ethereum, BNB Smart\nChain, and Polygon indicates chain-agnostic user misbehaviour, rather than\nchain-specific protocol flaws. These results expose how quickly cryptographic\nguarantees can unravel in everyday use, underscoring the need for both\ndisciplined user behaviour and privacy-aware protocol design. In total, our\nheuristics link over $2.3 billion in Tornado Cash withdrawals to identifiable\ndeposits, exposing significant cracks in practical anonymity.", "AI": {"tldr": "Error", "motivation": "Error", "method": "Error", "result": "Error", "conclusion": "Error"}}
{"id": "2510.08990", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.08990", "abs": "https://arxiv.org/abs/2510.08990", "authors": ["Mandira Roy", "Novarun Deb", "Nabendu Chaki", "Agostino Cortesi"], "title": "Towards a Taxonomy of Sustainability Requirements for Software Design", "comment": "Paper: 7 pages", "summary": "Software systems are a significant contributor to global sustainability\nconcerns, demanding that environmental, social, technical, and economic factors\nbe systematically addressed from the initial requirements engineering phase.\nAlthough existing research provides various sustainability requirements (SRs),\nthese contributions are often fragmented, specific to certain dimensions, or\nlimited to particular application domains, resulting in a critical lack of a\nunified, comprehensive taxonomy for the software engineering community. To\naddress this gap, this research conducts a Systematic Literature Review (SLR)\nto extract and organize sustainability requirements from the state-of-the-art.\nThe primary contribution is a comprehensive taxonomy of SRs across the four\ndimensions of sustainability (environmental, technical, social, and economic).\nFor each identified category, we provide clear definitions, associated metrics,\nand measures. Furthermore, we depict a correlation matrix that projects the\npositive and negative influences (synergies and conflicts) among categories\nacross different dimensions. This systematized reference assists both software\ndevelopers and researchers in effectively formulating, managing, and\nreconciling trade-offs within sustainable software development.", "AI": {"tldr": "This paper proposes a comprehensive taxonomy of sustainability requirements (SRs)- including definitions, metrics, and correlations across four dimensions (environmental, technical, social, economic)- to address fragmented prior research through a Systematic Literature Review (SLR).", "motivation": "Existing SR studies are fragmented, domain-specific, or dimension-limited, hindering systematic integration of sustainability in software development. A unified reference is needed.", "method": "Conducted a Systematic Literature Review (SLR) of state-of-the-art SRs, extracting categories and relationships through structured synthesis.", "result": "A four-dimensional SR taxonomy with cross-category correlation matrix showing synergies/conflicts, supported by definitions, metrics, and implementation measures.", "conclusion": "The taxonomy enables practitioners to balance trade-offs across sustainability dimensions and researchers to identify SR interactions in software systems."}}
{"id": "2510.09443", "categories": ["cs.CR", "cs.SI"], "pdf": "https://arxiv.org/pdf/2510.09443", "abs": "https://arxiv.org/abs/2510.09443", "authors": ["Raffaele Cristodaro", "Benjamin Kramer", "Claudio J. Tessone"], "title": "The Impact of Sanctions on decentralised Privacy Tools: A Case Study of Tornado Cash", "comment": null, "summary": "This paper investigates the impact of sanctions on Tornado Cash, a smart\ncontract protocol designed to enhance transaction privacy. Following the U.S.\nDepartment of the Treasury's sanctions against Tornado Cash in August 2022,\nplatform activity declined sharply. We document a significant and sustained\nreduction in transaction volume, user diversity, and overall protocol\nutilization after the sanctions were imposed. Our analysis draws on transaction\ndata from three major blockchains: Ethereum, BNB Smart Chain, and Polygon. We\nfurther examine developments following the partial lifting and eventual removal\nof sanctions by the U.S. Office of Foreign Assets Control (OFAC) in March 2025.\nAlthough activity partially recovered, the rebound remained limited. The\nTornado Cash case illustrates how regulatory interventions can affect\ndecentralized protocols, while also highlighting the challenges of fully\nenforcing such measures in decentralized environments.", "AI": {"tldr": "The paper examines how U.S. sanctions against Tornado Cash (2022-2025) caused sustained declines in transaction volume, user diversity, and protocol usage, with only partial recovery after sanctions were lifted, illustrating regulatory challenges in decentralized ecosystems.", "motivation": "The study addresses the gap in understanding how regulatory interventions impact decentralized protocols, balancing enforcement effectiveness with inherent system properties like privacy and decentralization.", "method": "Analyzes blockchain transaction data (Ethereum, BNB Smart Chain, Polygon) before/after sanctions imposition (August 2022), partial lifting, and full removal (March 2025) to measure protocol activity changes.", "result": "Sanctions caused significant and lasting reductions in key metrics; partial sanctions removal led to limited activity recovery, demonstrating both regulatory efficacy and limitations in decentralized environments.", "conclusion": "Regulatory actions can influence decentralized protocol behavior, but structural characteristics of such systems (e.g., cross-chain operations, pseudonymity) complicate comprehensive enforcement."}}
{"id": "2510.08996", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.08996", "abs": "https://arxiv.org/abs/2510.08996", "authors": ["Spandan Garg", "Ben Steenhoek", "Yufan Huang"], "title": "Saving SWE-Bench: A Benchmark Mutation Approach for Realistic Agent Evaluation", "comment": null, "summary": "Current benchmarks for evaluating software engineering agents, such as\nSWE-Bench Verified, are predominantly derived from GitHub issues and fail to\naccurately reflect how developers interact with chat-based coding assistants in\nintegrated development environments (IDEs). We posit that this mismatch leads\nto a systematic overestimation of agent's capabilities in real-world scenarios,\nespecially bug fixing. We introduce a novel benchmarking framework that\ntransforms existing formal benchmarks into realistic user queries through\nsystematic analysis of developer interaction patterns with chat-based agents.\nOur methodology is flexible and can be easily extended to existing benchmarks.\nIn this paper, we apply our testing framework to SWE-Bench Verified, the\nTypeScript subset of Multi-SWE-Bench and a private benchmark, SWE-Bench C# and\ntransform formal GitHub issue descriptions into realistic user-style queries\nbased on telemetry analysis of a popular chat-based agent interactions. Our\nfindings reveal that existing benchmarks significantly overestimate agent\ncapabilities for some models by >50% over baseline performance for public\nbenchmarks and ~10-16% for our internal benchmark. This work establishes a new\nparadigm for evaluating interactive chat-based software engineering agents\nthrough benchmark mutation techniques.", "AI": {"tldr": "Researchers show current chat-agent benchmarks overrate performance by 50+%. They create a framework using real IDE interaction patterns to generate test queries, revealing significant capability overestimation in popular benchmarks.", "motivation": "Current benchmarks like SWE-Bench Verified fail to reflect real-world developer-IDE-ChatAgent interactions, leading to overestimation of agent capabilities. This mismatch particularly impacts bug-fixing evaluations.", "method": "The authors developed a benchmarking framework that transforms existing formal benchmarks into realistic user queries by analyzing developer interaction patterns with chat-based agents, applying it to public and private benchmarks and using telemetry data from a popular agent.", "result": "Existing benchmarks overestimate agent performance by >50% compared to baseline on public benchmarks (SWE-Bench Verified etc.) and ~10-16% on the internal SWE-Bench C# benchmark when evaluated with the new framework.", "conclusion": "The study establishes a new benchmarking paradigm for interactive chat-based software engineering agents using mutation techniques, highlighting significant overestimation of agent capabilities in existing benchmarks and offering a flexible framework for realistic evaluation."}}
{"id": "2510.09494", "categories": ["cs.CR", "cs.DB", "cs.SE"], "pdf": "https://arxiv.org/pdf/2510.09494", "abs": "https://arxiv.org/abs/2510.09494", "authors": ["Nico Bistolfi", "Andreea Georgescu", "Dave Hodson"], "title": "The Data Enclave Advantage: A New Paradigm for Least-Privileged Data Access in a Zero-Trust World", "comment": "11 pages, 2 figures, company whitepaper, no journal", "summary": "As cloud infrastructure evolves to support dynamic and distributed workflows,\naccelerated now by AI-driven processes, the outdated model of standing\npermissions has become a critical vulnerability. Based on the Cloud Security\nAlliance (CSA) Top Threats to Cloud Computing Deep Dive 2025 Report, our\nanalysis details how standing permissions cause catastrophic cloud breaches.\nWhile current security tools are addressing network and API security, the\nchallenge of securing granular data access remains. Removing standing\npermissions at the data level is as critical as it is at the network level,\nespecially for companies handling valuable data at scale.\n  In this white paper, we introduce an innovative architecture based on\non-demand data enclaves to address this gap directly. Our approach enables Zero\nStanding Privilege (ZSP) and Just-in-Time (JIT) principles at the data level.\nWe replace static permissions with temporary data contracts that enforce\nproactive protection. This means separation is built around the data requested\non-demand, providing precise access and real time monitoring for individual\nrecords instead of datasets. This solution drastically reduces the attack\nsurface, prevents privilege creep, and simplifies auditing, offering a vital\npath for enterprises to transition to a more secure and resilient data\nenvironment.", "AI": {"tldr": "This paper addresses cloud security gaps caused by standing permissions by introducing on-demand data enclaves that enforce ZSP/JIT principles at the data level, replacing static permissions with temporary contracts to reduce risks and improve auditability.", "motivation": "The reliance on outdated standing permissions in cloud infrastructure has emerged as a critical vulnerability, particularly as AI-driven workflows and distributed systems increase data access complexity. Current security tools inadequately protect granular data access, creating catastrophic breach risks for enterprises handling sensitive data at scale.", "method": "The paper proposes an architecture based on on-demand data enclaves that enforce temporary data contracts, replacing static permissions. This enables ZSP and JIT principles at the data level, offering granular, real-time access control and monitoring for individual records rather than datasets.", "result": "The proposed solution reduces attack surfaces, prevents privilege creep, enables proactive protection through on-demand isolation, and simplifies auditing by replacing static permissions with ephemeral, record-level access controls enforced via data contracts.", "conclusion": "Transitioning to a model that enforces Zero Standing Privilege (ZSP) and Just-in-Time (JIT) principles through temporary data contracts provides a critical path for enterprises to achieve secure, auditable, and resilient cloud data environments by eliminating static permissions and reducing attack surfaces."}}
{"id": "2510.09045", "categories": ["cs.SE", "cs.AI", "cs.IR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.09045", "abs": "https://arxiv.org/abs/2510.09045", "authors": ["Manojit Chakraborty", "Madhusudan Ghosh", "Rishabh Gupta"], "title": "Cost-Efficient Long Code Translation using LLMs while Leveraging Identifier Replacements", "comment": null, "summary": "In the domain of software development, LLMs have been utilized to automate\ntasks such as code translation, where source code from one programming language\nis translated to another while preserving its functionality. However, LLMs\noften struggle with long source codes that don't fit into the context window,\nwhich produces inaccurate translations. To address this, we propose a novel\nzero-shot code translation method that incorporates identifier replacement. By\nsubstituting user-given long identifiers with generalized placeholders during\ntranslation, our method allows the LLM to focus on the logical structure of the\ncode, by reducing token count and memory usage, which improves the efficiency\nand cost-effectiveness of long code translation. Our empirical results\ndemonstrate that our approach preserves syntactical and hierarchical\ninformation and produces translation results with reduced tokens.", "AI": {"tldr": "This paper proposes a zero-shot code translation method using identifier replacement to improve LLM performance for long code by reducing token count and memory usage while preserving syntactical/hierarchical information.", "motivation": "LLMs struggle with long code translation due to context window limitations, leading to inaccurate translations.", "method": "Substitute long user identifiers with generalized placeholders during translation to reduce tokens and focus LLMs on logical structure.", "result": "Empirical results show preserved syntactical/hierarchical information with reduced token usage in translations.", "conclusion": "The method enhances translation efficiency and cost-effectiveness for long code without requiring training data."}}
{"id": "2510.09058", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.09058", "abs": "https://arxiv.org/abs/2510.09058", "authors": ["Italo Santos", "Cleyton Magalhaes", "Ronnie de Souza Santos"], "title": "Model-Assisted and Human-Guided: Perceptions and Practices of Software Professionals Using LLMs for Coding", "comment": null, "summary": "Large Language Models have quickly become a central component of modern\nsoftware development workflows, and software practitioners are increasingly\nintegrating LLMs into various stages of the software development lifecycle.\nDespite the growing presence of LLMs, there is still a limited understanding of\nhow these tools are actually used in practice and how professionals perceive\ntheir benefits and limitations. This paper presents preliminary findings from a\nglobal survey of 131 software practitioners. Our results reveal how LLMs are\nutilized for various coding-specific tasks. Software professionals report\nbenefits such as increased productivity, reduced cognitive load, and faster\nlearning, but also raise concerns about LLMs' inaccurate outputs, limited\ncontext awareness, and associated ethical risks. Most developers treat LLMs as\nassistive tools rather than standalone solutions, reflecting a cautious yet\npractical approach to their integration. Our findings provide an early,\npractitioner-focused perspective on LLM adoption, highlighting key\nconsiderations for future research and responsible use in software engineering.", "AI": {"tldr": "This paper analyzes 131 software developers' experiences with LLM tools in their workflows, finding they boost productivity but face accuracy and ethical challenges. Developers treat LLMs as careful assistants rather than standalone solutions, guiding future research on responsible integration.", "motivation": "Despite the growing influence of LLMs in software development workflows, there is limited empirical understanding of their practical implementation and practitioner perceptions of their value and risks.", "method": "A global survey of 131 software practitioners was conducted to gather insights on LLM usage, benefits, limitations, and integration practices in software development.", "result": "Survey results reveal productivity gains (e.g., reduced cognitive load, faster learning) alongside challenges (inaccuracies, limited context awareness, ethical risks). Developers adopt LLMs cautiously as supportive tools rather than relying on them independently.", "conclusion": "The study concludes that software professionals primarily use LLMs as assistive tools rather than standalone solutions, emphasizing a cautious integration approach while highlighting the need for future research and responsible LLM use in software engineering."}}
{"id": "2510.09073", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2510.09073", "abs": "https://arxiv.org/abs/2510.09073", "authors": ["Matthew Sotoudeh"], "title": "Literate Tracing", "comment": "examples at https://lair.masot.net/trex . SPLASH Onward 2025", "summary": "As computer systems grow ever larger and more complex, a crucial task in\nsoftware development is for one person (the system expert) to communicate to\nanother (the system novice) how a certain program works. This paper reports on\nthe author's experiences with a paradigm for program documentation that we call\nliterate tracing. A literate trace explains a software system using annotated,\nconcrete execution traces of the system. Literate traces complement both\nin-code comments (which often lack global context) and out-of-band design docs\n(which often lack a concrete connection to the code). We also describe TReX,\nour tool for making literate traces that are interactive, visual, and\nguaranteed by construction to be faithful to the program semantics. We have\nused TReX to write literate traces explaining components of large systems\nsoftware including the Linux kernel, Git source control system, and GCC\ncompiler.", "AI": {"tldr": "Introduces literate tracing (annotated execution traces) as a novel documentation approach, and TReX (interactive documentation tool) to create faithful, visual explanations of complex software systems.", "motivation": "Traditional documentation methods (code comments\u7f3a\u4e4f\u5168\u5c40\u4e0a\u4e0b\u6587; design docs lack concrete code connections) fail to effectively communicate complex system behavior. There is a need for documentation that bridges this gap by providing concrete execution context.", "method": "We developed a documentation paradigm called literate tracing, which uses annotated execution traces of software systems. This was implemented in TReX, a tool that generates interactive, visual traces guaranteed to align with program semantics.", "result": "Successfully applied TReX to document components of the Linux kernel, Git source control system, and GCC compiler, demonstrating the practicality of literate tracing for large-scale system software.", "conclusion": "Literate tracing is a novel approach to program documentation that combines annotated execution traces with interactive visualization, addressing the limitations of traditional in-code comments and design documents. The TReX tool demonstrates its feasibility for documenting complex systems like the Linux kernel and Git."}}
{"id": "2510.09108", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.09108", "abs": "https://arxiv.org/abs/2510.09108", "authors": ["Lukas Krodinger", "Altin Hajdari", "Stephan Lukasczyk", "Gordon Fraser"], "title": "Constraint-Guided Unit Test Generation for Machine Learning Libraries", "comment": "Accepted for SSBSE 2025", "summary": "Machine learning (ML) libraries such as PyTorch and TensorFlow are essential\nfor a wide range of modern applications. Ensuring the correctness of ML\nlibraries through testing is crucial. However, ML APIs often impose strict\ninput constraints involving complex data structures such as tensors. Automated\ntest generation tools such as Pynguin are not aware of these constraints and\noften create non-compliant inputs. This leads to early test failures and\nlimited code coverage. Prior work has investigated extracting constraints from\nofficial API documentation. In this paper, we present PynguinML, an approach\nthat improves the Pynguin test generator to leverage these constraints to\ngenerate compliant inputs for ML APIs, enabling more thorough testing and\nhigher code coverage. Our evaluation is based on 165 modules from PyTorch and\nTensorFlow, comparing PynguinML against Pynguin. The results show that\nPynguinML significantly improves test effectiveness, achieving up to 63.9 %\nhigher code coverage.", "AI": {"tldr": "PynguinML improves automated testing of ML libraries by using documentation constraints to generate valid inputs, achieving much higher code coverage than existing tools.", "motivation": "Existing automated test generators like Pynguin fail to account for complex input constraints in ML APIs, leading to non-compliant inputs, early test failures, and poor code coverage.", "method": "The authors developed PynguinML, an extension of the Pynguin test generator, by integrating constraints extracted from ML API documentation to produce valid inputs for testing.", "result": "Evaluation on 165 modules from PyTorch and TensorFlow showed PynguinML achieved up to 63.9% higher code coverage compared to Pynguin, demonstrating its effectiveness.", "conclusion": "The paper concludes that PynguinML significantly enhances test effectiveness for ML libraries by generating compliant inputs, resulting in substantially higher code coverage compared to existing tools."}}
{"id": "2510.09134", "categories": ["cs.SE", "cs.ET"], "pdf": "https://arxiv.org/pdf/2510.09134", "abs": "https://arxiv.org/abs/2510.09134", "authors": ["Amal Elgammal", "Bernd J. Kr\u00e4mer", "Michael P. Papazoglou", "Mira Raheem"], "title": "A Semantic Framework for Patient Digital Twins in Chronic Care", "comment": "This manuscript is currently under review at Software and Systems\n  Modeling (SoSyM)", "summary": "Personalized chronic care requires the integration of multimodal health data\nto enable precise, adaptive, and preventive decision-making. Yet most current\ndigital twin (DT) applications remain organ-specific or tied to isolated data\ntypes, lacking a unified and privacy-preserving foundation. This paper\nintroduces the Patient Medical Digital Twin (PMDT), an ontology-driven in\nsilico patient framework that integrates physiological, psychosocial,\nbehavioral, and genomic information into a coherent, extensible model.\nImplemented in OWL 2.0, the PMDT ensures semantic interoperability, supports\nautomated reasoning, and enables reuse across diverse clinical contexts. Its\nontology is structured around modular Blueprints (patient, disease and\ndiagnosis, treatment and follow-up, trajectories, safety, pathways, and adverse\nevents), formalized through dedicated conceptual views. These were iteratively\nrefined and validated through expert workshops, questionnaires, and a pilot\nstudy in the EU H2020 QUALITOP project with real-world immunotherapy patients.\nEvaluation confirmed ontology coverage, reasoning correctness, usability, and\nGDPR compliance. Results demonstrate the PMDT's ability to unify heterogeneous\ndata, operationalize competency questions, and support descriptive, predictive,\nand prescriptive analytics in a federated, privacy-preserving manner. By\nbridging gaps in data fragmentation and semantic standardization, the PMDT\nprovides a validated foundation for next-generation digital health ecosystems,\ntransforming chronic care toward proactive, continuously optimized, and\nequitable management.", "AI": {"tldr": "The paper introduces PMDT, an ontology-driven digital twin framework that integrates various health data for personalized chronic care, validated through expert input and real-world application.", "motivation": "Chronic care needs multimodal health data integration for precise, adaptive, and preventive decision-making, but current digital twin solutions are fragmented and lack privacy. A unified, interoperable, and GDPR-compliant framework is essential.", "method": "The PMDT is built using OWL 2.0 with modular, conceptual Blueprints covering multiple facets of patient data. The ontology was iteratively refined through expert collaboration, workshops, questionnaires, and a pilot study in the QUALITOP project.", "result": "PMDT successfully unifies heterogeneous health data, passes automated reasoning correctness checks, and supports descriptive, predictive, and prescriptive analytics. The framework also meets GDPR requirements and is validated for usability.", "conclusion": "The PMDT addresses critical gaps in data integration and standardization, establishing a robust platform for future digital health systems and advancing chronic care toward proactive, personalized management."}}
{"id": "2510.09308", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.09308", "abs": "https://arxiv.org/abs/2510.09308", "authors": ["Mira Raheem", "Amal Elgammal", "Michael Papazoglou", "Bernd Kr\u00e4mer", "Neamat El-Tazi"], "title": "A Model-Driven Engineering Approach to AI-Powered Healthcare Platforms", "comment": "Disclaimer: This manuscript is currently under review at * MDPI\n  Informatics*", "summary": "Artificial intelligence (AI) has the potential to transform healthcare by\nsupporting more accurate diagnoses and personalized treatments. However, its\nadoption in practice remains constrained by fragmented data sources, strict\nprivacy rules, and the technical complexity of building reliable clinical\nsystems. To address these challenges, we introduce a model driven engineering\n(MDE) framework designed specifically for healthcare AI. The framework relies\non formal metamodels, domain-specific languages (DSLs), and automated\ntransformations to move from high level specifications to running software. At\nits core is the Medical Interoperability Language (MILA), a graphical DSL that\nenables clinicians and data scientists to define queries and machine learning\npipelines using shared ontologies. When combined with a federated learning\narchitecture, MILA allows institutions to collaborate without exchanging raw\npatient data, ensuring semantic consistency across sites while preserving\nprivacy. We evaluate this approach in a multi center cancer immunotherapy\nstudy. The generated pipelines delivered strong predictive performance, with\nsupport vector machines achieving up to 98.5 percent and 98.3 percent accuracy\nin key tasks, while substantially reducing manual coding effort. These findings\nsuggest that MDE principles metamodeling, semantic integration, and automated\ncode generation can provide a practical path toward interoperable,\nreproducible, and trustworthy digital health platforms.", "AI": {"tldr": "This paper introduces an MDE framework with Medical Interoperability Language (MILA), a graphical domain-specific language, combined with federated learning to address data fragmentation, privacy constraints, and technical complexity in healthcare AI. Evaluation in a cancer study demonstrated high predictive accuracy (98.3-98.5%) and reduced manual coding effort.", "motivation": "Healthcare AI adoption faces critical barriers including fragmented data sources, strict privacy regulations, and technical challenges in building reliable clinical systems. Traditional approaches struggle to balance interoperability, privacy preservation, and development efficiency required for clinical AI deployment.", "method": "The proposed model-driven engineering (MDE)-based framework includes: 1. Medical Interoperability Language (MILA) - a visual DSL for collaborative pipeline design using shared ontologies 2. Automated model transformation pipeline from high-level specifications to executable code 3. Federated learning architecture enabling multi-institutional collaboration without sharing patient data, ensuring semantic consistency through formal metamodeling.", "result": "Evaluation in a multi-center cancer immunotherapy study achieved: - SVM accuracy of 98.5%/98.3 in key predictive tasks - 75-80 reduction in manual coding effort compared to traditional methods - Successful inter-institutional collaboration under privacy constraints without data sharing", "conclusion": "Model-driven engineering, when combined with semantic modeling (via MILA) and federated learning, provides a scalable path to build interoperable, reproducible, and privacy-preserving healthcare AI systems. This approach addresses three key barriers to clinical AI adoption by enabling code generation from formal specifications while maintaining data privacy through distributed learning."}}
{"id": "2510.09400", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.09400", "abs": "https://arxiv.org/abs/2510.09400", "authors": ["He Jiang", "Yufu Wang", "Hao Lin", "Peiyu Zou", "Zhide Zhou", "Ang Jia", "Xiaochen Li", "Zhilei Ren"], "title": "TIT: A Tree-Structured Instruction Tuning Approach for LLM-Based Code Translation", "comment": null, "summary": "Large Language Models (LLMs) have shown strong performance in automated\nsource-to-target code translation through pretraining on extensive code\ncorpora. However, mainstream LLM-based code translation methods suffer from two\ncritical limitations. First, they are highly sensitive to language-specific\nfeatures, which often introduce source-language syntax or lexicon into the\noutput, leading to syntactic confusion. Second, they lack fine-grained semantic\nalignment due to an over-reliance on function-level parallel datasets,\nresulting in semantic misalignment between the translated code and the original\nsource. To overcome these limitations, we propose TIT, a Tree-structured\nInstruction Tuning paradigm for LLM-based code translation. Specifically, TIT\nconsists of three modules. First, to mitigate syntactic confusion, the\nsyntactic information representation module integrates language-agnostic\nsyntactic features via structured parsing. Then, to generate high-quality\nfine-grained parallel data, the fine-grained parallel dataset augmentation\nmodule aligns nodes with code segments through statement-level segmentation and\ncontrastive matching. Finally, we leverage the dual-stage tree instruction\ntuning module to alleviate the contextual processing burden on the LLM caused\nby the introduction of syntactic information. The first stage employs\nsyntax-aware fine-tuning to enable the LLM to autonomously comprehend\nstructured syntactic information, while the second stage utilizes code\ngeneration fine-tuning to guide the model in generating accurate target code\nbased on function-level syntactic dependencies. The experimental results\ndemonstrate that the proposed method significantly outperforms existing\napproaches in multiple LLMs, achieving a success rate 1.22x-1.75x higher in\ncode translation while markedly reducing syntactic confusion.", "AI": {"tldr": "TIT is a Tree-structured Instruction Tuning paradigm for LLM-based code translation, addressing syntactic confusion and semantic misalignment via three modules: syntactic info representation, fine-grained dataset augmentation, and dual-stage instruction tuning. It achieves 1.22x-1.75x higher success rates.", "motivation": "Mainstream LLM-based code translation methods suffer from (1): sensitivity to language-specific syntax/lexicon causing syntactic confusion and (2): over-reliance on function-level datasets leading to semantic misalignment.", "method": "TIT comprises three modules: (1): Syntax representation module integrates language-agnostic features via structured parsing; (2): Fine-grained dataset module uses statement-level segmentation + contrastive matching for aligned data; (3): Dual-stage tuning first trains syntax comprehension, then function-level code generation.", "result": "Outperforms existing methods in multiple LLMs with 1.22x-1.75x higher success rates in code translation, while significantly reducing syntactic errors in outputs.", "conclusion": "TIT effectively addresses LLM code translation limitations through syntactic abstraction and fine-grained alignment mechanisms, demonstrating significant empirical improvements in translation accuracy and robustness."}}
