{"id": "2509.25192", "categories": ["cs.SE", "68T07"], "pdf": "https://arxiv.org/pdf/2509.25192", "abs": "https://arxiv.org/abs/2509.25192", "authors": ["Anderson de Lima Luiz"], "title": "WARP -- Web-Augmented Real-time Program Repairer: A Real-Time Compilation Error Resolution using LLMs and Web-Augmented Synthesis", "comment": "5 pages, 2 figures", "summary": "Compilation errors represent a significant bottleneck in software development\nproductivity. This paper introduces WARP (Web-Augmented Real-time Program\nRepairer), a novel system that leverages Large Language Models (LLMs) and\ndynamic web-augmented synthesis for real-time resolution of these errors. WARP\nactively monitors developer terminals, intelligently detects compilation\nerrors, and synergistically combines the understanding of a fine-tuned Code-LLM\nwith relevant solutions, explanations, and code snippets retrieved from\nup-to-date web sources like developer forums and official documentation.\nExperimental results on our curated benchmark, CGP (featuring C/C++, Python,\nand Go errors), demonstrate WARP achieves a superior fix rate (72.5 % Compiles\ncorrectly) and higher semantic correctness compared to baseline LLM-only\napproaches and traditional IDE quick-fixes. Key technical challenges in\nachieving high-accuracy synthesis from noisy web data.", "AI": {"tldr": " Compilation errors are a significant productivity issue in software development. This paper introduces WARP, a real-time program repair system that combines Code-LLMs with up-to-date web sources to resolve errors efficiently. Benchmarks show WARP outperforms existing LLM-only and traditional IDE methods. Despite challenges with noisy web data, WARP is a promising solution for improving error resolution in software development.", "motivation": "Fixing compilation errors is a time-consuming part of software development, causing delays and frustration. Traditional error resolution methods, such as IDE quick-fixes or manual web searches, are often inefficient and not as accurate as required. This paper seeks to present a system that efficiently and accurately resolves these errors in real time.", "method": "WARP uses a fine-tuned Code-LLM for understanding and contextual analysis of compilation errors, alongside dynamic web-augmented code synthesis. This involves monitoring developer terminals, detecting errors, and synthesizing real-time fixes by combining the model\u2019s reasoning with up-to-date code snippets, explanations, and solutions retrieved from web sources.", "result": "On the CGP benchmark, which includes C/C++, Python, and Go errors, WARP achieved a compilation success rate of 72.5% and demonstrated higher semantic correctness compared to both LLM-only approaches and traditional IDE quick-fixes.", "conclusion": "WARP offers a more effective method for addressing compilation errors by integrating code understanding and synthesis from Code-LLMs and web sources. While challenges remain with synthesizing accurate information from noisy web data, the system represents a promising direction for improving real-time error resolution in development tools."}}
{"id": "2509.25193", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.25193", "abs": "https://arxiv.org/abs/2509.25193", "authors": ["Abhinav Rastogi", "Adam Yang", "Albert Q. Jiang", "Alexander H. Liu", "Alexandre Sablayrolles", "Am\u00e9lie H\u00e9liou", "Am\u00e9lie Martin", "Anmol Agarwal", "Andy Ehrenberg", "Andy Lo", "Antoine Roux", "Arthur Darcet", "Arthur Mensch", "Baptiste Bout", "Baptiste Rozi\u00e8re", "Baudouin De Monicault", "Chris Bamford", "Christian Wallenwein", "Christophe Renaudin", "Cl\u00e9mence Lanfranchi", "Cl\u00e9ment Denoix", "Corentin Barreau", "Darius Dabert Devon Mizelle", "Diego de las Casas", "Elliot Chane-Sane", "Emilien Fugier", "Emma Bou Hanna", "Gabrielle Berrada", "Gauthier Delerce", "Gauthier Guinet", "Georgii Novikov", "Graham Neubig", "Guillaume Lample", "Guillaume Martin", "Himanshu Jaju", "Jan Ludziejewski", "Jason Rute", "Jean-Malo Delignon", "JeanHadrien Chabran", "Joachim Studnia", "Joep Barmentlo", "Jonas Amar", "Josselin Somerville Roberts", "Julien Denize", "Karan Saxena", "Karmesh Yadav", "Kartik Khandelwal", "Khyathi Raghavi Chandu", "Kush Jain", "L\u00e9lio Renard Lavaud", "L\u00e9onard Blier", "Lingxiao Zhao", "Louis Martin", "Lucile Saulnier", "Luyu Gao", "Marie Pellat", "Mathilde Guillaumin", "Mathis Felardos", "Matthieu Dinot", "Maxime Darrin", "Maximilian Augustin", "Micka\u00ebl Seznec", "Neha Gupta", "Nikhil Raghuraman", "Olivier Duchenne", "Patricia Wang", "Patrick von Platen", "Patryk Saffer", "Paul Jacob", "Paul Wambergue", "Paula Kurylowicz", "Philom\u00e8ne Chagniot", "Pierre Stock", "Pravesh Agrawal", "R\u00e9mi Delacourt", "Roman Soletskyi", "Romain Sauvestre", "Sagar Vaze", "Sanchit Gandhi", "Sandeep Subramanian", "Shashwat Dalal", "Siddharth Gandhi", "Soham Ghosh", "Srijan Mishra", "Sumukh Aithal", "Szymon Antoniak", "Teven Le Scao", "Thibaut Lavril", "Thibault Schueller", "Thomas Foubert", "Thomas Robert", "Thomas Wang", "Timoth\u00e9e Lacroix", "Tom Bewley", "Valeriia Nemychnikova", "Victor Paltz", "Virgile Richard", "Wen-Ding Li", "William Marshall", "Xingyao Wang", "Xuanyu Zhang", "Yihan Wan", "Yunhao Tang"], "title": "Devstral: Fine-tuning Language Models for Coding Agent Applications", "comment": null, "summary": "We introduce Devstral-Small, a lightweight open source model for code agents\nwith the best performance among models below 100B size. In this technical\nreport, we give an overview of how we design and develop a model and craft\nspecializations in agentic software development. The resulting model,\nDevstral-Small is a small 24B model, fast and easy to serve. Despite its size,\nDevstral-Small still attains competitive performance compared to models more\nthan an order of magnitude larger.", "AI": {"tldr": "Devstral-Small is a compact open-source code agent model (24B parameters) with state-of-the-art performance for models under 100B size.", "motivation": "Address the need for efficient, high-performance code agents by challenging the assumption that larger models are inherently better.", "method": "Designed and developed a specialized 24B model optimized for agentic software development tasks through architecture and training innovations.", "result": "Achieved competitive performance relative to models over ten times larger while maintaining fast inference and ease of deployment.", "conclusion": "Devstral-Small demonstrates that small models can achieve strong code agent capabilities, enabling accessible and scalable agentic software development."}}
{"id": "2509.25194", "categories": ["cs.SE", "physics.comp-ph"], "pdf": "https://arxiv.org/pdf/2509.25194", "abs": "https://arxiv.org/abs/2509.25194", "authors": ["Haoyang Wu", "Xinxin Zhang", "Lailai Zhu"], "title": "Automated Code Development for PDE Solvers Using Large Language Models", "comment": null, "summary": "Foundation models -- large language models (LLMs) in particular -- have\nbecome ubiquitous, shaping daily life and driving breakthroughs across science,\nengineering, and technology. Harnessing their broad cross-domain knowledge,\ntext-processing, and reasoning abilities for software development, e.g.,\nnumerical libraries for solving partial differential equations (PDEs), is\ntherefore attracting growing interest. Yet existing studies mainly automate\ncase setup and execution for end users. We introduce LLM-PDEveloper, a\nzero-shot, multi-agent LLM framework that automates code development for PDE\nlibraries, specifically targeting secondary developers. By translating\nmathematical and algorithmic descriptions directly into source code,\nLLM-PDEveloper generates new solvers/modules and adapts existing ones. This\nend-to-end math-to-code approach enables a self-augmenting pipeline that\ncontinuously expands the codebase of a library, extends its capacities, and\nbroadens its scope. We demonstrate LLM-PDEveloper on three tasks: 1) build a\nsolver for a new PDE, 2) implement new BCs for a given PDE, and 3) modify an\nexisting solver to incorporate additional terms, achieving moderate success\nrates. Failures due to syntactic errors made by LLMs are analyzed and we\npropose effective fixes. We also identify the mechanisms underlying certain\nsemantic errors, guiding future research.", "AI": {"tldr": "LLM-PDEveloper is a zero-shot multi-agent framework that automates code development for PDE libraries by translating mathematical/algorithmic descriptions into code, expanding library capabilities through an end-to-end math-to-code pipeline.", "motivation": "Existing LLM applications in scientific libraries focus on automating user workflows, but lack systematic code development for secondary developers. This limits expansion of PDE solver libraries despite LLMs\u2019 cross-domain reasoning potential.", "method": "The framework employs a multi-agent LLM architecture to (1\u2019 translate mathematical specifications into source code, (2) adapt existing solvers/modules via code generation, and (3\u2019 create self-augmenting pipelines for iterative library expansion through generated code.", "result": "Three tasks demonstrated automated code generation: new PDE solver development, boundary condition implementation, and solver modification with additional terms. Achieved moderate success rates with detailed analysis of syntactic/semantic error mechanisms and proposed fixes for common LLM-generated syntactic errors.", "conclusion": "LLM-PDEveloper establishes a viable architecture for automating scientific library development through math-to-code translation, while identifying technical barriers (error mechanisms) that guide future research in robust scientific code generation."}}
{"id": "2509.25195", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.25195", "abs": "https://arxiv.org/abs/2509.25195", "authors": ["Hira Naveed", "John Grundy", "Chetan Arora", "Hourieh Khalajzadeh", "Omar Haggag"], "title": "Understanding Practitioners Perspectives on Monitoring Machine Learning Systems", "comment": null, "summary": "Given the inherent non-deterministic nature of machine learning (ML) systems,\ntheir behavior in production environments can lead to unforeseen and\npotentially dangerous outcomes. For a timely detection of unwanted behavior and\nto prevent organizations from financial and reputational damage, monitoring\nthese systems is essential. This paper explores the strategies, challenges, and\nimprovement opportunities for monitoring ML systems from the practitioners\nperspective. We conducted a global survey of 91 ML practitioners to collect\ndiverse insights into current monitoring practices for ML systems. We aim to\ncomplement existing research through our qualitative and quantitative analyses,\nfocusing on prevalent runtime issues, industrial monitoring and mitigation\npractices, key challenges, and desired enhancements in future monitoring tools.\nOur findings reveal that practitioners frequently struggle with runtime issues\nrelated to declining model performance, exceeding latency, and security\nviolations. While most prefer automated monitoring for its increased\nefficiency, many still rely on manual approaches due to the complexity or lack\nof appropriate automation solutions. Practitioners report that the initial\nsetup and configuration of monitoring tools is often complicated and\nchallenging, particularly when integrating with ML systems and setting alert\nthresholds. Moreover, practitioners find that monitoring adds extra workload,\nstrains resources, and causes alert fatigue. The desired improvements from the\npractitioners perspective are: automated generation and deployment of monitors,\nimproved support for performance and fairness monitoring, and recommendations\nfor resolving runtime issues. These insights offer valuable guidance for the\nfuture development of ML monitoring tools that are better aligned with\npractitioners needs.", "AI": {"tldr": "A survey of 91 ML practitioners reveals key monitoring challenges (runtime issues, manual workflows, setup complexity) and desired improvements (automation, performance/fairness support) to guide future ML monitoring tool development.", "motivation": "ML systems' non-deterministic nature leads to unpredictable production behaviors, necessitating effective monitoring to prevent financial and reputational harm. Existing research lacks practitioner-focused analysis of monitoring practices.", "method": "The paper conducted a global survey of 91 ML practitioners to gather insights on monitoring practices, followed by qualitative and quantitative analysis of the data to identify trends, challenges, and desired improvements.", "result": "Findings highlight struggles with runtime issues (model performance decline, latency, security violations), reliance on manual monitoring due to automation gaps, challenges in tool setup/configuration, and desired improvements: automated monitor deployment, enhanced performance/fairness monitoring, and runtime issue resolution guidance.", "conclusion": "The insights from the survey provide a roadmap for developing ML monitoring tools that better meet practitioners' needs by addressing current challenges and enhancing automation and support features."}}
{"id": "2509.25394", "categories": ["cs.CR", "cs.SY", "eess.SP", "eess.SY"], "pdf": "https://arxiv.org/pdf/2509.25394", "abs": "https://arxiv.org/abs/2509.25394", "authors": ["Hui Wang", "Nima Tashakor", "Xiaoyang Tian", "Hans D. Schotten", "Stefan M. Goetz"], "title": "Fast Energy-Theft Attack on Frequency-Varying Wireless Power without Additional Sensors", "comment": "11 pages, 12 figures", "summary": "With the popularity of wireless charging, energy access protection and\ncybersecurity are gaining importance, especially in public places. Currently,\nthe most common energy encryption method uses frequency and associated\nimpedance variation. However, we have proven that this method is not reliable,\nsince a hacker can detect the changing frequency and adjust the compensation.\nHowever, the previously presented system needed time to follow the updated\nfrequency, while encryption systems may vary the frequency faster to avoid\nenergy theft. Furthermore, the previous system required an additional sensor\ncoil. To solve these problems, we optimized the attack and the associated\nsystem, which can intrude and steal energy within 0.2 ms. The key is the\nelimination of the time-consuming maximum receiver current regulation. Also, we\nuse the main receiving coil rather than any additional sensor antenna to detect\nthe magnetic field. Thus, the new hardware is even simpler. A simulation model\nand experimental results demonstrate the fast response speed of the attack on\nencrypted wireless power and steal 65% of the power. Overall, the applicability\nof the attack is highly improved and leaves less room for hardening the\nencryption. The results demonstrate that energy access protection needs to be\ngiven great attention.", "AI": {"tldr": "The paper presents an optimized wireless power attack method using a main receiving coil for faster intrusions and less hardware.", "motivation": "To enhance energy access protection and cybersecurity against energy theft via wireless charging.", "method": "Eliminated time-consuming maximum receiver current regulation and used the main receiving coil instead of an additional sensor coil to detect the magnetic field.", "result": "The attack can intrude and steal energy within 0.2 ms, with experimental results showing 65% power can be stolen from encrypted wireless power.", "conclusion": "The improved attack applicability indicates that energy access protection requires significant attention."}}
{"id": "2509.25196", "categories": ["cs.SE", "cs.AI", "cs.LG", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.25196", "abs": "https://arxiv.org/abs/2509.25196", "authors": ["Hua Zhong", "Shan Jiang", "Sarfraz Khurshid"], "title": "APRIL: API Synthesis with Automatic Prompt Optimization and Reinforcement Learning", "comment": null, "summary": "APIs are central to modern software development, yet composing new APIs from\nlarge libraries is difficult due to the exponential search space; traditional\ncomponent-based synthesis relies on costly exploration and hand-crafted\nspecifications. While large language models (LLMs) can generate implementations\nfrom natural language, hallucinations and limited access to up-to-date\ncontextual information often yield incorrect code. In this paper, we present\nAPRIL, an approach that combines LLM-based synthesis with Automatic Prompt\nOptimization (APO) and Reinforcement Learning from Verifiable Rewards (RLVR):\nAPO iteratively refines prompts for a frozen model, while RLVR fine-tunes the\npolicy toward functional correctness, producing an efficient synthesis\npipeline. Evaluated on 81 real-world APIs from widely used scientific Python\nlibraries and benchmarked against instruction-tuned but unfine-tuned LLMs\nguided by expert prompts, APRIL achieves substantial improvements. These\nresults indicate that integrating APO and RLVR provides a robust, scalable path\nfor component-based API synthesis in large libraries.", "AI": {"tldr": "The paper introduces APRIL, a method that combines LLM-based synthesis with APO and RLVR for efficient API composition, showing significant improvements over existing models.", "motivation": "Composing new APIs from large libraries is challenging due to exponential search spaces and limitations in traditional synthesis methods and LLMs, such as hallucinations and lack of up-to-date context.", "method": "APRIL integrates LLM-based synthesis with Automatic Prompt Optimization (APO) to refine prompts for a frozen model and Reinforcement Learning from Verifiable Rewards (RLVR) to fine-tune the policy towards functional correctness, creating an efficient synthesis pipeline.", "result": "APRIL was evaluated on 81 real-world APIs from popular scientific Python libraries and outperformed instruction-tuned but unfine-tuned LLMs guided by expert prompts in terms of effectiveness and scalability.", "conclusion": "The integration of APO and RLVR in APRIL provides a robust and scalable solution for component-based API synthesis in large libraries, demonstrating significant improvements in accuracy and efficiency."}}
{"id": "2509.25408", "categories": ["cs.CR", "econ.TH"], "pdf": "https://arxiv.org/pdf/2509.25408", "abs": "https://arxiv.org/abs/2509.25408", "authors": ["Korok Ray", "Sindura Saraswathi"], "title": "Optimal Threshold Signatures in Bitcoin", "comment": null, "summary": "We formulate the design of a threshold signature scheme as made possible on\ncryptocurrency protocols like Bitcoin. The funds are secured by an m-of-n\nthreshold signature, where at least m signatures are needed to unlock the\nfunds. A user designs this scheme knowing that a malicious attacker can also\nobtain the signatures with some probability. Higher thresholds offer more\nsecurity, but also risk locking the user out of his own funds. The optimal\nthreshold balances these twin effects. Interventions like increasing the\nsecurity or usability of the signatures allow for higher thresholds. We model\ndynamic threshold signature schemes, where the probability of a user or\nattacker obtaining signatures decays with time. A dynamic threshold signature\nscheme is optimal, and increasing security or usability allows for higher\nthresholds and longer time locks.", "AI": {"tldr": "Dynamic threshold signatures optimally balance security and usability through time-decaying access probabilities, enabling safer cryptocurrency fund management.", "motivation": "Higher security thresholds in cryptocurrencies risk locking users out of funds, while lower thresholds increase theft vulnerability. The challenge is balancing these tradeoffs in threshold signature design.", "method": "The authors model a dynamic threshold signature scheme where the probability of user or attacker obtaining signatures decays over time. They analyze how security and usability interventions affect optimal threshold selection.", "result": "Optimal thresholds exist that balance security/usability tradeoffs. Security/usability enhancements allow higher optimal thresholds (more security) while maintaining fund accessibility through time-based probability decay.", "conclusion": "Dynamic threshold signature schemes can achieve optimality by balancing security and usability, where improvements in these areas enable higher thresholds and longer time locks."}}
{"id": "2509.25197", "categories": ["cs.SE", "cs.AI", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.25197", "abs": "https://arxiv.org/abs/2509.25197", "authors": ["Si Cheng Zhong", "Xujie Si"], "title": "Towards Repository-Level Program Verification with Large Language Models", "comment": "Accepted to LMPL 2025", "summary": "Recent advancements in large language models (LLMs) suggest great promises in\ncode and proof generations. However, scaling automated formal verification to\nreal-world projects requires resolving cross-module dependencies and global\ncontexts, which are crucial challenges overlooked by existing LLM-based methods\nwith a special focus on targeting isolated, function-level verification tasks.\nTo systematically explore and address the significant challenges of verifying\nentire software repositories, we introduce RVBench, the first verification\nbenchmark explicitly designed for repository-level evaluation, constructed from\nfour diverse and complex open-source Verus projects.\n  We further introduce RagVerus, an extensible framework that synergizes\nretrieval-augmented generation with context-aware prompting to automate proof\nsynthesis for multi-module repositories. RagVerus triples proof pass rates on\nexisting benchmarks under constrained model inference budgets, and achieves a\n27% relative improvement on the more challenging RVBench benchmark,\ndemonstrating a scalable and sample-efficient verification solution.", "AI": {"tldr": "RVBench and RagVerus address repository-level verification: RVBench challenges LLMs with real-world software, while RagVerus improves proof synthesis via retrieval and context-aware prompts, showing significant performance boosts.", "motivation": "Existing LLM-based methods focus on isolated, function-level tasks, overlooking real-world challenges like cross-module dependencies and global contexts in automated formal verification.", "method": "RVBench is a repository-level verification benchmark constructed from four Verus projects, and RagVerus combines retrieval-augmented generation with context-aware prompting for scalable proof synthesis.", "result": "RagVerus triples proof pass rates on existing benchmarks and achieves 27% relative improvement on RVBench under constrained model inference budgets.", "conclusion": "The paper introduces RVBench and RagVerus, addressing repository-level verification challenges by handling cross-module dependencies and global contexts, with significant improvements in proof pass rates."}}
{"id": "2509.25410", "categories": ["cs.CR", "cs.CY"], "pdf": "https://arxiv.org/pdf/2509.25410", "abs": "https://arxiv.org/abs/2509.25410", "authors": ["Maraz Mia", "Mir Mehedi A. Pritom", "Tariqul Islam", "Shouhuai Xu"], "title": "Characterizing Event-themed Malicious Web Campaigns: A Case Study on War-themed Websites", "comment": "12 pages, 9 figures, 5 tables", "summary": "Cybercrimes such as online scams and fraud have become prevalent.\nCybercriminals often abuse various global or regional events as themes of their\nfraudulent activities to breach user trust and attain a higher attack success\nrate. These attacks attempt to manipulate and deceive innocent people into\ninteracting with meticulously crafted websites with malicious payloads,\nphishing, or fraudulent transactions. To deepen our understanding of the\nproblem, this paper investigates how to characterize event-themed malicious\nwebsite-based campaigns, with a case study on war-themed websites. We find that\nattackers tailor their attacks by exploiting the unique aspects of events, as\nevidenced by activities such as fundraising, providing aid, collecting\nessential supplies, or seeking updated news. We use explainable unsupervised\nclustering methods to draw further insights, which could guide the design of\neffective early defenses against various event-themed malicious web campaigns.", "AI": {"tldr": "This paper studies event-themed malicious websites, focusing on war-themed examples to understand their attack patterns using explainable clustering methods.", "motivation": "The prevalence of cybercrimes themed around global events urges a deeper understanding to design proactive defenses.", "method": "The authors used explainable unsupervised clustering methods on a case study of war-themed websites.", "result": "Attackers were found to exploit event-specific activities like fundraising for their attacks, and the clustering method provided insights into campaign characteristics.", "conclusion": "The study emphasizes the need for early defenses tailored to event themes, with clustering methods aiding in the detection of event-driven malicious campaigns."}}
{"id": "2509.25199", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.25199", "abs": "https://arxiv.org/abs/2509.25199", "authors": ["Mushahid Khan", "Prashant J. Nair", "Olivia Di Matteo"], "title": "CircInspect: Integrating Visual Circuit Analysis, Abstraction, and Real-Time Development in Quantum Debugging", "comment": null, "summary": "Software bugs typically result from errors in specifications or code\ntranslation. While classical software engineering has evolved with various\ntools and methodologies to tackle such bugs, the emergence of quantum computing\npresents unique challenges. Quantum software development introduces\ncomplexities due to the probabilistic nature of quantum computing, distinct\nalgorithmic primitives, and potential hardware noise. In this paper, we\nintroduce CircInspect, an interactive tool tailored for debugging quantum\nprograms in Python and PennyLane. By leveraging breakpoints and real-time\nsoftware development features, \\toolname~empowers users to analyze isolated\nquantum circuit components, monitor program output, visualize structural\nchanges, and abstract information to enhance comprehension.", "AI": {"tldr": "CircInspect is a debugging tool for quantum programs in Python and PennyLane, offering features like breakpoints and real-time monitoring to analyze quantum circuits and improve understanding.", "motivation": "Quantum software development introduces complexities due to the probabilistic nature of quantum computing, distinct algorithmic primitives, and potential hardware noise.", "method": "CircInspect uses breakpoints and real-time software development features to allow users to analyze isolated quantum circuit components, monitor program output, and visualize structural changes.", "result": "The result of developing CircInspect is the introduction of a new debugging tool that can be used for quantum programs in Python and PennyLane.", "conclusion": "CircInspect is an interactive tool that addresses the unique challenges of quantum software debugging by providing useful features for component analysis, output monitoring, and structural visualization."}}
{"id": "2509.25430", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2509.25430", "abs": "https://arxiv.org/abs/2509.25430", "authors": ["Martin Kotuliak", "Simon Erni", "Jakub Pol\u00e1k", "Marc Roeschlin", "Richard Baker", "Ivan Martinovic", "Srdjan \u010capkun"], "title": "Finding Phones Fast: Low-Latency and Scalable Monitoring of Cellular Communications in Sensitive Areas", "comment": null, "summary": "The widespread availability of cellular devices introduces new threat vectors\nthat allow users or attackers to bypass security policies and physical barriers\nand bring unauthorized devices into sensitive areas. These threats can arise\nfrom user non-compliance or deliberate actions aimed at data\nexfiltration/infiltration via hidden devices, drones, etc. We identify a\ncritical gap in this context: the absence of low-latency systems for\nhigh-quality and instantaneous monitoring of cellular transmissions. Such\nlow-latency systems are crucial to allow for timely detection, decision (e.g.,\ngeofencing or localization), and disruption of unauthorized communication in\nsensitive areas. Operator-based monitoring systems, built for purposes such as\npeople counting or tracking, lack real-time capability, require cooperation\nacross multiple operators, and thus are hard to deploy. Operator-independent\nmonitoring approaches proposed in the literature either lack low-latency\ncapabilities or do not scale.\n  We propose LTag, the first low-latency, operator-independent and scalable\nsystem designed to monitor cellular connections across all operators prior to\nany user data transmission. LTag consists of several downlink sniffers and a\ndistributed network of uplink sniffers that measure both downlink protocol\ninformation and uplink signal characteristics at multiple locations to gain a\ndetailed spatial image of uplink signals. LTag aggregates the recorded\ninformation, processes it, and provides a decision about the connection all\nprior to connection establishment of a UE. To evaluate LTag, we deployed it in\nthe context of geofencing, where LTag was able to determine if the signals\noriginate from inside or outside of an area within 2.3 ms of the initial base\nstation-to-device message, therefore enabling prompt and targeted suppression\nof communication before any user data was transmitted.", "AI": {"tldr": "LTag: First low-latency, operator-independent system blocks unauthorized cellular communication by monitoring uplink/downlink signals pre-connection, enabling real-time geofencing and disruption within 2.3 ms.", "motivation": "Existing cellular monitoring systems suffer from high latency, operator dependency, or poor scalability. This prevents timely detection and disruption of unauthorized devices (e.g., drones, hidden transceivers) in sensitive areas, enabling data exfiltration/infiltration risks.", "method": "LTag employs distributed downlink and uplink sniffers to measure cellular protocol data and signal characteristics. Aggregated data is processed to determine connection eligibility before UE (User Equipment) connection establishment, enabling rapid geofencing decisions.", "result": "LTag achieves signal origin classification (inside/outside geofence area) within 2.3 ms of the first base station-to-device message. It enables disruption of unauthorized communication before any user data transmission, validated through geofencing deployment.", "conclusion": "The paper introduces LTag, a low-latency, operator-independent monitoring system that addresses the critical gap in real-time cellular transmission monitoring. It demonstrates effectiveness in enabling timely disruption of unauthorized communication through a scalable and deployment-ready solution."}}
{"id": "2509.25203", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.25203", "abs": "https://arxiv.org/abs/2509.25203", "authors": ["Zekai Zhang", "Mingwei Liu", "Zhenxi Chen", "Linxi Liang", "Yuxuan Chen", "Guangsheng Ou", "Yanlin Wang", "Dan Li", "Xin Peng", "Zibin Zheng"], "title": "Generating High-Quality Datasets for Code Editing via Open-Source Language Models", "comment": "23 pages, 8 figures", "summary": "Code editing plays a vital role in software engineering, requiring developers\nto adjust existing code according to natural language instructions while\nkeeping functionality intact and avoiding unnecessary modifications. However,\ncommit-based datasets commonly used for this task are often noisy, lack\ndiversity, and fail to reflect the style of real-world edit instructions. To\naddress this, we introduce CanItEdit, an open-source pipeline that leverages\nmultiple LLMs to synthesize realistic code-edit triplets. The pipeline produces\nboth concise \"lazy\" instructions and more detailed \"descriptive\" ones, and\napplies filtering based on diffs and topics to guarantee data quality and\nvariety. Using this process, we construct OCEDataFT, a curated dataset of 20K\nsamples. Fine-tuning three advanced base models on OCEDataFT leads to\nsignificant performance boosts on the CanItEdit benchmark, with relative pass@1\nimprovements ranging from 4.50% to 20.79%. Notably, the resulting models\nachieve performance close to closed-source systems, narrowing the gap to GPT-4\nto just 3.54%, without relying on proprietary resources or manual annotation.", "AI": {"tldr": "The paper introduces CanItEdit, a pipeline for synthesizing realistic code-edit triplets using multiple LLMs, and presents OCEDataFT, a curated dataset. Fine-tuning models on this dataset significantly improves performance, reducing the gap to GPT-4.", "motivation": "Commit-based datasets for code editing are noisy, lack diversity, and do not reflect real-world edit instructions' style, limiting model performance improvements.", "method": "CanItEdit uses multiple LLMs to generate both concise and detailed code-edit instructions, followed by filtering based on diffs and topics to ensure data quality and variety. The pipeline produces a curated dataset of 20K samples, OCEDataFT.", "result": "Fine-tuning three advanced base models on OCEDataFT resulted in performance boosts on the CanItEdit benchmark. The relative pass@1 improvements ranged from 4.50% to 20.79%, with the resulting models achieving performance within 3.54% of GPT-4.", "conclusion": "The proposed CanItEdit pipeline and OCEDataFT dataset effectively enhance code editing model performance, bridging the gap to closed-source systems like GPT-4 without proprietary resources or manual annotation."}}
{"id": "2509.25448", "categories": ["cs.CR", "cs.CL"], "pdf": "https://arxiv.org/pdf/2509.25448", "abs": "https://arxiv.org/abs/2509.25448", "authors": ["Yuepeng Hu", "Zhengyuan Jiang", "Mengyuan Li", "Osama Ahmed", "Zhicong Huang", "Cheng Hong", "Neil Gong"], "title": "Fingerprinting LLMs via Prompt Injection", "comment": null, "summary": "Large language models (LLMs) are often modified after release through\npost-processing such as post-training or quantization, which makes it\nchallenging to determine whether one model is derived from another. Existing\nprovenance detection methods have two main limitations: (1) they embed signals\ninto the base model before release, which is infeasible for already published\nmodels, or (2) they compare outputs across models using hand-crafted or random\nprompts, which are not robust to post-processing. In this work, we propose\nLLMPrint, a novel detection framework that constructs fingerprints by\nexploiting LLMs' inherent vulnerability to prompt injection. Our key insight is\nthat by optimizing fingerprint prompts to enforce consistent token preferences,\nwe can obtain fingerprints that are both unique to the base model and robust to\npost-processing. We further develop a unified verification procedure that\napplies to both gray-box and black-box settings, with statistical guarantees.\nWe evaluate LLMPrint on five base models and around 700 post-trained or\nquantized variants. Our results show that LLMPrint achieves high true positive\nrates while keeping false positive rates near zero.", "AI": {"tldr": "LLMPrint introduces a novel framework for detecting model provenance by exploiting LLMs' vulnerability to prompt injection, creating robust fingerprints resilient to post-processing methods like quantization or post-training.", "motivation": "Existing provenance detection methods either require embedding signals before model release (inapplicable to existing LLMs), or rely on suboptimal prompt-based comparisons that fail under post-processing.", "method": "LLMPrint constructs unique model fingerprints by optimizing fingerprint prompts to enforce consistent token preferences. It leverages prompt injection vulnerabilities and proposes a unified, statistically guaranteed verification protocol for both gray-box and black-box scenarios.", "result": "Evaluations on 5 base models and 700 variants show LLMPrint achieves high true positive rates (approaching 100%) with false positive rates near 0%, maintaining effectiveness under various post-processing techniques.", "conclusion": "LLMPrint provides a practical, robust solution for model provenance detection. Its exploitation of inherent LLM vulnerabilities and unified verification framework addresses critical limitations of existing methods, enabling reliable detection of model lineage even after extensive modifications."}}
{"id": "2509.25242", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.25242", "abs": "https://arxiv.org/abs/2509.25242", "authors": ["Zejun Zhang", "Jian Wang", "Qingyun Yang", "Yifan Pan", "Yi Tang", "Yi Li", "Zhenchang Xing", "Tian Zhang", "Xuandong Li", "Guoan Zhang"], "title": "A Benchmark for Localizing Code and Non-Code Issues in Software Projects", "comment": null, "summary": "Accurate project localization (e.g., files and functions) for issue\nresolution is a critical first step in software maintenance. However, existing\nbenchmarks for issue localization, such as SWE-Bench and LocBench, are limited.\nThey focus predominantly on pull-request issues and code locations, ignoring\nother evidence and non-code files such as commits, comments, configurations,\nand documentation. To address this gap, we introduce MULocBench, a\ncomprehensive dataset of 1,100 issues from 46 popular GitHub Python projects.\nComparing with existing benchmarks, MULocBench offers greater diversity in\nissue types, root causes, location scopes, and file types, providing a more\nrealistic testbed for evaluation. Using this benchmark, we assess the\nperformance of state-of-the-art localization methods and five LLM-based\nprompting strategies. Our results reveal significant limitations in current\ntechniques: even at the file level, performance metrics (Acc@5, F1) remain\nbelow 40%. This underscores the challenge of generalizing to realistic,\nmulti-faceted issue resolution. To enable future research on project\nlocalization for issue resolution, we publicly release MULocBench at\nhttps://huggingface.co/datasets/somethingone/MULocBench.", "AI": {"tldr": "MULocBench addresses gaps in issue localization benchmarks by introducing a diverse dataset showing current methods' poor performance (Acc@5, F1 <40%), emphasizing real-world generalization challenges.", "motivation": "Existing benchmarks like SWE-Bench and LocBench focus narrowly on code locations and pull-requests, neglecting critical evidence such as commits, comments, and documentation, hindering realistic evaluation of issue localization.", "method": "The authors created MULocBench, a dataset of 1,100 issues from 46 GitHub projects, and evaluated state-of-the-art localization methods and LLM-based prompting strategies to analyze their limitations.", "result": "Current methods achieve below 40% accuracy at the file level, demonstrating significant limitations in handling diverse, multifaceted issues despite the inclusion of varied root causes and file types in MULocBench.", "conclusion": "The paper highlights the challenges in generalizing issue resolution methods and introduces MULocBench to enable future research on project localization by providing a more realistic evaluation framework."}}
{"id": "2509.25462", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2509.25462", "abs": "https://arxiv.org/abs/2509.25462", "authors": ["Loay Abdelrazek", "Filippo Rebecchi"], "title": "Managing Differentiated Secure Connectivity using Intents", "comment": "Preprint version of paper accepted in Mobiwac'25", "summary": "Mobile networks in the 5G and 6G era require to rethink how to manage\nsecurity due to the introduction of new services, use cases, each with its own\nsecurity requirements, while simultaneously expanding the threat landscape.\nAlthough automation has emerged as a key enabler to address complexity in\nnetworks, existing approaches lack the expressiveness to define and enforce\ncomplex, goal-driven, and measurable security requirements. In this paper, we\npropose the concept of differentiated security levels and leveraging intents as\na management framework. We discuss the requirements and enablers to extend the\ncurrently defined intent-based management frameworks to pave the path for\nintent-based security management in mobile networks. Our approach formalizes\nboth functional and non-functional security requirements and demonstrates how\nthese can be expressed and modeled using an extended TM Forum (TMF) intent\nsecurity ontology. We further discuss the required standardization steps to\nachieve intent-based security management. Our work aims at advance security\nautomation, improve adaptability, and strengthen the resilience and security\nposture of the next-generation mobile networks.", "AI": {"tldr": "This paper proposes intent-based security management for 5G/6G mobile networks using differentiated security levels and an extended TM Forum ontology to address complex, goal-driven security requirements, aiming to enhance automation and resilience.", "motivation": "New 5G/6G services and use cases introduce diverse security requirements and threats, while existing automation approaches lack the expressiveness to enforce measurable, goal-oriented security policies effectively.", "method": "The authors introduce differentiated security levels and extend intent-based management frameworks using a TMF intent security ontology to formalize functional/non-functional security requirements and outline standardization steps.", "result": "The work demonstrates a framework for expressing security requirements via intent modeling and identifies necessary standardization steps to enable intent-driven security automation in mobile networks.", "conclusion": "The proposed approach advancement aims to improve security automation, adaptability, and overall resilience for next-generation mobile networks through intent-based security management."}}
{"id": "2509.25243", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.25243", "abs": "https://arxiv.org/abs/2509.25243", "authors": ["Xunzhu Tang", "Iyiola Emmanuel Olatunji", "Tiezhu Sun", "Jacques Klein", "Tegawende F. Bissyande"], "title": "Reinforcement Learning-Guided Chain-of-Draft for Token-Efficient Code Generation", "comment": null, "summary": "LLMs demonstrate surface-level fluency in code generation but struggle with\nstructured reasoning tasks requiring correctness and semantic alignment. While\nChain-of-Thought (CoT) prompting enhances reasoning through intermediate steps,\nit suffers from verbosity and inefficiency. Chain-of-Draft (CoD) prompting\noffers more concise reasoning, but the stochastic nature of LLMs produces\nvarying solution quality, making optimal selection challenging. We propose\n\\multicod, a reinforcement learning framework that learns to select the most\npromising candidate from CoD-generated solutions. Our approach uses\nstrategy-guided prompting to encourage diverse reasoning styles and models\nsolution selection as a contextual bandit problem. The framework optimizes\ninterpretable features including code complexity, reasoning structure, and\nstrategic metadata through a reward function balancing correctness, efficiency,\nand clarity. Experiments on MBPP, BigCodeBench, SWE-bench Verified, and\nDefects4J show \\multicod~outperforms and in some cases, on par with standard\nprompting, CoT, and CoD baselines while achieving cost and token efficiency\nfrom the user's perspective through a multi-candidate design that charges only\nfor the selected output, reducing user billing by over 50\\% and improving LLM\nresponse quality, making \\multicod~more sustainable and scalable for real-world\ndeployment. Our code is available: https://anonymous.4open.science/r/MultiCoD.", "AI": {"tldr": "MultiCoD: Uses RL to select top code generation solutions from CoD candidates, reducing costs by 50% and boosting quality across benchmarks like MBPP and BigCodeBench.", "motivation": "While Chain-of-Thought (CoT) and Chain-of-Draft (CoD) prompting improve code generation through structured reasoning, they suffer from verbosity (CoT) and stochastic quality variation (CoD), making optimal solution selection challenging. This limits their practical scalability and cost-effectiveness.", "method": "MultiCoD employs a reinforcement learning framework that models solution selection as a contextual bandit problem. It uses strategy-guided prompting to generate diverse reasoning styles and optimizes interpretable features (code complexity, reasoning structure, strategic metadata) via a reward function balancing correctness, efficiency, and clarity.", "result": "Experiments on MBPP, BigCodeBench, SWE-bench Verified, and Defects4J demonstrate MultiCoD outperforms or matches standard prompting, CoT, and CoD baselines. The framework reduces user billing by >50% through a multi-candidate design that only charges for the selected output, while improving LLM response quality.", "conclusion": "MultiCoD is presented as a more sustainable and scalable solution for real-world deployment in code generation tasks due to its cost efficiency and improved response quality."}}
{"id": "2509.25469", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2509.25469", "abs": "https://arxiv.org/abs/2509.25469", "authors": ["Panagiotis Michalopoulos", "Anthony Mack", "Cameron Clark", "Linus Chen", "Johannes Sedlmeir", "Andreas Veneris"], "title": "Balancing Compliance and Privacy in Offline CBDC Transactions Using a Secure Element-based System", "comment": "9 pages, 4 figures", "summary": "Blockchain technology has spawned a vast ecosystem of digital currencies with\nCentral Bank Digital Currencies (CBDCs) -- digital forms of fiat currency --\nbeing one of them. An important feature of digital currencies is facilitating\ntransactions without network connectivity, which can enhance the scalability of\ncryptocurrencies and the privacy of CBDC users. However, in the case of CBDCs,\nthis characteristic also introduces new regulatory challenges, particularly\nwhen it comes to applying established Anti-Money Laundering and Countering the\nFinancing of Terrorism (AML/CFT) frameworks. This paper introduces a prototype\nfor offline digital currency payments, equally applicable to cryptocurrencies\nand CBDCs, that leverages Secure Elements and digital credentials to address\nthe tension of offline payment support with regulatory compliance. Performance\nevaluation results suggest that the prototype can be flexibly adapted to\ndifferent regulatory environments, with a transaction latency comparable to\nreal-life commercial payment systems. Furthermore, we conceptualize how the\nintegration of Zero-Knowledge Proofs into our design could accommodate various\ntiers of enhanced privacy protection.", "AI": {"tldr": "This paper introduces a compliant offline payment framework for CBDCs and cryptocurrencies using hardware security and zero-knowledge proofs, achieving commercial-grade performance with configurable privacy tiers.", "motivation": "Offline payments improve scalability and privacy but conflict with AML/CFT regulations, creating a critical tension in CBDC implementation.", "method": "A prototype leverages Secure Elements and digital credentials, with optional integration of Zero-Knowledge Proofs for tiered privacy protection.", "result": "The prototype achieves transaction latency comparable to commercial systems while demonstrating regulatory adaptability through performance evaluations.", "conclusion": "The paper proposes an offline digital currency payment solution using Secure Elements and Zero-Knowledge Proofs, balancing regulatory compliance with privacy enhancement for both cryptocurrencies and CBDCs."}}
{"id": "2509.25247", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.25247", "abs": "https://arxiv.org/abs/2509.25247", "authors": ["Krishna Vamshi Bodla", "Haizhao Yang"], "title": "Protocode: Prototype-Driven Interpretability for Code Generation in LLMs", "comment": null, "summary": "Since the introduction of Large Language Models (LLMs), they have been widely\nadopted for various tasks such as text summarization, question answering,\nspeech-to-text translation, and more. In recent times, the use of LLMs for code\ngeneration has gained significant attention, with tools such as Cursor and\nWindsurf demonstrating the ability to analyze massive code repositories and\nrecommend relevant changes. Big tech companies have also acknowledged the\ngrowing reliance on LLMs for code generation within their codebases. Although\nthese advances significantly improve developer productivity, increasing\nreliance on automated code generation can proportionally increase the risk of\nsuboptimal solutions and insecure code. Our work focuses on automatically\nsampling In-Context Learning (ICL) demonstrations which can improve model\nperformance and enhance the interpretability of the generated code. Using\nAST-based analysis on outputs from the MBPP test set, we identify regions of\ncode most influenced by the chosen demonstrations. In our experiments, we show\nthat high-quality ICL demonstrations not only make outputs easier to interpret\nbut also yield a positive performance improvement on the pass@10 metric.\nConversely, poorly chosen ICL demonstrations affected the LLM performance on\nthe pass@10 metric negatively compared to the base model. Overall, our approach\nhighlights the importance of efficient sampling strategies for ICL, which can\naffect the performance of the model on any given task.", "AI": {"tldr": "This paper investigates how In-Context Learning (ICL)$ demonstrations impact LLM code generation, showing high-quality ICL samples improve performance and interpretability while poor samples reduce model accuracy.", "motivation": "Reliance on LLM code generation increases developer productivity but introduces risks of suboptimal solutions and insecure code. Understanding ICL demonstration impact is critical for improving reliability.", "method": "The study uses AST-based analysis of MBPP test set outputs to identify code regions influenced by ICL demonstrations, experimenting with quality-based sampling strategies for pass@10 metric evaluation.", "result": "High-quality ICL demonstrations improved pass@10 scores and code interpretability, while poor demonstrations caused performance degradation compared to base models.", "conclusion": "Effective ICL sampling strategies significantly affect LLM performance and code quality, highlighting the need for robust demonstration selection mechanisms in code generation tasks."}}
{"id": "2509.25476", "categories": ["cs.CR", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2509.25476", "abs": "https://arxiv.org/abs/2509.25476", "authors": ["Yonatan Gizachew Achamyeleh", "Yang Xiang", "Yun-Ping Hsiao", "Yasamin Moghaddas", "Mohammad Abdullah Al Faruque"], "title": "Environmental Rate Manipulation Attacks on Power Grid Security", "comment": null, "summary": "The growing complexity of global supply chains has made hardware Trojans a\nsignificant threat in sensor-based power electronics. Traditional Trojan\ndesigns depend on digital triggers or fixed threshold conditions that can be\ndetected during standard testing. In contrast, we introduce Environmental Rate\nManipulation (ERM), a novel Trojan triggering mechanism that activates by\nmonitoring the rate of change in environmental parameters rather than their\nabsolute values. This approach allows the Trojan to remain inactive under\nnormal conditions and evade redundancy and sensor-fusion defenses. We implement\na compact 14~$\\mu$m$^2$ circuit that measures capacitor charging rates in\nstandard sensor front-ends and disrupts inverter pulse-width modulation PWM\nsignals when a rapid change is induced. Experiments on a commercial Texas\nInstruments solar inverter demonstrate that ERM can trigger catastrophic driver\nchip failure. Furthermore, ETAP simulations indicate that a single compromised\n100~kW inverter may initiate cascading grid instabilities. The attack's\nsignificance extends beyond individual sensors to entire classes of\nenvironmental sensing systems common in power electronics, demonstrating\nfundamental challenges for hardware security.", "AI": {"tldr": "This paper introduces Environmental Rate Manipulation (ERM), a novel hardware Trojan triggering mechanism that leverages environmental parameter rate-of-change to evade detection and cause cascading failures in power electronics systems.", "motivation": "Traditional Trojans using digital triggers or fixed thresholds are detectable during testing; there is a need for stealthier attack vectors that exploit dynamic environmental factors to bypass redundancy and sensor-fusion defenses.", "method": "The ERM mechanism employs a 14 \u00b5m\u00b2 circuit to monitor capacitor charging rates in sensor front-ends, disrupting PWM signals when rapid environmental changes occur. This hardware is implemented using standard power electronics components to avoid anomalies under normal conditions.", "result": "Experiments on TI solar inverters caused driver chip failures, while ETAP simulations showed 100 kW inverter sabotage could initiate grid-wide instabilities. ERM evades conventional testing by relying on temporal rather than static conditions.", "conclusion": "ERM exposes systemic vulnerabilities in power electronics security frameworks, demonstrating that attacks targeting environmental rate dynamics can compromise not only individual sensors but entire classes of hardware dependent on sensor fusion and redundancy mechanisms."}}
{"id": "2509.25248", "categories": ["cs.SE", "cs.AI", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.25248", "abs": "https://arxiv.org/abs/2509.25248", "authors": ["Zehua Zhang", "Ati Priya Bajaj", "Divij Handa", "Siyu Liu", "Arvind S Raj", "Hongkai Chen", "Hulin Wang", "Yibo Liu", "Zion Leonahenahe Basque", "Souradip Nath", "Vishal Juneja", "Nikhil Chapre", "Yan Shoshitaishvili", "Adam Doup\u00e9", "Chitta Baral", "Ruoyu Wang"], "title": "BuildBench: Benchmarking LLM Agents on Compiling Real-World Open-Source Software", "comment": null, "summary": "Automatically compiling open-source software (OSS) projects is a vital,\nlabor-intensive, and complex task, which makes it a good challenge for LLM\nAgents. Existing methods rely on manually curated rules and workflows, which\ncannot adapt to OSS that requires customized configuration or environment\nsetup. Recent attempts using Large Language Models (LLMs) used selective\nevaluation on a subset of highly rated OSS, a practice that underestimates the\nrealistic challenges of OSS compilation. In practice, compilation instructions\nare often absent, dependencies are undocumented, and successful builds may even\nrequire patching source files or modifying build scripts. We propose a more\nchallenging and realistic benchmark, BUILD-BENCH, comprising OSS that are more\ndiverse in quality, scale, and characteristics. Furthermore, we propose a\nstrong baseline LLM-based agent, OSS-BUILD-AGENT, an effective system with\nenhanced build instruction retrieval module that achieves state-of-the-art\nperformance on BUILD-BENCH and is adaptable to heterogeneous OSS\ncharacteristics. We also provide detailed analysis regarding different\ncompilation method design choices and their influence to the whole task,\noffering insights to guide future advances. We believe performance on\nBUILD-BENCH can faithfully reflect an agent's ability to tackle compilation as\na complex software engineering tasks, and, as such, our benchmark will spur\ninnovation with a significant impact on downstream applications in the fields\nof software development and software security.", "AI": {"tldr": "This paper introduces BUILD-BENCH, a realistic benchmark for compiling open-source software (OSS) and proposes an LLM-based agent, OSS-BUILD-AGENT, to address the challenges of automated OSS compilation.", "motivation": "Compiling OSS is a labor-intensive and complex task, and current methods using manually curated rules or selective evaluation fail to address the diverse and realistic challenges of automated compilation.", "method": "The paper presents BUILD-BENCH, a new benchmark featuring diverse-quality OSS projects for realistic compilation tasks, and proposes the OSS-BUILD-AGENT, an LLM agent with an enhanced build instruction retrieval module designed for adaptability and performance.", "result": "OSS-BUILD-AGENT achieves state-of-the-art performance on BUILD-BENCH and demonstrates adaptability to different OSS characteristics, with analysis provided on compilation design choices impacting task effectiveness.", "conclusion": "The proposed benchmark and agent set a new standard for evaluating automated OSS compilation, with the potential to drive innovation and support downstream software development and security applications."}}
{"id": "2509.25525", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.25525", "abs": "https://arxiv.org/abs/2509.25525", "authors": ["Boyang Zhang", "Istemi Ekin Akkus", "Ruichuan Chen", "Alice Dethise", "Klaus Satzke", "Ivica Rimac", "Yang Zhang"], "title": "Defeating Cerberus: Concept-Guided Privacy-Leakage Mitigation in Multimodal Language Models", "comment": null, "summary": "Multimodal large language models (MLLMs) have demonstrated remarkable\ncapabilities in processing and reasoning over diverse modalities, but their\nadvanced abilities also raise significant privacy concerns, particularly\nregarding Personally Identifiable Information (PII) leakage. While relevant\nresearch has been conducted on single-modal language models to some extent, the\nvulnerabilities in the multimodal setting have yet to be fully investigated. In\nthis work, we investigate these emerging risks with a focus on vision language\nmodels (VLMs), a representative subclass of MLLMs that covers the two\nmodalities most relevant for PII leakage, vision and text. We introduce a\nconcept-guided mitigation approach that identifies and modifies the model's\ninternal states associated with PII-related content. Our method guides VLMs to\nrefuse PII-sensitive tasks effectively and efficiently, without requiring\nre-training or fine-tuning. We also address the current lack of multimodal PII\ndatasets by constructing various ones that simulate real-world scenarios.\nExperimental results demonstrate that the method can achieve an average refusal\nrate of 93.3% for various PII-related tasks with minimal impact on unrelated\nmodel performances. We further examine the mitigation's performance under\nvarious conditions to show the adaptability of our proposed method.", "AI": {"tldr": "The paper investigates PII leakage risks in vision-language models (VLMs) and proposes a concept-guided mitigation method to block PII-sensitive tasks without retraining, achieving 93.3% refusal rate with minimal performance impact.", "motivation": "Multimodal models' PII vulnerabilities remain underexplored despite their ability to process privacy-sensitive image and text data. Existing single-modal research neglects cross-modal risks and dataset limitations hinder progress.", "method": "Introduces concept-guided internal state modification to identify and alter PII-related model states, combined with novel multimodal PII datasets simulating real-world scenarios.", "result": "93.3 average refusal rate for PII tasks across conditions with negligible impact on unrelated tasks, validated through extensive experiments and adaptability analysis.", "conclusion": "The proposed method effectively mitigates PII leakage in vision-language models without retraining, addressing current dataset gaps while maintaining model utility."}}
{"id": "2509.25257", "categories": ["cs.SE", "cs.IR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.25257", "abs": "https://arxiv.org/abs/2509.25257", "authors": ["Pratik Shah", "Rajat Ghosh", "Aryan Singhal", "Debojyoti Dutta"], "title": "RANGER -- Repository-Level Agent for Graph-Enhanced Retrieval", "comment": "24 pages, 4 figures", "summary": "General-purpose automated software engineering (ASE) includes tasks such as\ncode completion, retrieval, repair, QA, and summarization. These tasks require\na code retrieval system that can handle specific queries about code entities,\nor code entity queries (for example, locating a specific class or retrieving\nthe dependencies of a function), as well as general queries without explicit\ncode entities, or natural language queries (for example, describing a task and\nretrieving the corresponding code). We present RANGER, a repository-level code\nretrieval agent designed to address both query types, filling a gap in recent\nworks that have focused primarily on code-entity queries. We first present a\ntool that constructs a comprehensive knowledge graph of the entire repository,\ncapturing hierarchical and cross-file dependencies down to the variable level,\nand augments graph nodes with textual descriptions and embeddings to bridge the\ngap between code and natural language. RANGER then operates on this graph\nthrough a dual-stage retrieval pipeline. Entity-based queries are answered\nthrough fast Cypher lookups, while natural language queries are handled by\nMCTS-guided graph exploration. We evaluate RANGER across four diverse\nbenchmarks that represent core ASE tasks including code search, question\nanswering, cross-file dependency retrieval, and repository-level code\ncompletion. On CodeSearchNet and RepoQA it outperforms retrieval baselines that\nuse embeddings from strong models such as Qwen3-8B. On RepoBench, it achieves\nsuperior cross-file dependency retrieval over baselines, and on CrossCodeEval,\npairing RANGER with BM25 delivers the highest exact match rate in code\ncompletion compared to other RAG methods.", "AI": {"tldr": "RANGER is a repository-level code retrieval agent that addresses both code entity and natural language queries with a comprehensive knowledge graph and a dual-stage retrieval pipeline. It outperforms embedding-based baselines in code search and question answering and improves cross-file dependency retrieval and code completion.", "motivation": "Existing methods for automated software engineering tasks primarily focus on code entity queries, leaving a gap in handling general natural language queries effectively. Additionally, gaps still exist in cross-file dependency retrieval and repository-level code completion.", "method": "1. Construct a comprehensive knowledge graph of the entire repository with hierarchical and cross-file dependencies down to the variable level;\n2. Augment graph nodes with textual descriptions and embeddings for code-NLP integration;\n3. Implement a dual-stage retrieval pipeline where entity queries are addressed with Cypher lookups and natural language queries with MCTS-guided exploration.", "result": "RANGER achieves state-of-the-art performance in code search (CodeSearchNet), question answering (RepoQA), and cross-file dependency retrieval (RepoBench). When paired with BM25, it delivers the highest exact match rate in repository-level code completion on CrossCodeEval.", "conclusion": "RANGER is a versatile and efficient repository-level code retrieval agent that bridges code and natural language interactions, offering a robust solution for a wide range of ASE tasks with superior performance across four diverse benchmarks."}}
{"id": "2509.25566", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2509.25566", "abs": "https://arxiv.org/abs/2509.25566", "authors": ["Amal Yousseef", "Shalaka Satam", "Banafsheh Saber Latibari", "Mai Abdel-Malek", "Soheil Salehi", "Pratik Satam"], "title": "Zero Trust-based Decentralized Identity Management System for Autonomous Vehicles", "comment": null, "summary": "The rise of autonomous vehicles (AVs) promises to significantly enhance\ntransportation safety and efficiency by mitigating human error, which is\nresponsible for over 90\\% of road accidents. However, the increasing\nconnectivity of AVs introduces new cybersecurity challenges, as traditional\nperimeter-based security models are inadequate for dynamic and untrusted\nenvironments. This paper presents a novel Zero Trust-based Decentralized\nIdentity Management (D-IM) protocol for AVs. By integrating the core principles\nof Zero Trust Architecture, \"never trust, always verify\", with the tamper\nresistant and decentralized nature of a blockchain network, our framework\neliminates reliance on centralized authorities and provides continuous\nverification for every entity. We detail the system's design, which leverages\nHyperledger Iroha to enable lightweight and secure authentication without a\ncentral trusted entity. A comprehensive experimental evaluation, conducted\nacross both urban and highway scenarios, validates the protocol's practicality.\nOur results demonstrate that the D-IM framework introduces minimal overhead,\nwith less than 7.5\\% reduction in Packet Reception Rate (PRR) in urban settings\nand an increase of under 11\\% in Channel Busy Ratio (CBR) for LTE-V2X. These\nfindings prove the protocol's efficiency and robustness, providing a resilient\nfoundation for securing real-time V2X communication against impersonation and\nreplay attacks.", "AI": {"tldr": "This paper proposes a blockchain-enabled Zero Trust security framework for AVs, achieving strong cybersecurity with minimal performance impact.", "motivation": "Traditional perimeter-based security models are insufficient for AVs' dynamic, untrusted environments due to their reliance on centralized authorities and inability to continuously verify entities.", "method": "A Zero Trust-based Decentralized Identity Management (D-IM) protocol was developed by integrating Zero Trust Architecture principles with blockchain's tamper-resistant properties. Hyperledger Iroha was utilized for lightweight, secure authentication without centralized authority.", "result": "Experiments showed the protocol introduced <7.5% PRR reduction in urban settings and <11% CBR increase for LTE-V2X, demonstrating efficiency and robustness against cyberattacks.", "conclusion": "The D-IM framework provides a resilient and efficient solution for securing real-time V2X communication in AVs, effectively addressing impersonation and replay attacks while maintaining minimal performance overhead."}}
{"id": "2509.25297", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.25297", "abs": "https://arxiv.org/abs/2509.25297", "authors": ["Yuxuan Wan", "Tingshuo Liang", "Jiakai Xu", "Jingyu Xiao", "Yintong Huo", "Michael R. Lyu"], "title": "Automatically Generating Web Applications from Requirements Via Multi-Agent Test-Driven Development", "comment": null, "summary": "Developing full-stack web applications is complex and time-intensive,\ndemanding proficiency across diverse technologies and frameworks. Although\nrecent advances in multimodal large language models (MLLMs) enable automated\nwebpage generation from visual inputs, current solutions remain limited to\nfront-end tasks and fail to deliver fully functional applications. In this\nwork, we introduce TDDev, the first test-driven development (TDD)-enabled\nLLM-agent framework for end-to-end full-stack web application generation. Given\na natural language description or design image, TDDev automatically derives\nexecutable test cases, generates front-end and back-end code, simulates user\ninteractions, and iteratively refines the implementation until all requirements\nare satisfied. Our framework addresses key challenges in full-stack automation,\nincluding underspecified user requirements, complex interdependencies among\nmultiple files, and the need for both functional correctness and visual\nfidelity. Through extensive experiments on diverse application scenarios, TDDev\nachieves a 14.4% improvement on overall accuracy compared to state-of-the-art\nbaselines, demonstrating its effectiveness in producing reliable, high-quality\nweb applications without requiring manual intervention.", "AI": {"tldr": "This paper introduces TDDev, the first test-driven development (TDD)-enabled LLM-agent framework for end-to-end full-stack web application generation, achieving higher accuracy than existing solutions.", "motivation": "Current MLLMs for web development focus only on front-end tasks and lack test-driven approaches, leading to underspecified requirements, fragmented code dependencies, and functional/visual fidelity challenges in automation.", "method": "TDDev automatically (1) generates executable test cases from natural language/images, (2) creates front-end/back-end code, (3)f simulates user interactions, and (4)f iteratively refines implementation until test requirements are met, addressing cross-file dependencies and UI/UX expectations.", "result": "Experiments show TDDev improves overall accuracy by 14.4 percentage points compared to state-of-the-art baselines across diverse application scenarios.", "conclusion": "TDDev demonstrates the feasibility of test-driven automated full-stack web development, producing reliable applications with minimal manual intervention, opening new directions for LLM-agent based software engineering pipelines."}}
{"id": "2509.25624", "categories": ["cs.CR", "cs.AI", "cs.CL", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.25624", "abs": "https://arxiv.org/abs/2509.25624", "authors": ["Jing-Jing Li", "Jianfeng He", "Chao Shang", "Devang Kulshreshtha", "Xun Xian", "Yi Zhang", "Hang Su", "Sandesh Swamy", "Yanjun Qi"], "title": "STAC: When Innocent Tools Form Dangerous Chains to Jailbreak LLM Agents", "comment": null, "summary": "As LLMs advance into autonomous agents with tool-use capabilities, they\nintroduce security challenges that extend beyond traditional content-based LLM\nsafety concerns. This paper introduces Sequential Tool Attack Chaining (STAC),\na novel multi-turn attack framework that exploits agent tool use. STAC chains\ntogether tool calls that each appear harmless in isolation but, when combined,\ncollectively enable harmful operations that only become apparent at the final\nexecution step. We apply our framework to automatically generate and\nsystematically evaluate 483 STAC cases, featuring 1,352 sets of\nuser-agent-environment interactions and spanning diverse domains, tasks, agent\ntypes, and 10 failure modes. Our evaluations show that state-of-the-art LLM\nagents, including GPT-4.1, are highly vulnerable to STAC, with attack success\nrates (ASR) exceeding 90% in most cases. The core design of STAC's automated\nframework is a closed-loop pipeline that synthesizes executable multi-step tool\nchains, validates them through in-environment execution, and reverse-engineers\nstealthy multi-turn prompts that reliably induce agents to execute the verified\nmalicious sequence. We further perform defense analysis against STAC and find\nthat existing prompt-based defenses provide limited protection. To address this\ngap, we propose a new reasoning-driven defense prompt that achieves far\nstronger protection, cutting ASR by up to 28.8%. These results highlight a\ncrucial gap: defending tool-enabled agents requires reasoning over entire\naction sequences and their cumulative effects, rather than evaluating isolated\nprompts or responses.", "AI": {"tldr": "LLM agents are vulnerable to STAC attacks where seemingly harmless tool calls are chained to perform harmful actions, and a new defense strategy effectively reduces attack success rates.", "motivation": "As autonomous LLM agents become more prevalent, their use of tools introduces new security challenges beyond traditional content-based safety issues. Priorities needed to assess sequence-based vulnerabilities.", "method": "The authors develop STAC, a multi-turn attack framework that automatically generates and validates harmful sequences of tool calls. They also test existing defenses and propose a reasoning-based defense prompt.", "result": "Evaluation shows high vulnerability (ASR >90%) in state-of-the-art LLM agents like GPT-4.1 to STAC. The new defense reduces ASR by up to 28.8%.", "conclusion": "STAC highlights the need for defenses that reason about entire action sequences rather than individual prompts or responses."}}
{"id": "2509.25378", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.25378", "abs": "https://arxiv.org/abs/2509.25378", "authors": ["Akalanka Galappaththi", "Francisco Ribeiro", "Sarah Nadi"], "title": "Detecting and Fixing API Misuses of Data Science Libraries Using Large Language Models", "comment": "10 pages, 3 figures, accepted in CASCON 25", "summary": "Data science libraries, such as scikit-learn and pandas, specialize in\nprocessing and manipulating data. The data-centric nature of these libraries\nmakes the detection of API misuse in them more challenging. This paper\nintroduces DSCHECKER, an LLM-based approach designed for detecting and fixing\nAPI misuses of data science libraries. We identify two key pieces of\ninformation, API directives and data information, that may be beneficial for\nAPI misuse detection and fixing. Using three LLMs and misuses from five data\nscience libraries, we experiment with various prompts. We find that\nincorporating API directives and data-specific details enhances Dschecker's\nability to detect and fix API misuses, with the best-performing model achieving\na detection F1-score of 61.18 percent and fixing 51.28 percent of the misuses.\nBuilding on these results, we implement Dschecker agent which includes an\nadaptive function calling mechanism to access information on demand, simulating\na real-world setting where information about the misuse is unknown in advance.\nWe find that Dschecker agent achieves 48.65 percent detection F1-score and\nfixes 39.47 percent of the misuses, demonstrating the promise of LLM-based API\nmisuse detection and fixing in real-world scenarios.", "AI": {"tldr": "DSCHECKER, an LLM-based tool for detecting and fixing API misuses in data science libraries, demonstrates strong performance (up to 61.18% detection F1-score) and effective adaptability in real-world scenarios, offering a promising solution to a challenging problem.", "motivation": "The data-centric nature of libraries like scikit-learn and pandas complicates API misuse detection. Traditional methods struggle with this complexity, necessitating new approaches.", "method": "DSCHECKER is an LLM-based approach that leverages API directives and data-specific information. It uses three LLMs, misuses from five libraries, and adaptive function calling mechanisms to simulate real-world conditions.", "result": "The best model achieved 61.18% detection F1-score and fixed 51.28% of misuses. The DSCHECKER agent achieved 48.65% detection F1-score and resolved 39.47% of misuses in real-world simulations.", "conclusion": "The paper concludes that LLM-based approaches like DSCHECKER show promise in detecting and fixing API misuses in data science libraries, even in real-world scenarios where misuse information is unknown in advance."}}
{"id": "2509.25926", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.25926", "abs": "https://arxiv.org/abs/2509.25926", "authors": ["Dennis Jacob", "Emad Alghamdi", "Zhanhao Hu", "Basel Alomair", "David Wagner"], "title": "Better Privilege Separation for Agents by Restricting Data Types", "comment": null, "summary": "Large language models (LLMs) have become increasingly popular due to their\nability to interact with unstructured content. As such, LLMs are now a key\ndriver behind the automation of language processing systems, such as AI agents.\nUnfortunately, these advantages have come with a vulnerability to prompt\ninjections, an attack where an adversary subverts the LLM's intended\nfunctionality with an injected task. Past approaches have proposed detectors\nand finetuning to provide robustness, but these techniques are vulnerable to\nadaptive attacks or cannot be used with state-of-the-art models. To this end we\npropose type-directed privilege separation for LLMs, a method that\nsystematically prevents prompt injections. We restrict the ability of an LLM to\ninteract with third-party data by converting untrusted content to a curated set\nof data types; unlike raw strings, each data type is limited in scope and\ncontent, eliminating the possibility for prompt injections. We evaluate our\nmethod across several case studies and find that designs leveraging our\nprinciples can systematically prevent prompt injection attacks while\nmaintaining high utility.", "AI": {"tldr": "This paper proposes a novel security framework for LLMs using type-directed privilege separation to block prompt injection attacks by restricting interactions to strictly defined data types, ensuring both safety and performance.", "motivation": "Current defense mechanisms against prompt injection (e.g., detectors, finetuning) are ineffective against adaptive attacks or incompatible with state-of-the-art LLMs, necessitating a more robust and universally applicable solution.", "method": "The paper introduces type-directed privilege separation, which enforces security by converting untrusted content into a curated set of restricted data types, limiting the LLM\u2019s interaction scope to eliminate prompt injection vulnerabilities.", "result": "Case studies show that the proposed method systematically prevents prompt injection attacks while maintaining high system utility, demonstrating its effectiveness and practicality.", "conclusion": "Type-directed privilege separation provides a systematic and effective solution to prevent prompt injection attacks in LLMs without compromising utility, offering a robust alternative to existing vulnerable approaches."}}
{"id": "2509.25397", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.25397", "abs": "https://arxiv.org/abs/2509.25397", "authors": ["Johan Lin\u00e5ker", "Cailean Osborne", "Jennifer Ding", "Ben Burtenshaw"], "title": "A Cartography of Open Collaboration in Open Source AI: Mapping Practices, Motivations, and Governance in 14 Open Large Language Model Projects", "comment": "In submission", "summary": "The proliferation of open large language models (LLMs) is fostering a vibrant\necosystem of research and innovation in artificial intelligence (AI). However,\nthe methods of collaboration used to develop open LLMs both before and after\ntheir public release have not yet been comprehensively studied, limiting our\nunderstanding of how open LLM projects are initiated, organized, and governed\nas well as what opportunities there are to foster this ecosystem even further.\nWe address this gap through an exploratory analysis of open collaboration\nthroughout the development and reuse lifecycle of open LLMs, drawing on\nsemi-structured interviews with the developers of 14 open LLMs from grassroots\nprojects, research institutes, startups, and Big Tech companies in North\nAmerica, Europe, Africa, and Asia. We make three key contributions to research\nand practice. First, collaboration in open LLM projects extends far beyond the\nLLMs themselves, encompassing datasets, benchmarks, open source frameworks,\nleaderboards, knowledge sharing and discussion forums, and compute\npartnerships, among others. Second, open LLM developers have a variety of\nsocial, economic, and technological motivations, from democratizing AI access\nand promoting open science to building regional ecosystems and expanding\nlanguage representation. Third, the sampled open LLM projects exhibit five\ndistinct organizational models, ranging from single company projects to\nnon-profit-sponsored grassroots projects, which vary in their centralization of\ncontrol and community engagement strategies used throughout the open LLM\nlifecycle. We conclude with practical recommendations for stakeholders seeking\nto support the global community building a more open future for AI.", "AI": {"tldr": "This paper analyzes collaboration patterns in open LLM development through 14 case studies across global organizations, revealing diverse collaboration types, developer motivations, and organizational models.", "motivation": "Prior research has not comprehensively examined how open LLM projects are collaboratively developed and governed, limiting opportunities to enhance the open AI ecosystem.", "method": "Semi-structured interviews with developers from 14 open LLM projects (including grassroots, research, startups, and Big Tech) across North America, Europe, Africa, and Asia.", "result": "Three findings: (1)demonstration of multi-dimensional collaboration beyond models (e.g., datasets, frameworks), (2)diverse developer motivations (democratizing AI, regional ecosystems), (3)identification of five organizational models differing in centralization and community engagement.", "conclusion": "Provides practical recommendations for stakeholders to support open LLM ecosystem growth, emphasizing varied collaboration strategies and governance models."}}
{"id": "2509.26350", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.26350", "abs": "https://arxiv.org/abs/2509.26350", "authors": ["Tharindu Lakshan Yasarathna", "Nhien-An Le-Khac"], "title": "SoK: Systematic analysis of adversarial threats against deep learning approaches for autonomous anomaly detection systems in SDN-IoT networks", "comment": null, "summary": "Integrating SDN and the IoT enhances network control and flexibility.\nDL-based AAD systems improve security by enabling real-time threat detection in\nSDN-IoT networks. However, these systems remain vulnerable to adversarial\nattacks that manipulate input data or exploit model weaknesses, significantly\ndegrading detection accuracy. Existing research lacks a systematic analysis of\nadversarial vulnerabilities specific to DL-based AAD systems in SDN-IoT\nenvironments. This SoK study introduces a structured adversarial threat model\nand a comprehensive taxonomy of attacks, categorising them into data, model,\nand hybrid-level threats. Unlike previous studies, we systematically evaluate\nwhite, black, and grey-box attack strategies across popular benchmark datasets.\nOur findings reveal that adversarial attacks can reduce detection accuracy by\nup to 48.4%, with Membership Inference causing the most significant drop. C&W\nand DeepFool achieve high evasion success rates. However, adversarial training\nenhances robustness, and its high computational overhead limits the real-time\ndeployment of SDN-IoT applications. We propose adaptive countermeasures,\nincluding real-time adversarial mitigation, enhanced retraining mechanisms, and\nexplainable AI-driven security frameworks. By integrating structured threat\nmodels, this study offers a more comprehensive approach to attack\ncategorisation, impact assessment, and defence evaluation than previous\nresearch. Our work highlights critical vulnerabilities in existing DL-based AAD\nmodels and provides practical recommendations for improving resilience,\ninterpretability, and computational efficiency. This study serves as a\nfoundational reference for researchers and practitioners seeking to enhance\nDL-based AAD security in SDN-IoT networks, offering a systematic adversarial\nthreat model and conceptual defence evaluation based on prior empirical\nstudies.", "AI": {"tldr": "The paper examines adversarial attacks on DL-based AAD systems in SDN-IoT networks. It introduces a structured threat model, taxonomy, and finds that attacks reduce accuracy by up to 48.4%. They propose adaptive defenses like adversarial training but note its computational cost.", "motivation": "The motivation stems from the rising adoption of SDN and IoT and the need for advanced security. Traditional security measures are inadequate against adversarial attacks that exploit DL systems. The authors enhance network security by offering deeper analysis of adversarial vulnerabilities and refined defense strategies.", "method": "The research methodology includes developing a threat model and taxonomy for adversarial attacks on SDN-IoT systems. It systematically evaluates attack types (white, black, grey-box strategies) on benchmark datasets using C&W and DeepFool techniques to simulate real threat scenarios.", "result": "The results identify membership inference as the most damaging attack type. Adversarial attacks cause up to 48.4% drop in detection accuracy, while C&W and DeepFool report high evasion rates. The study shows that adversarial training bolsters system robustness but imposes high computational demands.", "conclusion": "The conclusion emphasizes the integration of structured threat models and adaptive defenses like adversarial training, real-time mitigation, and explainable AI for securing DL-based AAD systems. The work lays a foundation for future research into efficient, resilient, and interpretable SDN-IoT security solutions."}}
{"id": "2509.25455", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.25455", "abs": "https://arxiv.org/abs/2509.25455", "authors": ["Alexander Kovrigin", "Aleksandra Eliseeva", "Konstantin Grotov", "Egor Bogomolov", "Yaroslav Zharov"], "title": "PIPer: On-Device Environment Setup via Online Reinforcement Learning", "comment": "Under review", "summary": "Environment setup-the process of configuring the system to work with a\nspecific software project-represents a persistent challenge in Software\nEngineering (SE). Automated environment setup methods could assist developers\nby providing fully configured environments for arbitrary repositories without\nmanual effort. This also helps SE researchers to scale execution-based\nbenchmarks. However, recent studies reveal that even state-of-the-art Large\nLanguage Models (LLMs) achieve limited success in automating this task. To\naddress this limitation, we tune a specialized model for environment setup. We\ncombine supervised fine-tuning for generating correct Bash scripts and\nReinforcement Learning with Verifiable Rewards (RLVR) to adapt it to the task\nof environment setup. On EnvBench-Python, our method enables Qwen3-8B (a model\nrunnable on consumer hardware) to perform on par with larger models-Qwen3-32B\nand GPT-4o. The training code and model checkpoints are available online:\nhttps://github.com/JetBrains-Research/PIPer.", "AI": {"tldr": "This paper introduces a specialized LLM training approach combining RLVR and supervised fine-tuning to improve environment setup automation, achieving state-of-the-art performance with smaller models.", "motivation": "Current LLM-based methods struggle with environment setup automation, creating a need for improved solutions to reduce developers' manual efforts and enable scalable benchmarking in software engineering research.", "method": "The authors employ supervised fine-tuning to generate correct Bash scripts and implement Reinforcement Learning with Verifiable Rewards (RLVR) to adapt the model to environment setup tasks.", "result": "On EnvBench-Python, the method enables Qwen3-8B to match the performance of larger models (Qwen3-32B, GPT-4o) in environment setup tasks while being hardware-efficient.", "conclusion": "The study demonstrates that a specialized model trained with RLVR and supervised fine-tuning can significantly enhance environment setup automation. The approach achieves comparable performance to larger models with open-source accessibility."}}
{"id": "2509.26393", "categories": ["cs.CR", "cs.IT", "math.IT"], "pdf": "https://arxiv.org/pdf/2509.26393", "abs": "https://arxiv.org/abs/2509.26393", "authors": ["Maciej Skorski", "Francisco-Javier Soto", "Onur G\u00fcnl\u00fc"], "title": "Exact Bias of Linear TRNG Correctors -- Spectral Approach", "comment": null, "summary": "Using Fourier analysis, this paper establishes exact security bounds for\nlinear extractors in True Random Number Generators (TRNGs). We provide the\nfirst near-optimal total variation security characterization by interpolating\nbetween optimal $\\ell_{\\infty}$ and $\\ell_2$ norm results, expressed through\ncode weight enumerators and input bias parameters. Our bounds improve security\nassessments by an order of magnitude over previous approximations. By scanning\n~20,000 codes, we reveal fundamental trade-offs between compression efficiency\nand cryptographic security. For instance, we show that achieving 80 bits of\nsecurity can require sacrificing more than 50\\% of the code rate when\ncorrecting 10\\% input bias. Our bounds enhance security evaluation of TRNG\npost-processing schemes and quantify the inherent cost of randomness extraction\nin hardware implementations.", "AI": {"tldr": "This paper analytically establishes near-optimal security bounds for linear TRNG extractors using Fourier analysis, revealing trade-offs between compression and security through extensive code evaluations.", "motivation": "Previous TRNG security approximations lacked precision, necessitating a rigorous mathematical framework to quantify cryptographic security and extraction costs in hardware implementations.", "method": "The authors combine \u2113\u221e and \u21132 norm analyses via code weight enumerators and input bias parameters, using Fourier analysis to bridge theoretical bounds. They validate these by scanning ~20,000 codes for empirical trade-off measurements.", "result": "1) Improved total variation security bounds by an order of magnitude\n2) Revealed 50% code rate sacrifice required for 80-bit security at 10% input bias\n3) Demonstrated fundamental compression-security trade-offs across real-world TRNG scenarios", "conclusion": "The work enables precise TRNG post-processing evaluation, proving that high security demands significant compression efficiency trade-offs in hardware, which directly impacts practical randomness extraction costs."}}
{"id": "2509.25465", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.25465", "abs": "https://arxiv.org/abs/2509.25465", "authors": ["Yinghang Ma", "Jiho Shin", "Leuson Da Silva", "Zhen Ming", "Jiang", "Song Wang", "Foutse Khomh", "Shin Hwei Tan"], "title": "BloomAPR: A Bloom's Taxonomy-based Framework for Assessing the Capabilities of LLM-Powered APR Solutions", "comment": "22 pages, 7 figures, Manuscript submitted to ACM Transactions on\n  Software Engineering and Methodology", "summary": "Recent advances in large language models (LLMs) have accelerated the\ndevelopment of AI-driven automated program repair (APR) solutions. However,\nthese solutions are typically evaluated using static benchmarks such as\nDefects4J and SWE-bench, which suffer from two key limitations: (1) the risk of\ndata contamination, potentially inflating evaluation results due to overlap\nwith LLM training data, and (2) limited ability to assess the APR capabilities\nin dynamic and diverse contexts. In this paper, we introduced BloomAPR, a novel\ndynamic evaluation framework grounded in Bloom's Taxonomy. Our framework offers\na structured approach to assess the cognitive capabilities of LLM-powered APR\nsolutions across progressively complex reasoning levels. Using Defects4J as a\ncase study, we evaluated two state-of-the-art LLM-powered APR solutions,\nChatRepair and CigaR, under three different LLMs: GPT-3.5-Turbo, Llama-3.1, and\nStarCoder-2. Our findings show that while these solutions exhibit basic\nreasoning skills and effectively memorize bug-fixing patterns (fixing up to\n81.57% of bugs at the Remember layer), their performance increases with\nsynthetically generated bugs (up to 60.66% increase at the Understand layer).\nHowever, they perform worse on minor syntactic changes (fixing up to 43.32% at\nthe Apply layer), and they struggle to repair similar bugs when injected into\nreal-world projects (solving only 13.46% to 41.34% bugs at the Analyze layer).\nThese results underscore the urgent need for evolving benchmarks and provide a\nfoundation for more trustworthy evaluation of LLM-powered software engineering\nsolutions.", "AI": {"tldr": "BloomAPR: A dynamic evaluation framework for LLM-driven APR systems reveals performance gaps under synthetic/real-world conditions, stressing the need for evolving benchmarks to accurately assess cognitive capabilities.", "motivation": "Static benchmarks (e.g., Defects4J, SWE-bench) face issues of data contamination and limited ability to assess APR systems in dynamic, context-diverse environments, leading to inflated and unreliable evaluation results.", "method": "The authors proposed BloomAPR, a dynamic evaluation framework based on Bloom's Taxonomy, and evaluated state-of-the-art LLM-powered APR systems (ChatRepair and CigaR) across three LLMs (GPT-3.5-Turbo, Llama-3.1, StarCoder-2) using Defects4J as a case study.", "result": "Results show APR systems excel in memorizing patterns (81.57% at 'Remember' layer), perform better with synthetic bugs (60.66% increase at 'Understand'), but struggle with syntactic changes (43.32% at 'Apply') and real-world scenarios (13.46%-41.34% at 'Analyze'), highlighting significant room for improvement.", "conclusion": "The paper concludes that current static benchmarks for evaluating LLM-powered APR systems are insufficient, emphasizing the need for dynamic evaluation frameworks like BloomAPR to ensure more trustworthy assessments of such solutions."}}
{"id": "2509.26404", "categories": ["cs.CR", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2509.26404", "abs": "https://arxiv.org/abs/2509.26404", "authors": ["Yao Tong", "Haonan Wang", "Siquan Li", "Kenji Kawaguchi", "Tianyang Hu"], "title": "SeedPrints: Fingerprints Can Even Tell Which Seed Your Large Language Model Was Trained From", "comment": null, "summary": "Fingerprinting Large Language Models (LLMs) is essential for provenance\nverification and model attribution. Existing methods typically extract post-hoc\nsignatures based on training dynamics, data exposure, or hyperparameters --\nproperties that only emerge after training begins. In contrast, we propose a\nstronger and more intrinsic notion of LLM fingerprinting: SeedPrints, a method\nthat leverages random initialization biases as persistent, seed-dependent\nidentifiers present even before training. We show that untrained models exhibit\nreproducible token selection biases conditioned solely on their parameters at\ninitialization. These biases are stable and measurable throughout training,\nenabling our statistical detection method to recover a model's lineage with\nhigh confidence. Unlike prior techniques, unreliable before convergence and\nvulnerable to distribution shifts, SeedPrints remains effective across all\ntraining stages and robust under domain shifts or parameter modifications.\nExperiments on LLaMA-style and Qwen-style models show that SeedPrints achieves\nseed-level distinguishability and can provide birth-to-lifecycle identity\nverification akin to a biometric fingerprint. Evaluations on large-scale\npretrained models and fingerprinting benchmarks further confirm its\neffectiveness under practical deployment scenarios. These results suggest that\ninitialization itself imprints a unique and persistent identity on neural\nlanguage models, forming a true ''Galtonian'' fingerprint.", "AI": {"tldr": "SeedPrints introduces a novel LLM fingerprinting method using initialization biases as persistent, seed-dependent identifiers detectable before training, offering a robust alternative to post-hoc techniques.", "motivation": "Existing LLM fingerprinting methods rely on post-training dynamics/data, which are unreliable before convergence and vulnerable to distribution shifts. SeedPrints addresses this by leveraging inherent initialization biases to establish early, persistent identity markers.", "method": "Exploits reproducible token selection biases in untrained models caused by parameter initialization. Statistical detection tracks these stable biases through training, enabling seed-level identification immune to domain shifts or parameter changes.", "result": "Experiments on LLaMA/Qwen-style models show SeedPrints achieves high-confidence lifecycle fingerprinting, outperforming prior methods in distinguishing seed-dependent identities and maintaining effectiveness during training.", "conclusion": "Initialization itself creates a persistent, Galtonian-like fingerprint in LLMs, enabling birth-to-convergence biometric identification without reliance on training dynamics or data exposure."}}
{"id": "2509.25514", "categories": ["cs.SE", "cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.25514", "abs": "https://arxiv.org/abs/2509.25514", "authors": ["Yonatan Gizachew Achamyeleh", "Tongtao Zhang", "Joshua Hyunki Kim", "Gabriel Garcia", "Shih-Yuan Yu", "Anton Kocheturov", "Mohammad Abdullah Al Faruque"], "title": "AGNOMIN -- Architecture Agnostic Multi-Label Function Name Prediction", "comment": null, "summary": "Function name prediction is crucial for understanding stripped binaries in\nsoftware reverse engineering, a key step for \\textbf{enabling subsequent\nvulnerability analysis and patching}. However, existing approaches often\nstruggle with architecture-specific limitations, data scarcity, and diverse\nnaming conventions. We present AGNOMIN, a novel architecture-agnostic approach\nfor multi-label function name prediction in stripped binaries. AGNOMIN builds\nFeature-Enriched Hierarchical Graphs (FEHGs), combining Control Flow Graphs,\nFunction Call Graphs, and dynamically learned \\texttt{PCode} features. A\nhierarchical graph neural network processes this enriched structure to generate\nconsistent function representations across architectures, vital for\n\\textbf{scalable security assessments}. For function name prediction, AGNOMIN\nemploys a Ren\\'ee-inspired decoder, enhanced with an attention-based head layer\nand algorithmic improvements.\n  We evaluate AGNOMIN on a comprehensive dataset of 9,000 ELF executable\nbinaries across three architectures, demonstrating its superior performance\ncompared to state-of-the-art approaches, with improvements of up to 27.17\\% in\nprecision and 55.86\\% in recall across the testing dataset. Moreover, AGNOMIN\ngeneralizes well to unseen architectures, achieving 5.89\\% higher recall than\nthe closest baseline. AGNOMIN's practical utility has been validated through\nsecurity hackathons, where it successfully aided reverse engineers in analyzing\nand patching vulnerable binaries across different architectures.", "AI": {"tldr": "AGNOMIN tackles stripped binary reverse engineering via architecture-agnostic graph neural networks, achieving state-of-the-art performance (27%+ precision, 56%+ recall gains) and verified practicality in real-world security assessments.", "motivation": "Existing methods for function name prediction in stripped binaries face architecture-specific constraints, data scarcity, and inconsistent naming conventions, limiting their scalability and effectiveness in vulnerability analysis and patching across heterogeneous architectures.", "method": "AGNOMIN constructs Feature-Enriched Hierarchical Graphs (FEHGs) combining CFGs, FCGs, and PCode features, processed by a hierarchical GNN to create architecture-agnostic function representations. It uses a Ren\u00e9e-inspired decoder with attention mechanisms and algorithmic optimizations.", "result": "AGNOMIN outperforms state-of-the-art approaches by 27.17% in precision and 55.86% in recall on 9,000+ ELF binaries across three architectures. It achieves 5.89% higher recall on unseen architectures and demonstrates practical utility in security hackathons for vulnerability analysis.", "conclusion": "AGNOMIN offers a scalable, architecture-agnostic solution for multi-label function name prediction, effectively addressing limitations of prior methods and demonstrating significant improvements in precision, recall, and cross-architecture generalizability."}}
{"id": "2509.26509", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2509.26509", "abs": "https://arxiv.org/abs/2509.26509", "authors": ["Raghul Saravanan", "Sai Manoj P D"], "title": "Logic Solver Guided Directed Fuzzing for Hardware Designs", "comment": null, "summary": "The ever-increasing complexity of design specifications for processors and\nintellectual property (IP) presents a formidable challenge for early bug\ndetection in the modern IC design cycle. The recent advancements in hardware\nfuzzing have proven effective in detecting bugs in RTL designs of cutting-edge\nprocessors. The modern IC design flow involves incremental updates and\nmodifications to the hardware designs necessitating rigorous verification and\nextending the overall verification period. To accelerate this process, directed\nfuzzing has emerged focusing on generating targeted stimuli for specific\nregions of the design, avoiding the need for exhaustive, full-scale\nverification. However, a significant limitation of these hardware fuzzers lies\nin their reliance on an equivalent SW model of the hardware which fails to\ncapture intrinsic hardware characteristics. To circumvent the aforementioned\nchallenges, this work introduces TargetFuzz, an innovative and scalable\ntargeted hardware fuzzing mechanism. It leverages SAT-based techniques to focus\non specific regions of the hardware design while operating at its native\nhardware abstraction level, ensuring a more precise and comprehensive\nverification process. We evaluated this approach across a diverse range of RTL\ndesigns for various IP cores. Our experimental results demonstrate its\ncapability to effectively target and fuzz a broad spectrum of sites within\nthese designs, showcasing its extensive coverage and precision in addressing\ntargeted regions. TargetFuzz demonstrates its capability to effectively scale\n30x greater in terms of handling target sites, achieving 100% state coverage\nand 1.5x faster in terms of site coverage, and shows 90x improvement in target\nstate coverage compared to Coverage-Guided Fuzzing, demonstrating its potential\nto advance the state-of-the-art in directed hardware fuzzing.", "AI": {"tldr": "TargetFuzz is a new directed hardware fuzzing tool that uses SAT-based techniques to improve bug detection in complex IC designs by targeting specific regions without relying on SW models.", "motivation": "The increasing complexity of modern IC design specifications makes early bug detection challenging. Traditional hardware fuzzing methods rely on SW equivalent models which can miss hardware-specific characteristics, leading to inefficient verification.", "method": "TargetFuzz employs SAT-based techniques to perform targeted fuzzing directly at the native hardware abstraction level, eliminating the need for SW models. This approach allows it to focus on specific regions of a hardware design for more efficient and accurate verification.", "result": "Evaluation on various IP core RTL designs showed TargetFuzz can target a wide range of sites with 100% state coverage and 1.5x faster site coverage than Coverage-Guided Fuzzing. It also achieved 90x improvement in target state coverage.", "conclusion": "TargetFuzz represents a significant advancement in directed hardware fuzzing, offering scalable and precise verification without the drawbacks of SW model dependencies."}}
{"id": "2509.25625", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.25625", "abs": "https://arxiv.org/abs/2509.25625", "authors": ["Luiza Martins de Freitas Cintra", "Philipp Zech", "Mohamad Kassab", "Eliomar Ara\u00fajo Lima", "Sofia Larissa da Costa Paiva", "Valdemar Vicente Graciano Neto"], "title": "M&SCheck: Towards a Checklist to Support Software Engineering Newcomers to the Modeling and Simulation Area", "comment": null, "summary": "The advent of increasingly complex and dynamic ecosystems, such as digital\ntwins (DT), smart cities and Industry 4.0 and 5.0, has made evident the need to\ninclude modeling and simulation (M&S) in the software development life cycle.\nSuch disruptive systems include simulation models in their own architecture\n(such as DT) or require the use of simulation models to represent the high\ndegree of movement and the multiplicity of interactions that occur between the\ninvolved systems. However, when software engineers (particularly the newcomers)\nneed to use M&S in their projects, they often pose themselves an important\nquestion: which formalism should I use? In this direction, the main\ncontribution of this paper is the establishment of a preliminary checklist with\nquestions to assist beginners in M&S in choosing the most appropriate paradigm\nto solve their problems. The checklist is based on three main formalisms: DEVS,\nSystem Dynamics and Agent-Based Simulation. A pilot study was carried out and\nan expert was consulted. The preliminary results show (i) conformance between\nthe suggestion given by the checklist and the formalism selected in the\noriginal studies used as input for evaluating the checklist, and (ii) a\npositive feedback from the expert.", "AI": {"tldr": "This paper proposes a checklist to help beginners choose modeling/simulation formalisms (DEVS, System Dynamics, Agent-Based), validated via pilot studies and expert feedback. The checklist shows promise in aligning with existing solutions and aiding decision-making.", "motivation": "The increasing complexity of systems like digital twins and Industry 4.0 requires modeling and simulation (M&S), but newcomers struggle to choose the appropriate formalism, creating a need for guidance tools.", "method": "The authors developed a checklist based on three formalisms (DEVS, System Dynamics, Agent-Based Simulation) and evaluated it through a pilot study, comparing its suggestions to formalisms in original studies and using expert consultation for validation.", "result": "The checklist demonstrated (i) alignment with formalisms selected in original studies used for evaluation, and (ii) positive feedback from an expert, validating its preliminary effectiveness.", "conclusion": "The paper concludes that the proposed checklist effectively assists beginners in selecting appropriate modeling and simulation formalisms, showing alignment with existing studies and positive expert feedback. Further validation with a larger sample is recommended."}}
{"id": "2509.26530", "categories": ["cs.CR", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2509.26530", "abs": "https://arxiv.org/abs/2509.26530", "authors": ["Aleksandra Knapi\u0144ska", "Marija Furdek"], "title": "Explainable and Resilient ML-Based Physical-Layer Attack Detectors", "comment": null, "summary": "Detection of emerging attacks on network infrastructure is a critical aspect\nof security management. To meet the growing scale and complexity of modern\nthreats, machine learning (ML) techniques offer valuable tools for automating\nthe detection of malicious activities. However, as these techniques become more\ncomplex, their internal operations grow increasingly opaque. In this context,\nwe address the need for explainable physical-layer attack detection methods.\nFirst, we analyze the inner workings of various classifiers trained to alert\nabout physical layer intrusions, examining how the influence of different\nmonitored parameters varies depending on the type of attack being detected.\nThis analysis not only improves the interpretability of the models but also\nsuggests ways to enhance their design for increased speed. In the second part,\nwe evaluate the detectors' resilience to malicious parameter noising. The\nresults highlight a key trade-off between model speed and resilience. This work\nserves as a design guideline for developing fast and robust detectors trained\non available network monitoring data.", "AI": {"tldr": "This paper proposes explainable machine learning methods for physical-layer attack detection, analyzing model interpretability and resilience trade-offs to guide fast, robust detector design.", "motivation": "Modern network threats require automated detection via ML, but complex models lack transparency. Explainable methods improve interpretability and efficiency for physical-layer intrusion detection.", "method": "1) Analyze classifier parameter influence on attack detection for interpretability and design optimization. 2\uff09Evaluate detectors' resilience against parameter noising to identify speed-robustness trade-offs.", "result": "Reveals inherent trade-off between model speed and resilience to adversarial parameter perturbations. Provides design principles for balancing these factors in network monitoring systems.", "conclusion": "The work establishes critical guidelines for developing explainable, high-performance detectors leveraging network monitoring data while maintaining robustness against evasion attacks."}}
{"id": "2509.25676", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.25676", "abs": "https://arxiv.org/abs/2509.25676", "authors": ["Fang Liu", "Tianze Wang", "Li Zhang", "Zheyu Yang", "Jing Jiang", "Zian Sun"], "title": "Explainable Fault Localization for Programming Assignments via LLM-Guided Annotation", "comment": "Accepted by ASE'2025", "summary": "Providing timely and personalized guidance for students' programming\nassignments, offers significant practical value for helping students complete\nassignments and enhance their learning. In recent years, various automated\nFault Localization (FL) techniques have demonstrated promising results in\nidentifying errors in programs. However, existing FL techniques face challenges\nwhen applied to educational contexts. Most approaches operate at the method\nlevel without explanatory feedback, resulting in granularity too coarse for\nstudents who need actionable insights to identify and fix their errors. While\nsome approaches attempt line-level fault localization, they often depend on\npredicting line numbers directly in numerical form, which is ill-suited to\nLLMs. To address these challenges, we propose FLAME, a fine-grained,\nexplainable Fault Localization method tailored for programming assignments via\nLLM-guided Annotation and Model Ensemble. FLAME leverages rich contextual\ninformation specific to programming assignments to guide LLMs in identifying\nfaulty code lines. Instead of directly predicting line numbers, we prompt the\nLLM to annotate faulty code lines with detailed explanations, enhancing both\nlocalization accuracy and educational value. To further improve reliability, we\nintroduce a weighted multi-model voting strategy that aggregates results from\nmultiple LLMs to determine the suspiciousness of each code line. Extensive\nexperimental results demonstrate that FLAME outperforms state-of-the-art fault\nlocalization baselines on programming assignments, successfully localizing 207\nmore faults at top-1 over the best-performing baseline. Beyond educational\ncontexts, FLAME also generalizes effectively to general-purpose software\ncodebases, outperforming all baselines on the Defects4J benchmark.", "AI": {"tldr": "FLAME is a fine-grained, explainable fault localization method for programming assignments using LLM-guided annotation and model ensemble, achieving state-of-the-art performance in both educational and general software contexts.", "motivation": "Existing fault localization techniques lack granularity and explanatory power needed for educational settings, while line-level approaches struggle with LLM compatibility due to direct numerical predictions.", "method": "FLAME employs LLMs to annotate faulty lines with contextual explanations instead of predicting line numbers directly. Combines this with a weighted multi-model voting strategy to enhance reliability through multiple LLMs' collective analysis.", "result": "Outperforms existing methods by localizing 207 more faults at top-1 in programming assignments, and achieves superior performance on the Defects4J benchmark for general software codebases.", "conclusion": "FLAME addresses critical limitations of current fault localization approaches in educational contexts, providing both technical improvement through LLM-annotation and pedagogical value via explanatory feedback, with proven generalization to standard software defects."}}
{"id": "2509.26562", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.26562", "abs": "https://arxiv.org/abs/2509.26562", "authors": ["Firas Ben Hmida", "Abderrahmen Amich", "Ata Kaboudi", "Birhanu Eshete"], "title": "DeepProv: Behavioral Characterization and Repair of Neural Networks via Inference Provenance Graph Analysis", "comment": "18 pages, 9 figures, 6 tables, To appear in the 41st Annual Computer\n  Security Applications Conference (ACSAC), 2025", "summary": "Deep neural networks (DNNs) are increasingly being deployed in high-stakes\napplications, from self-driving cars to biometric authentication. However,\ntheir unpredictable and unreliable behaviors in real-world settings require new\napproaches to characterize and ensure their reliability.\n  This paper introduces DeepProv, a novel and customizable system designed to\ncapture and characterize the runtime behavior of DNNs during inference by using\ntheir underlying graph structure. Inspired by system audit provenance graphs,\nDeepProv models the computational information flow of a DNN's inference process\nthrough Inference Provenance Graphs (IPGs). These graphs provide a detailed\nstructural representation of the behavior of DNN, allowing both empirical and\nstructural analysis. DeepProv uses these insights to systematically repair DNNs\nfor specific objectives, such as improving robustness, privacy, or fairness.\n  We instantiate DeepProv with adversarial robustness as the goal of model\nrepair and conduct extensive case studies to evaluate its effectiveness. Our\nresults demonstrate its effectiveness and scalability across diverse\nclassification tasks, attack scenarios, and model complexities. DeepProv\nautomatically identifies repair actions at the node and edge-level within IPGs,\nsignificantly enhancing the robustness of the model. In particular, applying\nDeepProv repair strategies to just a single layer of a DNN yields an average\n55% improvement in adversarial accuracy. Moreover, DeepProv complements\nexisting defenses, achieving substantial gains in adversarial robustness.\nBeyond robustness, we demonstrate the broader potential of DeepProv as an\nadaptable system to characterize DNN behavior in other critical areas, such as\nprivacy auditing and fairness analysis.", "AI": {"tldr": "DeepProv introduces Inference Provenance Graphs (IPGs) to model DNN runtime behavior, enabling targeted repairs to improve robustness and adaptability across tasks like privacy and fairness.", "motivation": "DNNs fail reliably in real-world applications (e.g., self-driving, biometrics) due to unpredictable behavior, requiring new methods for characterizing and repairing their runtime behavior.", "method": "Uses graph-based IPGs to capture computational information flow during inference, enabling node/edge-level analysis and systematic repairs (e.g., adversarial robustness improvement).", "result": "Achieves 55%% average improvement in adversarial accuracy with single-layer repairs; demonstrates scalability across tasks and model complexities; complements existing defenses effectively.", "conclusion": "DeepProv establishes a versatile framework for auditing and repairing DNNs, with broad applicability beyond robustness to privacy auditing and fairness analysis."}}
{"id": "2509.25716", "categories": ["cs.SE", "cs.AI", "cs.IR"], "pdf": "https://arxiv.org/pdf/2509.25716", "abs": "https://arxiv.org/abs/2509.25716", "authors": ["Esakkivel Esakkiraja", "Denis Akhiyarov", "Aditya Shanmugham", "Chitra Ganapathy"], "title": "DeepCodeSeek: Real-Time API Retrieval for Context-Aware Code Generation", "comment": "Retrieval-Augmented Generation, API Prediction, Context-Aware Code\n  Generation, Enterprise Code Completion, Reinforcement Learning, ServiceNow,\n  Real-Time Code Search, Query Enhancement, Fine-Tuning, Embedding, Reranker", "summary": "Current search techniques are limited to standard RAG query-document\napplications. In this paper, we propose a novel technique to expand the code\nand index for predicting the required APIs, directly enabling high-quality,\nend-to-end code generation for auto-completion and agentic AI applications. We\naddress the problem of API leaks in current code-to-code benchmark datasets by\nintroducing a new dataset built from real-world ServiceNow Script Includes that\ncapture the challenge of unclear API usage intent in the code. Our evaluation\nmetrics show that this method achieves 87.86% top-40 retrieval accuracy,\nallowing the critical context with APIs needed for successful downstream code\ngeneration. To enable real-time predictions, we develop a comprehensive\npost-training pipeline that optimizes a compact 0.6B reranker through synthetic\ndataset generation, supervised fine-tuning, and reinforcement learning. This\napproach enables our compact reranker to outperform a much larger 8B model\nwhile maintaining 2.5x reduced latency, effectively addressing the nuances of\nenterprise-specific code without the computational overhead of larger models.", "AI": {"tldr": "This paper introduces an efficient API prediction method with a compact reranker that outperforms larger models, enabling high-quality code generation with reduced latency using a novel dataset and training pipeline.", "motivation": "Current search techniques are limited to standard RAG applications, and code-to-code benchmarks suffer from API leaks and unclear intent in API usage.", "method": "Developed a novel technique to expand code/index for API prediction, introduced a real-world ServiceNow dataset to address API leaks, and created a post-training pipeline (synthetic dataset generation, supervised fine-tuning, and reinforcement learning) for a compact 0.6B reranker.", "result": "Achieved 87.86% top-40 retrieval accuracy; the compact reranker outperformed an 8B model with 2.5x reduced latency.", "conclusion": "The proposed method effectively addresses API prediction for code generation with a compact reranker that outperforms larger models while maintaining reduced latency, offering a computationally efficient solution for enterprise-specific code challenges."}}
{"id": "2509.26598", "categories": ["cs.CR", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.26598", "abs": "https://arxiv.org/abs/2509.26598", "authors": ["Anshul Nasery", "Edoardo Contente", "Alkin Kaz", "Pramod Viswanath", "Sewoong Oh"], "title": "Are Robust LLM Fingerprints Adversarially Robust?", "comment": null, "summary": "Model fingerprinting has emerged as a promising paradigm for claiming model\nownership. However, robustness evaluations of these schemes have mostly focused\non benign perturbations such as incremental fine-tuning, model merging, and\nprompting. Lack of systematic investigations into {\\em adversarial robustness}\nagainst a malicious model host leaves current systems vulnerable. To bridge\nthis gap, we first define a concrete, practical threat model against model\nfingerprinting. We then take a critical look at existing model fingerprinting\nschemes to identify their fundamental vulnerabilities. Based on these, we\ndevelop adaptive adversarial attacks tailored for each vulnerability, and\ndemonstrate that these can bypass model authentication completely for ten\nrecently proposed fingerprinting schemes while maintaining high utility of the\nmodel for the end users. Our work encourages fingerprint designers to adopt\nadversarial robustness by design. We end with recommendations for future\nfingerprinting methods.", "AI": {"tldr": "This paper reveals critical vulnerabilities in 10 recent model fingerprinting schemes by developing adversarial attacks that bypass ownership authentication while maintaining model utility, emphasizing the need for adversarial robustness in fingerprint design.", "motivation": "Existing model fingerprinting evaluations focus on benign perturbations, leaving adversarial robustness against malicious attacks unaddressed. This creates vulnerabilities in ownership claim systems.", "method": "The researchers (1) defined a practical threat model for adversarial robustness, (2) analyzed vulnerabilities in 10 fingerprinting schemes, and (3) developed tailored adversarial attacks against these vulnerabilities.", "result": "Demonstrated complete bypass of ownership authentication for all 10 schemes using adversarial attacks while maintaining high model utility for end users, validating the critical vulnerabilities in current fingerprinting methods.", "conclusion": "Current fingerprinting systems require adversarial robustness by design. The authors recommend future methods should prioritize defending against such attacks to ensure secure ownership verification."}}
{"id": "2509.25754", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.25754", "abs": "https://arxiv.org/abs/2509.25754", "authors": ["Ajmain Inqiad Alam", "Palash Roy", "Farouq Al-omari", "Chanchal Roy", "Banani Roy", "Kevin Schneider"], "title": "Are Classical Clone Detectors Good Enough For the AI Era?", "comment": null, "summary": "The increasing adoption of AI-generated code has reshaped modern software\ndevelopment, introducing syntactic and semantic variations in cloned code.\nUnlike traditional human-written clones, AI-generated clones exhibit systematic\nsyntactic patterns and semantic differences learned from large-scale training\ndata. This shift presents new challenges for classical code clone detection\n(CCD) tools, which have historically been validated primarily on human-authored\ncodebases and optimized to detect syntactic (Type 1-3) and limited semantic\nclones. Given that AI-generated code can produce both syntactic and complex\nsemantic clones, it is essential to evaluate the effectiveness of classical CCD\ntools within this new paradigm. In this paper, we systematically evaluate nine\nwidely used CCD tools using GPTCloneBench, a benchmark containing\nGPT-3-generated clones. To contextualize and validate our results, we further\ntest these detectors on established human-authored benchmarks, BigCloneBench\nand SemanticCloneBench, to measure differences in performance between\ntraditional and AI-generated clones. Our analysis demonstrates that classical\nCCD tools, particularly those enhanced by effective normalization techniques,\nretain considerable effectiveness against AI-generated clones, while some\nexhibit notable performance variation compared to traditional benchmarks. This\npaper contributes by (1) evaluating classical CCD tools against AI-generated\nclones, providing critical insights into their current strengths and\nlimitations; (2) highlighting the role of normalization techniques in improving\ndetection accuracy; and (3) delivering detailed scalability and execution-time\nanalyses to support practical CCD tool selection.", "AI": {"tldr": "This paper evaluates nine classical code clone detection (CCD) tools on AI-generated clones from GPTCloneBench and human-authored benchmarks, finding that normalization techniques enhance their performance, though results vary compared to traditional setups.", "motivation": "The adoption of AI-generated code introduces new syntactic and semantic clone patterns that challenge classical CCD tools, necessitating an update to their evaluation beyond traditional human-authored code benchmarks.", "method": "The study systematically assesses nine leading CCD tools on a GPTCloneBench dataset of GPT-3-generated clones, comparing their performance to established human-authored benchmarks like BigCloneBench and SemanticCloneBench. The evaluation emphasizes detection effectiveness and computational efficiency.", "result": "Classical CCD tools maintain considerable effectiveness against AI clones, particularly when using normalization techniques. However, their performance metrics show variability when compared to traditional clone detection benchmarks.", "conclusion": "While classical CCD tools remain largely effective for AI-generated clones, normalization enhances accuracy, and scalability analyses guide tool selection. Traditional benchmarks do not fully reflect AI clone challenges, necessitating updated evaluation methods."}}
{"id": "2509.25874", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.25874", "abs": "https://arxiv.org/abs/2509.25874", "authors": ["Zhihan Jiang", "Jinyang Liu", "Yichen Li", "Haiyu Huang", "Xiao He", "Tieying Zhang", "Jianjun Chen", "Yi Li", "Rui Shi", "Michael R. Lyu"], "title": "LogPilot: Intent-aware and Scalable Alert Diagnosis for Large-scale Online Service Systems", "comment": "Accepted by the 40th IEEE/ACM International Conference on Automated\n  Software Engineering (ASE 2025)", "summary": "Effective alert diagnosis is essential for ensuring the reliability of\nlarge-scale online service systems. However, on-call engineers are often\nburdened with manually inspecting massive volumes of logs to identify root\ncauses. While various automated tools have been proposed, they struggle in\npractice due to alert-agnostic log scoping and the inability to organize\ncomplex data effectively for reasoning. To overcome these limitations, we\nintroduce LogPilot, an intent-aware and scalable framework powered by Large\nLanguage Models (LLMs) for automated log-based alert diagnosis. LogPilot\nintroduces an intent-aware approach, interpreting the logic in alert\ndefinitions (e.g., PromQL) to precisely identify causally related logs and\nrequests. To achieve scalability, it reconstructs each request's execution into\na spatiotemporal log chain, clusters similar chains to identify recurring\nexecution patterns, and provides representative samples to the LLMs for\ndiagnosis. This clustering-based approach ensures the input is both rich in\ndiagnostic detail and compact enough to fit within the LLM's context window.\nEvaluated on real-world alerts from Volcano Engine Cloud, LogPilot improves the\nusefulness of root cause summarization by 50.34% and exact localization\naccuracy by 54.79% over state-of-the-art methods. With a diagnosis time under\none minute and a cost of only $0.074 per alert, LogPilot has been successfully\ndeployed in production, offering an automated and practical solution for\nservice alert diagnosis.", "AI": {"tldr": "LogPilot is an intent-aware, scalable LLM-based...", "motivation": "On-call engineers face challenges...", "method": "The framework...", "result": "Evaluated on real-world alerts...", "conclusion": "LogPilot's efficiency and accuracy..."}}
{"id": "2509.25894", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.25894", "abs": "https://arxiv.org/abs/2509.25894", "authors": ["Simin Chen", "Yixin He", "Suman Jana", "Baishakhi Ray"], "title": "Red Teaming Program Repair Agents: When Correct Patches can Hide Vulnerabilities", "comment": null, "summary": "LLM-based agents are increasingly deployed for software maintenance tasks\nsuch as automated program repair (APR). APR agents automatically fetch GitHub\nissues and use backend LLMs to generate patches that fix the reported bugs.\nHowever, existing work primarily focuses on the functional correctness of\nAPR-generated patches, whether they pass hidden or regression tests, while\nlargely ignoring potential security risks. Given the openness of platforms like\nGitHub, where any user can raise issues and participate in discussions, an\nimportant question arises: Can an adversarial user submit a valid issue on\nGitHub that misleads an LLM-based agent into generating a functionally correct\nbut vulnerable patch? To answer this question, we propose SWExploit, which\ngenerates adversarial issue statements designed to make APR agents produce\npatches that are functionally correct yet vulnerable. SWExploit operates in\nthree main steps: (1) program analysis to identify potential injection points\nfor vulnerable payloads; (2) adversarial issue generation to provide misleading\nreproduction and error information while preserving the original issue\nsemantics; and (3) iterative refinement of the adversarial issue statements\nbased on the outputs of the APR agents. Empirical evaluation on three agent\npipelines and five backend LLMs shows that SWExploit can produce patches that\nare both functionally correct and vulnerable (the attack success rate on the\ncorrect patch could reach 0.91, whereas the baseline ASRs are all below 0.20).\nBased on our evaluation, we are the first to challenge the traditional\nassumption that a patch passing all tests is inherently reliable and secure,\nhighlighting critical limitations in the current evaluation paradigm for APR\nagents.", "AI": {"tldr": "This paper shows LLM-based APR agents can be tricked into generating secure but vulnerable code via adversarial GitHub issues, exposing critical flaws in their evaluation paradigm.", "motivation": "Existing APR agents focus on functional correctness but ignore security risks. The study explores whether adversarial GitHub issues can trick agents into generating functionally correct yet vulnerable patches.", "method": "SWExploit uses three steps: program analysis to identify injection points, adversarial issue generation (preserving original semantics while misleading), and iterative refinement based on APR agent outputs.", "result": "SWExploit achieves an attack success rate of 0.91 on correct patches (vs. baselines below 0.20 across three agent pipelines and five LLMs), showing vulnerability introduction without affecting functional correctness.", "conclusion": "The paper challenges the assumption that functionally correct patches from APR agents are inherently secure, demonstrating vulnerabilities via adversarial issues and highlighting flaws in existing evaluation paradigms."}}
{"id": "2509.25987", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.25987", "abs": "https://arxiv.org/abs/2509.25987", "authors": ["Yilun Liu", "Ziang Chen", "Song Xu", "Minggui He", "Shimin Tao", "Weibin Meng", "Yuming Xie", "Tao Han", "Chunguang Zhao", "Jingzhou Du", "Daimeng Wei", "Shenglin Zhang", "Yongqian Sun"], "title": "R-Log: Incentivizing Log Analysis Capability in LLMs via Reasoning-based Reinforcement Learning", "comment": null, "summary": "The growing complexity of log data in modern software systems has prompted\nthe use of Large Language Models (LLMs) for automated log analysis. Current\napproaches typically rely on direct supervised fine-tuning (SFT) on log-label\npairs. However, this exacerbates the domain discrepancy between general-purpose\nLLMs and specialized log data, causing overfitting. Furthermore, SFT's\nimbalanced loss computation often allows lengthy contexts to overwhelm\ncritical, concise details in model answers, leading to hallucinations. To\naddress these limitations, we propose R-Log, a novel reasoning-based paradigm\nthat mirrors the structured, step-by-step analytical process of human\nengineers. This approach enhances generalizability by learning the underlying\nrules behind conclusions. We further employ Reinforcement Learning (RL) to\noptimize the model within a simulated O&M environment, thereby reducing\nhallucinations by directly rewarding correct outcomes. R-Log is first\ncold-started on a curated dataset of 2k+ reasoning trajectories, guided by 13\nstrategies from manual O&M practices, to establish an initial reasoning\ncapability. This ability is then refined via RL using a joint reward function.\nEmpirical evaluations on real-world logs show that R-Log outperforms existing\nmethods across five log analysis tasks, particularly in unseen scenarios (by\n228.05%). We also designed R-Log-fast with 5x speedup while keeping 93% of the\nefficacy.", "AI": {"tldr": "R-Log uses human-like reasoning and RL to improve LLM log analysis, outperforming SFT methods with better generalization and reduced hallucinations.", "motivation": "Current SFT methods for log analysis fail due to domain gaps causing overfitting, imbalanced loss computation that prioritizes lengthy contexts over critical details, and resulting hallucinations in model outputs.", "method": "The paper proposes R-Log, a reasoning-based paradigm that pre-trains on 2k+ expert reasoning trajectories guided by 13 O&M strategies, followed by RL refinement in a simulated environment with joint reward functions.", "result": "R-Log achieves 228.05% improvement in unseen scenarios over existing methods and introduces R-Log-fast with 5x acceleration while retaining 93% of effectiveness, validated across five real-world log analysis tasks.", "conclusion": "R-Log effectively addresses domain discrepancy and hallucination issues in log analysis using LLMs through reasoning-based learning and RL optimization, achieving significant performance improvements."}}
{"id": "2509.26014", "categories": ["cs.SE", "cs.IR"], "pdf": "https://arxiv.org/pdf/2509.26014", "abs": "https://arxiv.org/abs/2509.26014", "authors": ["Joel Garcia-Escribano", "Arkaitz Carbajo", "Mikel Ega\u00f1a Aranguren", "Unai Lopez-Novoa"], "title": "Using GPT to build a Project Management assistant for Jira environments", "comment": null, "summary": "In the domain of Project Management, the sheer volume of data is a challenge\nthat project managers continually have to deal with. Effectively steering\nprojects from inception to completion requires handling of diverse information\nstreams, including timelines, budgetary considerations, and task dependencies.\nTo navigate this data-driven landscape with precision and agility, project\nmanagers must rely on efficient and sophisticated tools. These tools have\nbecome essential, as they enable project managers to streamline communication,\noptimize resource allocation, and make informed decisions in real-time.\nHowever, many of these tools have steep learning curves and require using\ncomplex programming languages to retrieve the exact data that project managers\nneed. In this work we present JiraGPT Next, a software that uses the GPT Large\nLanguage Model to ease the process by which project managers deal with large\namounts of data. It is conceived as an add-on for Jira, one of the most popular\nProject Management tools, and provides a natural language interface to retrieve\ninformation. This work presents the design decisions behind JiraGPT Next and an\nevaluation of the accuracy of GPT in this context, including the effects of\nproviding different prompts to complete a particular task.", "AI": {"tldr": "JiraGPT Next, a natural language interface for Jira, is presented to help project managers access data efficiently, avoiding complex programming.", "motivation": "Managing large data volumes in project management tools is challenging; many tools require complex programming which could be complicated for project managers.", "method": "Design of JiraGPT Next as a Jira add-on utilizing the GPT Large Language Model for natural language data retrieval and evaluation of GPT's accuracy with various prompts.", "result": "The software was designed and tested, demonstrating potential for efficient data handling in project management through natural language interaction.", "conclusion": "JiraGPT Next offers a solution to simplify data management in Jira, enhancing accessibility and efficiency for project managers through GPT-based natural language interface."}}
{"id": "2509.26031", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.26031", "abs": "https://arxiv.org/abs/2509.26031", "authors": ["Hina Anwar", "Dietmar Pfahl", "Satish N. Srirama"], "title": "Evaluating the impact of code smell refactoring on the energy consumption of Android applications", "comment": null, "summary": "Energy consumption of mobile apps is a domain that is receiving a lot of\nattention from researchers. Recent studies indicate that the energy consumption\nof mobile devices could be improved by improving the quality of mobile apps.\nFrequent refactoring is one way of achieving this goal. In this paper, we\nexplore the performance and energy impact of several common code refactorings\nin Android apps. Experimental results indicate that some code smell\nrefactorings positively impact the energy consumption of Android apps.\nRefactoring of the code smells \"Duplicated code\" and \"Type checking\" reduce\nenergy consumption by up to 10.8%. Significant reduction in energy consumption,\nhowever, does not seem to be directly related to the increase or decrease of\nexecution time. In addition, the energy impact over permutations of code smell\nrefactorings in the selected Android apps was small. When analyzing the order\nin which refactorings were made across code smell types, it turned out that\nsome permutations resulted in a reduction and some in an increase of energy\nconsumption for the analyzed apps. More research needs to be done to\ninvestigate how factors like size and age of software apps, experience, and\nnumber of contributors to app development correlate with (a) the number and\ntype of code smells found and (b) the impact of energy consumption and\nperformance after refactoring.", "AI": {"tldr": "Refactoring code smells in Android apps can reduce energy use by up to 10.8%, but the relationship between energy savings, execution time, and refactoring order is complex and merits further study.", "motivation": "Mobile app energy efficiency is critical for device performance. Code refactorings offer a potential method to improve energy consumption by addressing code smells like duplication and type checking.", "method": "The study experimentally analyzed the energy impact of various code refactorings (e.g., 'Duplicated code', 'Type checking') on Android apps, testing permutations of refactorings and correlating results with execution time and code smells.", "result": "Refactorings reduced energy consumption by up to 10.8%, though energy savings were not strictly tied to changes in execution time. Refactoring order also influenced energy impact, with some permutations increasing consumption.", "conclusion": "The paper concludes that code refactoring can significantly reduce energy consumption in Android apps by up to 10.8%, but further research is needed to understand correlations between app development factors and refactoring outcomes."}}
{"id": "2509.26110", "categories": ["cs.SE", "astro-ph.IM"], "pdf": "https://arxiv.org/pdf/2509.26110", "abs": "https://arxiv.org/abs/2509.26110", "authors": ["Dmitriy Kostunin", "Vladimir Sotnikov", "Sergo Golovachev", "Abhay Mehta", "Tim Lukas Holch", "Elisa Jones"], "title": "Agent-based code generation for the Gammapy framework", "comment": "ICRC2025 proceedings PoS(ICRC2025)753", "summary": "Software code generation using Large Language Models (LLMs) is one of the\nmost successful applications of modern artificial intelligence. Foundational\nmodels are very effective for popular frameworks that benefit from\ndocumentation, examples, and strong community support. In contrast, specialized\nscientific libraries often lack these resources and may expose unstable APIs\nunder active development, making it difficult for models trained on limited or\noutdated data. We address these issues for the Gammapy library by developing an\nagent capable of writing, executing, and validating code in a controlled\nenvironment. We present a minimal web demo and an accompanying benchmarking\nsuite. This contribution summarizes the design, reports our current status, and\noutlines next steps.", "AI": {"tldr": "This paper addresses the challenges of applying Large Language Models (LLMs), such as code generation, to specialized scientific libraries due to limited documentation and unstable APIs. The researchers developed an agent to autonomously write, execute, and validate code for the Gammapy library, providing a web demo and benchmarking suite to demonstrate their approach.", "motivation": "Modern LLMs excel at code generation for well-documented frameworks but struggle with scientific libraries that lack documentation, community resources, and have unstable APIs. This hampers their utility in scientific domains requiring specialized tools.", "method": "The authors developed an agent trained to write, execute, and validate code within a controlled environment tailored to the Gammapy library. This system enables iterative testing and validation of generated code to address unstable APIs and limited documentation.", "result": "A minimal web demo and benchmarking suite were created to showcase the agent's capabilities. The approach demonstrates effectiveness in handling scientific library challenges, though ongoing development is noted.", "conclusion": "The work highlights a successful adaptation of LLM-powered agents for scientific domains, addressing gaps in documentation and API stability. Future work includes expanding the benchmarking suite and improving agent robustness."}}
{"id": "2509.26111", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.26111", "abs": "https://arxiv.org/abs/2509.26111", "authors": ["Shuai Wang", "Liang Ding", "Li Shen", "Yong Luo", "Han Hu", "Lefei Zhang", "Fu Lin"], "title": "A Multi-Language Object-Oriented Programming Benchmark for Large Language Models", "comment": "20 pages, 12 figures", "summary": "Establishing fair and robust benchmarks is essential for evaluating\nintelligent code generation by large language models (LLMs). Our survey of 35\nexisting benchmarks uncovers three major imbalances: 85.7% focus on a single\nprogramming language; 94.3% target only function-level or statement-level\ntasks; and over 80% include fewer than ten test cases on average. To address\nthese gaps, we propose MultiOOP, a multi-language object-oriented programming\nbenchmark covering six popular languages (Python, PHP, C++, C#, Java,\nJavaScript) with 267 tasks per language. We design a translator that extends an\nexisting single-language OOP benchmark and the pass@o metric to a multilingual\nsetting. Moreover, we propose an automated framework for augmenting test cases\nto ensure the reliability of the evaluation results. We evaluate 14 mainstream\nLLMs under zero-shot prompting and report three key findings: 1) Substantial\nperformance degradation: pass@1 scores on MultiOOP drop by up to 65.6\npercentage points compared to function-level tasks (e.g., HumanEval). 2)\nCross-language variability: GPT-4o mini achieves pass@1 of 48.06% in Python but\nonly 0.12%-15.26% in other languages, indicating limited multilingual\ngeneralization. 3) Conceptual gaps: pass@o scores are consistently 1.1-19.2\npoints lower than pass@k, demonstrating that LLMs often generate executable\ncode without fully capturing core OOP concepts. Our benchmark, metric\nextensions, and evaluation scripts will be publicly released to foster a more\nbalanced and comprehensive assessment of LLMs in object-oriented code\ngeneration. Our code and data will be released at\nhttps://github.com/alphadl/OOP-eval and\nhttps://huggingface.co/datasets/codeai-dteam/MultiOOP respectively.", "AI": {"tldr": "The paper introduces MultiOOP, a multi-language OOP benchmark for evaluating code generation models, revealing substantial performance drops across tasks and languages compared to existing benchmarks.", "motivation": "Existing benchmarks for evaluating LLM code generation are imbalanced, focusing narrowly on single languages (85.7%), low-level tasks (94.3%), and small test sets (80% with fewer than 10 cases), limiting robust evaluation.", "method": "Proposed MultiOOP covering 6 languages (Python, PHP, C++, C#, Java, JS) with 267 tasks per language, designed a multilingual translator and pass@o metric extension, and developed an automated framework for test case augmentation.", "result": "1) Performance degradation of up to 65.6 pp in pass@1 scores compared to function-level benchmarks. 2) GPT-4o mini's cross-language variability (48.06% in Python vs. 0.12%-15.26% in others). 3) Conceptual gaps with pass@o scores 1.1-19.2 points lower than pass@k, indicating incomplete OOP concept understanding.", "conclusion": "MultiOOP provides a comprehensive benchmark for OOP evaluation across multiple languages. The authors plan to release datasets, metrics, and evaluation tools at specified repositories to foster fair, multilingual LLM code generation assessment."}}
{"id": "2509.26173", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.26173", "abs": "https://arxiv.org/abs/2509.26173", "authors": ["Lisi Qarkaxhija", "Maximilian Carparo", "Stefan Menzel", "Bernhard Sendhoff", "Ingo Scholtes"], "title": "Understanding Collective Social Behavior in OSS Communities: A Co-editing Network Analysis of Activity Cascades", "comment": null, "summary": "Understanding the collective social behavior of software developers is\ncrucial to model and predict the long-term dynamics and sustainability of Open\nSource Software (OSS) communities. To this end, we analyze temporal activity\npatterns of developers, revealing an inherently ``bursty'' nature of commit\ncontributions. To investigate the social mechanisms behind this phenomenon, we\nadopt a network-based modelling framework that captures developer interactions\nthrough co-editing networks. Our framework models social interactions, where a\ndeveloper editing the code of other developers triggers accelerated activity\namong collaborators. Using a large data set on 50 major OSS communities, we\nfurther develop a method that identifies activity cascades, i.e. the\npropagation of developer activity in the underlying co-editing network. Our\nresults suggest that activity cascades are a statistically significant\nphenomenon in more than half of the studied projects. We further show that our\ninsights can be used to develop a simple yet practical churn prediction method\nthat forecasts which developers are likely to leave a project. Our work sheds\nlight on the emergent collective social dynamics in OSS communities and\nhighlights the importance of activity cascades to understand developer churn\nand retention in collaborative software projects.", "AI": {"tldr": "This paper investigates the bursty activity patterns in open-source software (OSS), showing that developer interactions in co-editing networks generate activity cascades, which help predict developer churn and explain community dynamics.", "motivation": "Understanding how developers interact is critical for modeling the sustainability of OSS communities. The bursty nature of commit activity raises the need to uncover its social mechanisms.", "method": "A network-based framework uses co-editing interactions to model cascading activity. Over 50 OSS communities are analyzed to identify cascades and develop a churn prediction method.", "result": "Activity cascades are statistically significant in over half the projects. The proposed method predicts developer churn with practical effectiveness.", "conclusion": "Activity cascades are key to understanding developer retention and churn in OSS. Modeling social interactions through co-editing networks provides actionable insights for community sustainability."}}
{"id": "2509.26204", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.26204", "abs": "https://arxiv.org/abs/2509.26204", "authors": ["Rangeet Pan", "Tyler Stennett", "Raju Pavuluri", "Nate Levin", "Alessandro Orso", "Saurabh Sinha"], "title": "Hamster: A Large-Scale Study and Characterization of Developer-Written Tests", "comment": null, "summary": "Automated test generation (ATG), which aims to reduce the cost of manual test\nsuite development, has been investigated for decades and has produced countless\ntechniques based on a variety of approaches: symbolic analysis, search-based,\nrandom and adaptive-random, learning-based, and, most recently,\nlarge-language-model-based approaches. However, despite this large body of\nresearch, there is still a gap in our understanding of the characteristics of\ndeveloper-written tests and, consequently, in our assessment of how well ATG\ntechniques and tools can generate realistic and representative tests. To bridge\nthis gap, we conducted an extensive empirical study of developer-written tests\nfor Java applications, covering 1.7 million test cases from open-source\nrepositories. Our study is the first of its kind in studying aspects of\ndeveloper-written tests that are mostly neglected in the existing literature,\nsuch as test scope, test fixtures and assertions, types of inputs, and use of\nmocking. Based on the characterization, we then compare existing tests with\nthose generated by two state-of-the-art ATG tools. Our results highlight that a\nvast majority of developer-written tests exhibit characteristics that are\nbeyond the capabilities of current ATG tools. Finally, based on the insights\ngained from the study, we identify promising research directions that can help\nbridge the gap between current tool capabilities and more effective tool\nsupport for developer testing practices. We hope that this work can set the\nstage for new advances in the field and bring ATG tools closer to generating\nthe types of tests developers write.", "AI": {"tldr": "This paper bridges the gap between developer-written tests and Automated Test Generation (ATG). Using 1.7 million Java tests, it compares ATG tools to real-world developer practices, revealing that current ATG tools struggle to replicate key test characteristics. It proposes research directions to improve tool capabilities.", "motivation": "Prior ATG research lacks understanding of developer test characteristics, hampering assessment of tool effectiveness. This study addresses this gap to improve alignment between ATG tools and developer needs.", "method": "An empirical analysis of 1.7M open-source Java test cases, focusing on test scope, fixtures, inputs, and mocking. Existing tests are compared to those generated by two state-of-the-art ATG tools.", "result": "Most developer-written tests exhibit characteristics (e.g., complex fixtures, input handling, mocking) that current ATG tools cannot replicate effectively, highlighting a significant gap in tool capabilities.", "conclusion": "The study identifies actionable research directions to enable ATG tools to better match developer testing practices, advocating for advances that align tool outputs with real-world test creation patterns."}}
{"id": "2509.26336", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.26336", "abs": "https://arxiv.org/abs/2509.26336", "authors": ["Zhouruixing Zhu", "Zhihan Jiang", "Tianyi Yang", "Pinjia He"], "title": "UniSage: A Unified and Post-Analysis-Aware Sampling for Microservices", "comment": null, "summary": "Traces and logs are essential for observability and fault diagnosis in modern\ndistributed systems. However, their ever-growing volume introduces substantial\nstorage overhead and complicates troubleshooting. Existing approaches typically\nadopt a sample-before-analysis paradigm: even when guided by data heuristics,\nthey inevitably discard failure-related information and hinder transparency in\ndiagnosing system behavior. To address this, we introduce UniSage, the first\nunified framework to sample both traces and logs using a post-analysis-aware\nparadigm. Instead of discarding data upfront, UniSagefirst performs lightweight\nand multi-modal anomaly detection and root cause analysis (RCA) on the complete\ndata stream. This process yields fine-grained, service-level diagnostic\ninsights that guide a dual-pillar sampling strategy for handling both normal\nand anomalous scenarios: an analysis-guided sampler prioritizes data implicated\nby RCA, while an edge-case-based sampler ensures rare but critical behaviors\nare captured. Together, these pillars ensure comprehensive coverage of critical\nsignals without excessive redundancy. Extensive experiments demonstrate that\nUniSage significantly outperforms state-of-the-art baselines. At a 2.5%\nsampling rate, it captures 56.5% of critical traces and 96.25% of relevant\nlogs, while improving the accuracy (AC@1) of downstream root cause analysis by\n42.45%. Furthermore, its efficient pipeline processes 10 minutes of telemetry\ndata in under 5 seconds, demonstrating its practicality for production\nenvironments.", "AI": {"tldr": "UniSage enables accurate failure diagnosis while reducing storage requirements using post-analysis-aware trace/log sampling in distributed systems.", "motivation": "Modern distributed systems generate massive volume of traces/logs for observability, but traditional sample-before-analysis approaches inevitably discard failure-related data, reducing diagnostic transparency and system behavior visibility. This information loss hinders effective fault diagnosis.", "method": "Introduces UniSage, a unified framework that first performs lightweight multi-modal anomaly detection and root cause analysis (RCA) on the full telemetry data stream. It then applies a dual-pillar sampling strategy: analysis-guided (prioritizes data implicated by RCA) and edge-case-based (captures rare critical behaviors). This post-analysis approach preserves failure-related information discarded by pre-sampling methods.", "result": "At 2.5% sampling rate, captures 56.5% of critical traces and 96.25% of relevant logs, achieving 42.45% improvement in root cause analysis accuracy over state-of-the-art. Processes 10m of telemetry data in <5s, demonstrating practical deployment feasibility.", "conclusion": "UniSage addresses the limitations of traditional pre-sampling methods by using post-analysis-aware sampling, achieving comprehensive coverage of critical failure signals at ultra-low sampling rates while maintaining high diagnostic accuracy and efficiency for production systems."}}
{"id": "2509.26422", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.26422", "abs": "https://arxiv.org/abs/2509.26422", "authors": ["Michelle Barker", "Jeremy Cohen", "Pedro Hern\u00e1ndez Serrano", "Daniel S. Katz", "Kim Martin", "Dan Rudmann", "Hugh Shanahan"], "title": "Institutional Policy Pathways for Supporting Research Software: Global Trends and Local Practices", "comment": null, "summary": "As research software becomes increasingly central to modern science,\nresearch-performing organisations (RPOs) need to ensure that their investment\nin people, skills and infrastructure around research software produces\nsustainable and maintainable software that improves the research they perform,\nwhich in turn improves the overall institution and its reputation and funding,\nfor example, by competing with peers who lack this approach. However, research\ninstitution management and recognition of research software and its personnel\nhas mostly often developed in an ad hoc manner. RPO training infrastructures,\nrecognition and reward structures, have not developed at a sufficient rate to\nsupport and encourage both the widespread use of research software best\npractices and the long-term support for technical roles that is required. To\nbegin to address this fundamental problem for modern research environments,\nRPOs must implement and adopt robust policies to support research software\ndevelopment, use, and sustainability. Despite growing momentum from funders and\npublishers around FAIR and open science principles, research\ninstitutional-level policies specifically addressing research software remain\nlimited or lacking in breadth.\n  This article outlines the work of the Policies in Research Organisations for\nResearch Software (PRO4RS) Working Group (WG), a joint initiative of the\nResearch Software Alliance (ReSA) and the Research Data Alliance (RDA), which\nexamined and advanced research software policy development across institutions\nworldwide. After consideration of the rationale for institutional policies on\nresearch software, the PRO4RS WG outputs and analysis are utilised to highlight\ncritical policy gaps, particularly related to consideration of research\nsoftware personnel in policy work focused on reform of research assessment.", "AI": {"tldr": "The paper addresses the lack of institutional policies for research software sustainability, reviewing challenges in current ad hoc management approaches and proposing systemic reforms via the PRO4RS Working Group's global policy analysis.", "motivation": "Research software is critical to modern science but faces institutional neglect in training, recognition, and sustainability. Existing policies fail to address technical role support, research assessment reforms, and alignment with FAIR/open science principles.", "method": "The PRO4RS Working Group (ReSA-RDA collaboration, 2020-2023+) conducted global research software policy analysis, identifying gaps through stakeholder engagement and institutional case studies focused on research assessment reforms.", "result": "Identified critical policy gaps: (1\u7f3a\u5c11\u9488\u5bf9\u7814\u7a76\u8f6f\u4ef6\u4eba\u5458\u7684\u804c\u4e1a\u53d1\u5c55\u8def\u5f84; (2\u7f3a\u4e4f\u5c06\u8f6f\u4ef6\u8d21\u732e\u7eb3\u5165\u5b66\u672f\u8bc4\u4f30\u4f53\u7cfb; (3\u672a\u5c06FAIR\u539f\u5219\u5145\u5206\u6574\u5408\u5230\u8f6f\u4ef6\u7ba1\u7406\u4e2d; (4\u673a\u6784\u5c42\u9762\u7f3a\u4e4f\u6280\u672f\u57fa\u7840\u8bbe\u65bd\u957f\u671f\u652f\u6301\u673a\u5236.", "conclusion": "Institutions must adopt systemic policies to sustain research software ecosystems. PRO4RS demonstrates that structured policy development is essential for competitive research institutions to maintain technical excellence, attract funding, and uphold scientific rigor in the digital age."}}
{"id": "2509.26458", "categories": ["cs.SE", "68Q60, 03B70", "D.2.5"], "pdf": "https://arxiv.org/pdf/2509.26458", "abs": "https://arxiv.org/abs/2509.26458", "authors": ["Robin Lee", "Youngho Nam"], "title": "EQ-Robin: Generating Multiple Minimal Unique-Cause MC/DC Test Suites", "comment": "5 pages", "summary": "Modified Condition/Decision Coverage (MC/DC), particularly its strict\nUnique-Cause form, is a cornerstone of safety-critical software verification. A\nrecent algorithm, \"Robin's Rule,\" introduced a deterministic method to\nconstruct the theoretical minimum of N+1 test cases for Singular Boolean\nExpressions (SBEs). However, this approach yields only a single test suite,\nintroducing a critical risk: if a test case forming a required 'independence\npair' is an illegal input forbidden by system constraints, the suite fails to\nachieve 100% coverage. This paper proposes EQ-Robin, a lightweight pipeline\nthat systematically generates a family of minimal Unique-Cause MC/DC suites to\nmitigate this risk. We introduce a method for systematically generating\nsemantically equivalent SBEs by applying algebraic rearrangements to an\nAbstract Syntax Tree (AST) representation of the expression. By applying\nRobin's Rule to each structural variant, a diverse set of test suites can be\nproduced. This provides a resilient path to discovering a valid test suite that\npreserves the N+1 minimality guarantee while navigating real-world constraints.\nWe outline an evaluation plan on TCAS-II-derived SBEs to demonstrate how\nEQ-Robin offers a practical solution for ensuring robust MC/DC coverage.", "AI": {"tldr": "EQ-Robin enhances test suite reliability for MC/DC by generating multiple minimal SBE variants, overcoming risks in deterministic single-solution approaches.", "motivation": "Existing Robin's Rule produces only one test suite, risking 100% MC/DC coverage failure if any test case is invalid based on system constraints. This hinders verification in safety-critical domains.", "method": "The approach generates semantically equivalent Singular Boolean Expressions (SBEs) via algebraic AST-based rearrangements, then applies Robin's Rule to each variant to create multiple test suite options while preserving N+1 minimality.", "result": "EQ-Robin's evaluation plan on TCAS-II-derived SBEs demonstrates its ability to produce minimal valid test suites through structural expression diversity, ensuring resilience to constraint violations.", "conclusion": "EQ-Robin provides a systematic method for generating diverse minimal test suites, ensuring robust Unique-Cause MC/DC coverage for safety-critical software despite system constraints."}}
{"id": "2509.26463", "categories": ["cs.SE", "D.2.5"], "pdf": "https://arxiv.org/pdf/2509.26463", "abs": "https://arxiv.org/abs/2509.26463", "authors": ["Junsong Pu", "Yichen Li", "Zhuangbin Chen", "Jinyang Liu", "Zhihan Jiang", "Jianjun Chen", "Rui Shi", "Zibin Zheng", "Tieying Zhang"], "title": "ErrorPrism: Reconstructing Error Propagation Paths in Cloud Service Systems", "comment": "12 pages, 6 figures, 1 table, this paper has been accepted by the\n  40th IEEE/ACM International Conference on Automated Software Engineering, ASE\n  2025", "summary": "Reliability management in cloud service systems is challenging due to the\ncascading effect of failures. Error wrapping, a practice prevalent in modern\nmicroservice development, enriches errors with context at each layer of the\nfunction call stack, constructing an error chain that describes a failure from\nits technical origin to its business impact. However, this also presents a\nsignificant traceability problem when recovering the complete error propagation\npath from the final log message back to its source. Existing approaches are\nineffective at addressing this problem. To fill this gap, we present ErrorPrism\nin this work for automated reconstruction of error propagation paths in\nproduction microservice systems. ErrorPrism first performs static analysis on\nservice code repositories to build a function call graph and map log strings to\nrelevant candidate functions. This significantly reduces the path search space\nfor subsequent analysis. Then, ErrorPrism employs an LLM agent to perform an\niterative backward search to accurately reconstruct the complete, multi-hop\nerror path. Evaluated on 67 production microservices at ByteDance, ErrorPrism\nachieves 97.0% accuracy in reconstructing paths for 102 real-world errors,\noutperforming existing static analysis and LLM-based approaches. ErrorPrism\nprovides an effective and practical tool for root cause analysis in industrial\nmicroservice systems.", "AI": {"tldr": "ErrorPrism is introduced to address the traceability problem of error propagation in microservice systems. It combines static code analysis and an LLM agent for accurate path reconstruction with high accuracy in real-world errors.", "motivation": "Failure cascading in cloud systems hinders reliability management, and existing methods struggle with reconstructing error propagation paths from logs.", "method": "ErrorPrism first uses static analysis to build a function call graph and map logs to functions; then, an LLM agent performs backward search based on the initial mapping and error signals for multi-hop error path reconstruction.", "result": "ByteDance's evaluation on 67 microservices for 102 real errors achieved 97.0% accuracy, outperforming static and LLM-based methods.", "conclusion": "ErrorPrism effectively automates root cause analysis for industrial microservice systems by reducing search space and accurate path reconstruction."}}
{"id": "2509.26546", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.26546", "abs": "https://arxiv.org/abs/2509.26546", "authors": ["Meghana Sistla", "Gogul Balakrishnan", "Pat Rondon", "Jos\u00e9 Cambronero", "Michele Tufano", "Satish Chandra"], "title": "Towards Verified Code Reasoning by LLMs", "comment": "43 pages", "summary": "While LLM-based agents are able to tackle a wide variety of code reasoning\nquestions, the answers are not always correct. This prevents the agent from\nbeing useful in situations where high precision is desired: (1) helping a\nsoftware engineer understand a new code base, (2) helping a software engineer\nduring code review sessions, and (3) ensuring that the code generated by an\nautomated code generation system meets certain requirements (e.g. fixes a bug,\nimproves readability, implements a feature).\n  As a result of this lack of trustworthiness, the agent's answers need to be\nmanually verified before they can be trusted. Manually confirming responses\nfrom a code reasoning agent requires human effort and can result in slower\ndeveloper productivity, which weakens the assistance benefits of the agent. In\nthis paper, we describe a method to automatically validate the answers provided\nby a code reasoning agent by verifying its reasoning steps. At a very high\nlevel, the method consists of extracting a formal representation of the agent's\nresponse and, subsequently, using formal verification and program analysis\ntools to verify the agent's reasoning steps.\n  We applied this approach to a benchmark set of 20 uninitialized variable\nerrors detected by sanitizers and 20 program equivalence queries. For the\nuninitialized variable errors, the formal verification step was able to\nvalidate the agent's reasoning on 13/20 examples, and for the program\nequivalence queries, the formal verification step successfully caught 6/8\nincorrect judgments made by the agent.", "AI": {"tldr": "Error", "motivation": "Error", "method": "Error", "result": "Error", "conclusion": "Error"}}
{"id": "2509.26616", "categories": ["cs.SE", "cs.FL", "cs.PL", "68Q42, 68Q45 (Primary), 68T50 (Secondary)", "D.2.5; F.4.2"], "pdf": "https://arxiv.org/pdf/2509.26616", "abs": "https://arxiv.org/abs/2509.26616", "authors": ["Mohammad Rifat Arefin", "Shanto Rahman", "Christoph Csallner"], "title": "Black-box Context-free Grammar Inference for Readable & Natural Grammars", "comment": "20 pages", "summary": "Black-box context-free grammar inference is crucial for program analysis,\nreverse engineering, and security, yet existing tools such as Arvada, TreeVada,\nand Kedavra struggle with scalability, readability, and accuracy on large,\ncomplex languages. We present NatGI, a novel LLM-guided grammar inference\nframework that extends TreeVada's parse tree recovery with three key\ninnovations: bracket-guided bubble exploration, LLM-driven bubble generation\nand non-terminal labeling, and hierarchical delta debugging (HDD) for\nsystematic tree simplification. Bracket-guided exploration leverages syntactic\ncues such as parentheses to propose well-structured grammar fragments, while\nLLM guidance produces meaningful non-terminal names and selects more promising\nmerges. Finally, HDD incrementally reduces unnecessary rules, which makes the\ngrammars both compact and interpretable. In our experiments, we evaluate NatGI\non a comprehensive benchmark suite ranging from small languages to larger ones\nsuch as lua, c, and mysql. Our results show that NatGI consistently outperforms\nstrong baselines in terms of F1 score. On average, NatGI achieves an F1 score\nof 0.57, which is 25pp (percentage points) higher than the best-performing\nbaseline, TreeVada. In the case of interpretability, our generated grammars\nperform significantly better than those produced by existing approaches.\nLeveraging LLM-based node renaming and bubble exploration, NatGI produces rules\nwith meaningful non-terminal names and compact structures that align more\nclosely with human intuition. As a result, developers and researchers can\nachieve higher accuracy while still being able to easily inspect, verify, and\nreason about the structure and semantics of the induced grammars.", "AI": {"tldr": "NatGI: An LLM-guided context-free grammar inference framework for improving scalability, readability, and accuracy.", "motivation": "existing tools struggle with scalability, readability, and accuracy on large, complex languages", "method": "extend TreeVada with bracket-guided bubble exploration, LLM-driven bubble generation and non-terminal labeling, and HDD for simplification", "result": "NatGI consistently outperforms baselines. F1 score average of 0.57, 25pp higher than TreeVada, and better interpretability", "conclusion": "NatGI improves accuracy and interpretability, benefiting developers and researchers in program analysis and security."}}
