{"id": "2510.03461", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03461", "abs": "https://arxiv.org/abs/2510.03461", "authors": ["Sanjay Malakar", "Michael D. Ernst", "Martin Kellogg", "Manu Sridharan"], "title": "Repairing Leaks in Resource Wrappers", "comment": null, "summary": "A resource leak occurs when a program fails to release a finite resource like\na socket, file descriptor or database connection. While sound static analysis\ntools can detect all leaks, automatically repairing them remains challenging.\nPrior work took the output of a detection tool and attempted to repair only\nleaks from a hard-coded list of library resource types. That approach limits\nthe scope of repairable leaks: real-world code uses resource wrappers that\nstore a resource in a field and must themselves be closed. This paper makes\nfour key contributions to improve resource leak repair in the presence of\nwrappers. (1) It integrates inference of resource management specifications\ninto the repair pipeline, enabling extant fixing approaches to reason about\nwrappers. (2) It transforms programs into variants that are easier to analyze,\nmaking inference, detection, and fixing tools more effective; for instance, it\nmakes detection tools report problems closer to the root cause, often in a\nclient of a resource wrapper rather than within the wrapper class itself. (3) A\nnovel field containment analysis reasons about resource lifetimes, enabling\nrepair of more leaks involving resources stored in fields. (4) It introduces a\nnew repair pattern and more precise reasoning to better handle resources stored\nin non-final fields. Prior work fixed 41% of resource leak warnings in the NJR\nbenchmark suite; our implementation Arodnap fixes 68%."}
{"id": "2510.03463", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.03463", "abs": "https://arxiv.org/abs/2510.03463", "authors": ["Vali Tawosi", "Keshav Ramani", "Salwa Alamir", "Xiaomo Liu"], "title": "ALMAS: an Autonomous LLM-based Multi-Agent Software Engineering Framework", "comment": null, "summary": "Multi-agent Large Language Model (LLM) systems have been leading the way in\napplied LLM research across a number of fields. One notable area is software\ndevelopment, where researchers have advanced the automation of code\nimplementation, code testing, code maintenance, inter alia, using LLM agents.\nHowever, software development is a multifaceted environment that extends beyond\njust code. As such, a successful LLM system must factor in multiple stages of\nthe software development life-cycle (SDLC). In this paper, we propose a vision\nfor ALMAS, an Autonomous LLM-based Multi-Agent Software Engineering framework,\nwhich follows the above SDLC philosophy such that it may work within an agile\nsoftware development team to perform several tasks end-to-end. ALMAS aligns its\nagents with agile roles, and can be used in a modular fashion to seamlessly\nintegrate with human developers and their development environment. We showcase\nthe progress towards ALMAS through our published works and a use case\ndemonstrating the framework, where ALMAS is able to seamlessly generate an\napplication and add a new feature."}
{"id": "2510.03474", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.03474", "abs": "https://arxiv.org/abs/2510.03474", "authors": ["Nadeeshan De Silva", "Martin Kellogg", "Oscar Chaparro"], "title": "Relative Code Comprehensibility Prediction", "comment": null, "summary": "Automatically predicting how difficult it is for humans to understand a code\nsnippet can assist developers in tasks like deciding when and where to\nrefactor. Despite many proposed code comprehensibility metrics, studies have\nshown they often correlate poorly with actual measurements of human\ncomprehensibility. This has motivated the use of machine learning models to\npredict human comprehensibility directly from code, but these models have also\nshown limited accuracy.\n  We argue that model inaccuracy stems from inherent noise in human\ncomprehensibility data, which confuses models trained to predict it directly.\nTo address this, we propose training models to predict the relative\ncomprehensibility of two code snippets - that is, predicting which snippet a\nhuman would find easier to understand without predicting each snippet's\ncomprehensibility in isolation. This mitigates noise in predicting 'absolute'\ncomprehensibility measurements, but is still useful for downstream\nsoftware-engineering tasks like assessing whether refactoring improves or\nhinders comprehensibility.\n  We conducted a study to assess and compare the effectiveness of absolute and\nrelative code comprehensibility prediction via machine learning. We used a\ndataset of 150 Java code snippets and 12.5k human comprehensibility\nmeasurements from prior user studies, comparing the models' performance with\nnaive baselines (eg 'always predict the majority class'). Our findings indicate\nthat absolute comprehensibility models improve over the baselines by at most\n33.4% and frequently underperform. In contrast, relative comprehensibility\nmodels are substantially better, with average improvements of 137.8% and 74.7%\nfor snippet-wise and developer-wise prediction, respectively. These results\nsuggest that relative comprehensibility models learn more effectively from the\ndata, supporting their practical applicability for downstream SE tasks."}
{"id": "2510.03480", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.03480", "abs": "https://arxiv.org/abs/2510.03480", "authors": ["Vali Tawosi", "Salwa Alamir", "Xiaomo Liu", "Manuela Veloso"], "title": "LLM Agents for Automated Dependency Upgrades", "comment": null, "summary": "As a codebase expands over time, its library dependencies can become outdated\nand require updates to maintain innovation and security. However, updating a\nlibrary can introduce breaking changes in the code, necessitating significant\ndeveloper time for maintenance. To address this, we introduce a framework of\nLLM agents to be used in combination with migration documentation to\nautomatically recommend and apply code updates and ensure compatibility with\nnew versions. Our solution can automatically localize updated library usages in\nlive Java codebases and implement recommended fixes in a user-friendly manner.\nThe system architecture consists of multiple key components: a Summary Agent,\nControl Agent, and Code Agent. To validate our approach, we apply the framework\non an industrial use case by which we create three synthetic code repositories\nwith major Upgrade changes and benchmark our approach against state-of-the-art\nmethods. Results show that our approach not only performs upgrades using fewer\ntokens across all cases but also achieves a precision of 71.4%, highlighting\nits efficiency and effectiveness compared to state-of-the-art methods."}
{"id": "2510.03319", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.03319", "abs": "https://arxiv.org/abs/2510.03319", "authors": ["Chenxiang Luo", "David K. Y. Yau", "Qun Song"], "title": "SVDefense: Effective Defense against Gradient Inversion Attacks via Singular Value Decomposition", "comment": null, "summary": "Federated learning (FL) enables collaborative model training without sharing\nraw data but is vulnerable to gradient inversion attacks (GIAs), where\nadversaries reconstruct private data from shared gradients. Existing defenses\neither incur impractical computational overhead for embedded platforms or fail\nto achieve privacy protection and good model utility at the same time.\nMoreover, many defenses can be easily bypassed by adaptive adversaries who have\nobtained the defense details. To address these limitations, we propose\nSVDefense, a novel defense framework against GIAs that leverages the truncated\nSingular Value Decomposition (SVD) to obfuscate gradient updates. SVDefense\nintroduces three key innovations, a Self-Adaptive Energy Threshold that adapts\nto client vulnerability, a Channel-Wise Weighted Approximation that selectively\npreserves essential gradient information for effective model training while\nenhancing privacy protection, and a Layer-Wise Weighted Aggregation for\neffective model aggregation under class imbalance. Our extensive evaluation\nshows that SVDefense outperforms existing defenses across multiple\napplications, including image classification, human activity recognition, and\nkeyword spotting, by offering robust privacy protection with minimal impact on\nmodel accuracy. Furthermore, SVDefense is practical for deployment on various\nresource-constrained embedded platforms. We will make our code publicly\navailable upon paper acceptance."}
{"id": "2510.03495", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.03495", "abs": "https://arxiv.org/abs/2510.03495", "authors": ["Erik Pautsch", "Tanmay Singla", "Wenxin Jiang", "Huiyun Peng", "Behnaz Hassanshahi", "Konstantin LÃ¤ufer", "George K. Thiruvathukal", "James C. Davis"], "title": "AgentHub: A Research Agenda for Agent Sharing Infrastructure", "comment": null, "summary": "LLM-based agents are rapidly proliferating, yet the infrastructure for\ndiscovering, evaluating, and governing them remains fragmented compared to\nmature ecosystems like software package registries (e.g., npm) and model hubs\n(e.g., Hugging Face). Recent research and engineering works have begun to\nconsider the requisite infrastructure, but so far they focus narrowly -- on\ndistribution, naming, or protocol negotiation. However, considering broader\nsoftware engineering requirements would improve open-source distribution and\nease reuse. We therefore propose AgentHub, a research agenda for agent sharing.\nBy framing the key challenges of capability clarity, lifecycle transparency,\ninteroperability, governance, security, and workflow integration, AgentHub\ncharts a community-wide agenda for building reliable and scalable agent\necosystems. Our vision is a future where agents can be shared, trusted, and\ncomposed as seamlessly as today's software libraries."}
{"id": "2510.03320", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.03320", "abs": "https://arxiv.org/abs/2510.03320", "authors": ["Raik Dankworth", "Gesina Schwalbe"], "title": "Attack logics, not outputs: Towards efficient robustification of deep neural networks by falsifying concept-based properties", "comment": "13 pages, 2 figures, accepted by \"7th OVERLAY\" workshop", "summary": "Deep neural networks (NNs) for computer vision are vulnerable to adversarial\nattacks, i.e., miniscule malicious changes to inputs may induce unintuitive\noutputs. One key approach to verify and mitigate such robustness issues is to\nfalsify expected output behavior. This allows, e.g., to locally proof security,\nor to (re)train NNs on obtained adversarial input examples. Due to the\nblack-box nature of NNs, current attacks only falsify a class of the final\noutput, such as flipping from $\\texttt{stop_sign}$ to $\\neg\\texttt{stop_sign}$.\nIn this short position paper we generalize this to search for generally\nillogical behavior, as considered in NN verification: falsify constraints\n(concept-based properties) involving further human-interpretable concepts, like\n$\\texttt{red}\\wedge\\texttt{octogonal}\\rightarrow\\texttt{stop_sign}$. For this,\nan easy implementation of concept-based properties on already trained NNs is\nproposed using techniques from explainable artificial intelligence. Further, we\nsketch the theoretical proof that attacks on concept-based properties are\nexpected to have a reduced search space compared to simple class falsification,\nwhilst arguably be more aligned with intuitive robustness targets. As an\noutlook to this work in progress we hypothesize that this approach has\npotential to efficiently and simultaneously improve logical compliance and\nrobustness."}
{"id": "2510.03588", "categories": ["cs.SE", "cs.MA"], "pdf": "https://arxiv.org/pdf/2510.03588", "abs": "https://arxiv.org/abs/2510.03588", "authors": ["Anvith Pabba", "Simin Chen", "Alex Mathai", "Anindya Chakraborty", "Baishakhi Ray"], "title": "REFINE: Enhancing Program Repair Agents through Context-Aware Patch Refinement", "comment": "We also open source our code at\n  https://anonymous.4open.science/r/SemAgent-7B2F/README.md", "summary": "Large Language Models (LLMs) have recently shown strong potential in\nautomatic program repair (APR), especially in repository-level settings where\nthe goal is to generate patches based on natural language issue descriptions,\nlarge codebases, and regression tests. However, despite their promise, current\nLLM-based APR techniques often struggle to produce correct fixes due to limited\nunderstanding of code context and over-reliance on incomplete test suites. As a\nresult, they frequently generate Draft Patches-partially correct patches that\neither incompletely address the bug or overfit to the test cases. In this work,\nwe propose a novel patch refinement framework, Refine, that systematically\ntransforms Draft Patches into correct ones. Refine addresses three key\nchallenges: disambiguating vague issue and code context, diversifying patch\ncandidates through test-time scaling, and aggregating partial fixes via an\nLLM-powered code review process. We implement Refine as a general refinement\nmodule that can be integrated into both open-agent-based and workflow-based APR\nsystems. Our evaluation on the SWE-Bench Lite benchmark shows that Refine\nachieves state-of-the-art results among workflow-based approaches and\napproaches the best-known performance across all APR categories. Specifically,\nRefine boosts AutoCodeRover's performance by 14.67%, achieving a score of\n51.67% and surpassing all prior baselines. On SWE-Bench Verified, Refine\nimproves the resolution rate by 12.2%, and when integrated across multiple APR\nsystems, it yields an average improvement of 14%-demonstrating its broad\neffectiveness and generalizability. These results highlight the effectiveness\nof refinement as a missing component in current APR pipelines and the potential\nof agentic collaboration in closing the gap between near-correct and correct\npatches. We also open source our code."}
{"id": "2510.03407", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03407", "abs": "https://arxiv.org/abs/2510.03407", "authors": ["Boniface M. Sindala", "Ragib Hasan"], "title": "Security Analysis and Threat Modeling of Research Management Applications [Extended Version]", "comment": "8 pages, 4 tables, 2 figures, This is an extended version of a paper\n  published in IEEE SoutheastCon 2025. \\c{opyright} 2025 IEEE", "summary": "Research management applications (RMA) are widely used in clinical research\nenvironments to collect, transmit, analyze, and store sensitive data. This data\nis so valuable making RMAs susceptible to security threats. This analysis,\nanalyzes RMAs' security, focusing on Research Electronic Data Capture (REDCap)\nas an example. We explore the strengths and vulnerabilities within RMAs by\nevaluating the architecture, data flow, and security features. We identify and\nassess potential risks using the MITRE ATT\\&CK framework and STRIDE model. We\nassess REDCap's defenses against common attack vectors focusing on security to\nprovide confidentiality, integrity, availability, non-repudiation, and\nauthentication. We conclude by proposing recommendations for enhancing the\nsecurity of RMAs, ensuring that critical research data remains protected\nwithout compromising usability. This research aims to contribute towards a more\nsecure framework for managing sensitive information in research-intensive\nenvironments."}
{"id": "2510.03641", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.03641", "abs": "https://arxiv.org/abs/2510.03641", "authors": ["Satoshi Masuda", "Satoshi Kouzawa", "Kyousuke Sezai", "Hidetoshi Suhara", "Yasuaki Hiruta", "Kunihiro Kudou"], "title": "Generating High-Level Test Cases from Requirements using LLM: An Industry Study", "comment": "11pages", "summary": "Currently, generating high-level test cases described in natural language\nfrom requirement documents is performed manually. In the industry, including\ncompanies specializing in software testing, there is a significant demand for\nthe automatic generation of high-level test cases from requirement documents\nusing Large Language Models (LLMs). Efforts to utilize LLMs for requirement\nanalysis are underway. In some cases, retrieval-augmented generation (RAG) is\nemployed for generating high-level test cases using LLMs. However, in practical\napplications, it is necessary to create a RAG tailored to the knowledge system\nof each specific application, which is labor-intensive. Moreover, when applying\nhigh-level test case generation as a prompt, there is no established method for\ninstructing the generation of high-level test cases at a level applicable to\nother specifications without using RAG. It is required to establish a method\nfor the automatic generation of high-level test cases that can be generalized\nacross a wider range of requirement documents. In this paper, we propose a\nmethod for generating high-level (GHL) test cases from requirement documents\nusing only prompts, without creating RAGs. In the proposed method, first, the\nrequirement document is input into the LLM to generate test design techniques\ncorresponding to the requirement document. Then, high-level test cases are\ngenerated for each of the generated test design techniques. Furthermore, we\nverify an evaluation method based on semantic similarity of the generated\nhigh-level test cases. In the experiments, we confirmed the method using\ndatasets from Bluetooth and Mozilla, where requirement documents and high-level\ntest cases are available, achieving macro-recall measurement of 0.81 and 0.37,\nrespectively. We believe that the method is feasible for practical application\nin generating high-level test cases without using RAG."}
{"id": "2510.03417", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.03417", "abs": "https://arxiv.org/abs/2510.03417", "authors": ["Javad Rafiei Asl", "Sidhant Narula", "Mohammad Ghasemigol", "Eduardo Blanco", "Daniel Takabi"], "title": "NEXUS: Network Exploration for eXploiting Unsafe Sequences in Multi-Turn LLM Jailbreaks", "comment": "Javad Rafiei Asl and Sidhant Narula are co-first authors", "summary": "Large Language Models (LLMs) have revolutionized natural language processing\nbut remain vulnerable to jailbreak attacks, especially multi-turn jailbreaks\nthat distribute malicious intent across benign exchanges and bypass alignment\nmechanisms. Existing approaches often explore the adversarial space poorly,\nrely on hand-crafted heuristics, or lack systematic query refinement. We\npresent NEXUS (Network Exploration for eXploiting Unsafe Sequences), a modular\nframework for constructing, refining, and executing optimized multi-turn\nattacks. NEXUS comprises: (1) ThoughtNet, which hierarchically expands a\nharmful intent into a structured semantic network of topics, entities, and\nquery chains; (2) a feedback-driven Simulator that iteratively refines and\nprunes these chains through attacker-victim-judge LLM collaboration using\nharmfulness and semantic-similarity benchmarks; and (3) a Network Traverser\nthat adaptively navigates the refined query space for real-time attacks. This\npipeline uncovers stealthy, high-success adversarial paths across LLMs. On\nseveral closed-source and open-source LLMs, NEXUS increases attack success rate\nby 2.1% to 19.4% over prior methods. Code: https://github.com/inspire-lab/NEXUS"}
{"id": "2510.03712", "categories": ["cs.SE", "68M15, 90B25, 68T05, 90C29", "C.4; C.2.4; D.2.5; D.4.5"], "pdf": "https://arxiv.org/pdf/2510.03712", "abs": "https://arxiv.org/abs/2510.03712", "authors": ["Jahidul Arafat", "Kh. M. Moniruzzaman", "Shamim Hossain", "Fariha Tasmin", "Kamrujjaman", "Ahsan Habib Tareq"], "title": "Detecting and Preventing Latent Risk Accumulation in High-Performance Software Systems", "comment": "26 pages, 12 tables, 4 figures. Academic-industry collaboration.\n  Framework (HYDRA, RAVEN, APEX) for optimization-induced vulnerabilities.\n  Evaluated: 2,160 configs, 12.7TB data, 1,748 scenarios", "summary": "Modern distributed systems employ aggressive optimization strategies that\ncreate latent risks - hidden vulnerabilities where exceptional performance\nmasks catastrophic fragility when optimizations fail. Cache layers achieving\n99% hit rates can obscure database bottlenecks until cache failures trigger\n100x load amplification and cascading collapse. Current reliability engineering\nfocuses on reactive incident response rather than proactive detection of\noptimization-induced vulnerabilities. This paper presents the first\ncomprehensive framework for systematic latent risk detection, prevention, and\noptimization through integrated mathematical modeling, intelligent perturbation\ntesting, and risk-aware performance optimization. We introduce the Latent Risk\nIndex (LRI) that correlates strongly with incident severity (r=0.863, p<0.001),\nenabling predictive risk assessment. Our framework integrates three systems:\nHYDRA employing six optimization-aware perturbation strategies achieving 89.7%\nrisk discovery rates, RAVEN providing continuous production monitoring with\n92.9% precision and 93.8% recall across 1,748 scenarios, and APEX enabling\nrisk-aware optimization maintaining 96.6% baseline performance while reducing\nlatent risks by 59.2%. Evaluation across three testbed environments\ndemonstrates strong statistical validation with large effect sizes (Cohen\nd>2.0) and exceptional reproducibility (r>0.92). Production deployment over 24\nweeks shows 69.1% mean time to recovery reduction, 78.6% incident severity\nreduction, and 81 prevented incidents generating 1.44M USD average annual\nbenefits with 3.2-month ROI. Our approach transforms reliability engineering\nfrom reactive incident management to proactive risk-aware optimization."}
{"id": "2510.03542", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03542", "abs": "https://arxiv.org/abs/2510.03542", "authors": ["Pouriya Alimoradi", "Ali Barati", "Hamid Barati"], "title": "A Multi-Layer Electronic and Cyber Interference Model for AI-Driven Cruise Missiles: The Case of Khuzestan Province", "comment": null, "summary": "The rapid advancement of Artificial Intelligence has enabled the development\nof cruise missiles endowed with high levels of autonomy, adaptability, and\nprecision. These AI driven missiles integrating deep learning algorithms, real\ntime data processing, and advanced guidance systems pose critical threats to\nstrategic infrastructures, especially under complex geographic and climatic\nconditions such as those found in Irans Khuzestan Province. In this paper, we\npropose a multi layer interference model, encompassing electronic warfare,\ncyberattacks, and deception strategies, to degrade the performance of AI guided\ncruise missiles significantly. Our experimental results, derived from 400\nsimulation runs across four distinct scenarios, demonstrate notable\nimprovements when employing the integrated multi layer approach compared to\nsingle layer or no interference baselines. Specifically, the average missile\ndeviation from its intended target increases from 0.25 to 8.65 under multi\nlayer interference a more than 3300 increase in angular deviation. Furthermore,\nthe target acquisition success rate is reduced from 92.7 in the baseline\nscenario to 31.5, indicating a 66 decrease in successful strikes. While\nresource consumption for multi layer strategies rises by approximately 25\ncompared to single layer methods, the significant drop in missile accuracy and\nreliability justifies the more intensive deployment of jamming power, cyber\nresources, and decoy measures. Beyond these quantitative improvements, the\nproposed framework uses a deep reinforcement learning based defense coordinator\nto adaptively select the optimal configuration of EW, cyber, and deception\ntactics in real time."}
{"id": "2510.03743", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.03743", "abs": "https://arxiv.org/abs/2510.03743", "authors": ["Zachary Eberhart", "Collin McMillan"], "title": "APIDA-Chat: Structured Synthesis of API Search Dialogues to Bootstrap Conversational Agents", "comment": "4 pages, 2 figures. To be published in Proceedings of the 40th\n  IEEE/ACM International Conference on Automated Software Engineering", "summary": "Large-language-model assistants are suitable for explaining popular APIs, yet\nthey falter on niche or proprietary libraries because the multi-turn dialogue\ndata needed for fine-tuning are scarce. We present APIDA-Chat, an open-source\npipeline that converts symbolic dialogue-act \"scripts\" into realistic,\ndomain-grounded API Search conversations using a lightweight model for\ninexpensive training data generation. Phase I pairs a legacy dialogue planner\nwith a high-capability teacher LLM (o4-mini) to synthesize a \"gold set\" of\nrealized dialogues; then, a smaller Llama 3.2 3B student model is fine-tuned on\nthis corpus. Phase II drops the teacher and reuses the same planner with the\nfine-tuned model, allowing rapid, low-cost synthesis of new dialogues without\nexposing source code to external services. The fine-tuned student improves BLEU\nfrom 0.38 to 0.50 and BERTScore from 0.88 to 0.91 versus the base model while\nrunning entirely on a single consumer GPU. All components are modular and\npublicly released to serve as a conservative baseline for future work.\nAPIDA-Chat is open-sourced at https://github.com/Zeberhart/apida-chat and a\nvideo demo is available at https://youtu.be/YqmZBHyGbPs ."}
{"id": "2510.03559", "categories": ["cs.CR", "cs.HC"], "pdf": "https://arxiv.org/pdf/2510.03559", "abs": "https://arxiv.org/abs/2510.03559", "authors": ["Zeya Chen", "Jianing Wen", "Ruth Schmidt", "Yaxing Yao", "Toby Jia-Jun Li", "Tianshi Li"], "title": "PrivacyMotiv: Speculative Persona Journeys for Empathic and Motivating Privacy Reviews in UX Design", "comment": "42 pages, 13 figures", "summary": "UX professionals routinely conduct design reviews, yet privacy concerns are\noften overlooked -- not only due to limited tools, but more critically because\nof low intrinsic motivation. Limited privacy knowledge, weak empathy for\nunexpectedly affected users, and low confidence in identifying harms make it\ndifficult to address risks. We present PrivacyMotiv, an LLM-powered system that\nsupports privacy-oriented design diagnosis by generating speculative personas\nwith UX user journeys centered on individuals vulnerable to privacy risks.\nDrawing on narrative strategies, the system constructs relatable and\nattention-drawing scenarios that show how ordinary design choices may cause\nunintended harms, expanding the scope of privacy reflection in UX. In a\nwithin-subjects study with professional UX practitioners (N=16), we compared\nparticipants' self-proposed methods with PrivacyMotiv across two privacy review\ntasks. Results show significant improvements in empathy, intrinsic motivation,\nand perceived usefulness. This work contributes a promising privacy review\napproach which addresses the motivational barriers in privacy-aware UX."}
{"id": "2510.03755", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.03755", "abs": "https://arxiv.org/abs/2510.03755", "authors": ["Roham Koohestani", "Parham Bateni", "Aydin Ebrahimi", "Behdad Etezadi", "Kiarash Karimi", "Maliheh Izadi"], "title": "Code4MeV2: a Research-oriented Code-completion Platform", "comment": "Under review for submission at a conference", "summary": "The adoption of AI-powered code completion tools in software development has\nincreased substantially, yet the user interaction data produced by these\nsystems remain proprietary within large corporations. This creates a barrier\nfor the academic community, as researchers must often develop dedicated\nplatforms to conduct studies on human--AI interaction, making reproducible\nresearch and large-scale data analysis impractical. In this work, we introduce\nCode4MeV2, a research-oriented, open-source code completion plugin for\nJetBrains IDEs, as a solution to this limitation. Code4MeV2 is designed using a\nclient--server architecture and features inline code completion and a\ncontext-aware chat assistant. Its core contribution is a modular and\ntransparent data collection framework that gives researchers fine-grained\ncontrol over telemetry and context gathering. Code4MeV2 achieves\nindustry-comparable performance in terms of code completion, with an average\nlatency of 200~ms. We assess our tool through a combination of an expert\nevaluation and a user study with eight participants. Feedback from both\nresearchers and daily users highlights its informativeness and usefulness. We\ninvite the community to adopt and contribute to this tool. More information\nabout the tool can be found at https://app.code4me.me."}
{"id": "2510.03565", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03565", "abs": "https://arxiv.org/abs/2510.03565", "authors": ["Cory Brynds", "Parker McLeod", "Lauren Caccamise", "Asmita Pal", "Dewan Saiham", "Sazadur Rahman", "Joshua San Miguel", "Di Wu"], "title": "CryptOracle: A Modular Framework to Characterize Fully Homomorphic Encryption", "comment": null, "summary": "Privacy-preserving machine learning has become an important long-term pursuit\nin this era of artificial intelligence (AI). Fully Homomorphic Encryption (FHE)\nis a uniquely promising solution, offering provable privacy and security\nguarantees. Unfortunately, computational cost is impeding its mass adoption.\nModern solutions are up to six orders of magnitude slower than plaintext\nexecution. Understanding and reducing this overhead is essential to the\nadvancement of FHE, particularly as the underlying algorithms evolve rapidly.\nThis paper presents a detailed characterization of OpenFHE, a comprehensive\nopen-source library for FHE, with a particular focus on the CKKS scheme due to\nits significant potential for AI and machine learning applications. We\nintroduce CryptOracle, a modular evaluation framework comprising (1) a\nbenchmark suite, (2) a hardware profiler, and (3) a predictive performance\nmodel. The benchmark suite encompasses OpenFHE kernels at three abstraction\nlevels: workloads, microbenchmarks, and primitives. The profiler is compatible\nwith standard and user-specified security parameters. CryptOracle monitors\napplication performance, captures microarchitectural events, and logs power and\nenergy usage for AMD and Intel systems. These metrics are consumed by a\nmodeling engine to estimate runtime and energy efficiency across different\nconfiguration scenarios, with error geomean of $-7.02\\%\\sim8.40\\%$ for runtime\nand $-9.74\\%\\sim15.67\\%$ for energy. CryptOracle is open source, fully modular,\nand serves as a shared platform to facilitate the collaborative advancements of\napplications, algorithms, software, and hardware in FHE. The CryptOracle code\ncan be accessed at https://github.com/UnaryLab/CryptOracle."}
{"id": "2510.03802", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.03802", "abs": "https://arxiv.org/abs/2510.03802", "authors": ["Gilberto Recupito", "Vincenzo De Martino", "Dario Di Nucci", "Fabio Palomba"], "title": "A First Look at the Lifecycle of DL-Specific Self-Admitted Technical Debt", "comment": "Accepted at the International Workshop of Software Quality Assurance\n  for Artificial Intelligence 2025 (SQA4AI), Montr\\'eal, Canada", "summary": "The rapid adoption of Deep Learning (DL)-enabled systems has revolutionized\nsoftware development, driving innovation across various domains. However, these\nsystems also introduce unique challenges, particularly in maintaining software\nquality and performance. Among these challenges, Self-Admitted Technical Debt\n(SATD) has emerged as a growing concern, significantly impacting the\nmaintainability and overall quality of ML and DL-enabled systems. Despite its\ncritical implications, the lifecycle of DL-specific SATD, how developers\nintroduce, acknowledge, and address it over time-remains underexplored. This\nstudy presents a preliminary analysis of the persistence and lifecycle of\nDL-specific SATD in DL-enabled systems. The purpose of this project is to\nuncover the patterns of SATD introduction, recognition, and durability during\nthe development life cycle, providing information on how to manage these\nissues. Using mining software repository techniques, we examined 40 ML\nprojects, focusing on 185 DL-specific SATD instances. The analysis tracked the\nintroduction and persistence of SATD instances through project commit histories\nto assess their lifecycle and developer actions. The findings indicate that\nDL-specific SATD is predominantly introduced during the early and middle stages\nof project development. Training and Hardware phases showed the longest SATD\ndurations, highlighting critical areas where debt accumulates and persists.\nAdditionally, developers introduce DL-specific SATD more frequently during\nfeature implementation and bug fixes. This study emphasizes the need for\ntargeted DL-specific SATD management strategies in DL-enabled systems to\nmitigate its impact. By understanding the temporal characteristics and\nevolution of DL-specific SATD, developers can prioritize interventions at\ncritical stages to improve the maintainability and quality of the system."}
{"id": "2510.03610", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.03610", "abs": "https://arxiv.org/abs/2510.03610", "authors": ["Zachary Ezetta", "Wu-chang Feng"], "title": "PentestMCP: A Toolkit for Agentic Penetration Testing", "comment": null, "summary": "Agentic AI is transforming security by automating many tasks being performed\nmanually. While initial agentic approaches employed a monolithic architecture,\nthe Model-Context-Protocol has now enabled a remote-procedure call (RPC)\nparadigm to agentic applications, allowing for the flexible construction and\ncomposition of multi-function agents. This paper describes PentestMCP, a\nlibrary of MCP server implementations that support agentic penetration testing.\nBy supporting common penetration testing tasks such as network scanning,\nresource enumeration, service fingerprinting, vulnerability scanning,\nexploitation, and post-exploitation, PentestMCP allows a developer to customize\nmulti-agent workflows for performing penetration tests."}
{"id": "2510.03843", "categories": ["cs.SE", "cs.HC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.03843", "abs": "https://arxiv.org/abs/2510.03843", "authors": ["Vincent Nguyen", "Guilherme Herzog", "JosÃ© Cambronero", "Marcus Revaj", "Aditya Kini", "Alexander FrÃ¶mmgen", "Maxim Tabachnyk"], "title": "Smart Paste: Automatically Fixing Copy/Paste for Google Developers", "comment": "11 pages", "summary": "Manually editing pasted code is a long-standing developer pain point. In\ninternal software development at Google, we observe that code is pasted 4 times\nmore often than it is manually typed. These paste actions frequently require\nfollow-up edits, ranging from simple reformatting and renaming to more complex\nstyle adjustments and cross-language translations. Prior work has shown deep\nlearning can be used to predict these edits. In this work, we show how to\niteratively develop and scale Smart Paste, an IDE feature for post-paste edit\nsuggestions, to Google's development environment. This experience can serve as\na guide for AI practitioners on a holistic approach to feature development,\ncovering user experience, system integration, and model capabilities. Since\ndeployment, Smart Paste has had overwhelmingly positive feedback with a 45%\nacceptance rate. At Google's enterprise scale, these accepted suggestions\naccount substantially for over 1% of all code written company-wide."}
{"id": "2510.03623", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.03623", "abs": "https://arxiv.org/abs/2510.03623", "authors": ["Maraz Mia", "Mir Mehedi A. Pritom"], "title": "Explainable but Vulnerable: Adversarial Attacks on XAI Explanation in Cybersecurity Applications", "comment": "10 pages, 9 figures, 4 tables", "summary": "Explainable Artificial Intelligence (XAI) has aided machine learning (ML)\nresearchers with the power of scrutinizing the decisions of the black-box\nmodels. XAI methods enable looking deep inside the models' behavior, eventually\ngenerating explanations along with a perceived trust and transparency. However,\ndepending on any specific XAI method, the level of trust can vary. It is\nevident that XAI methods can themselves be a victim of post-adversarial attacks\nthat manipulate the expected outcome from the explanation module. Among such\nattack tactics, fairwashing explanation (FE), manipulation explanation (ME),\nand backdoor-enabled manipulation attacks (BD) are the notable ones. In this\npaper, we try to understand these adversarial attack techniques, tactics, and\nprocedures (TTPs) on explanation alteration and thus the effect on the model's\ndecisions. We have explored a total of six different individual attack\nprocedures on post-hoc explanation methods such as SHAP (SHapley Additive\nexPlanations), LIME (Local Interpretable Model-agnostic Explanation), and IG\n(Integrated Gradients), and investigated those adversarial attacks in\ncybersecurity applications scenarios such as phishing, malware, intrusion, and\nfraudulent website detection. Our experimental study reveals the actual\neffectiveness of these attacks, thus providing an urgency for immediate\nattention to enhance the resiliency of XAI methods and their applications."}
{"id": "2510.03862", "categories": ["cs.SE", "cs.AI", "500"], "pdf": "https://arxiv.org/pdf/2510.03862", "abs": "https://arxiv.org/abs/2510.03862", "authors": ["Nathalia Nascimento", "Everton Guimaraes", "Paulo Alencar"], "title": "Designing Empirical Studies on LLM-Based Code Generation: Towards a Reference Framework", "comment": "5 pages", "summary": "The rise of large language models (LLMs) has introduced transformative\npotential in automated code generation, addressing a wide range of software\nengineering challenges. However, empirical evaluation of LLM-based code\ngeneration lacks standardization, with studies varying widely in goals, tasks,\nand metrics, which limits comparability and reproducibility. In this paper, we\npropose a theoretical framework for designing and reporting empirical studies\non LLM-based code generation. The framework is grounded in both our prior\nexperience conducting such experiments and a comparative analysis of key\nsimilarities and differences among recent studies. It organizes evaluation\naround core components such as problem sources, quality attributes, and\nmetrics, supporting structured and systematic experimentation. We demonstrate\nits applicability through representative case mappings and identify\nopportunities for refinement. Looking forward, we plan to evolve the framework\ninto a more robust and mature tool for standardizing LLM evaluation across\nsoftware engineering contexts."}
{"id": "2510.03625", "categories": ["cs.CR", "cs.DC"], "pdf": "https://arxiv.org/pdf/2510.03625", "abs": "https://arxiv.org/abs/2510.03625", "authors": ["Joachim Neu", "Javier Nieto", "Ling Ren"], "title": "On the Limits of Consensus under Dynamic Availability and Reconfiguration", "comment": null, "summary": "Proof-of-stake blockchains require consensus protocols that support Dynamic\nAvailability and Reconfiguration (so-called DAR setting), where the former\nmeans that the consensus protocol should remain live even if a large number of\nnodes temporarily crash, and the latter means it should be possible to change\nthe set of operating nodes over time. State-of-the-art protocols for the DAR\nsetting, such as Ethereum, Cardano's Ouroboros, or Snow White, require\nunrealistic additional assumptions, such as social consensus, or that key\nevolution is performed even while nodes are not participating. In this paper,\nwe identify the necessary and sufficient adversarial condition under which\nconsensus can be achieved in the DAR setting without additional assumptions. We\nthen introduce a new and realistic additional assumption: honest nodes dispose\nof their cryptographic keys the moment they express intent to exit from the set\nof operating nodes. To add reconfiguration to any dynamically available\nconsensus protocol, we provide a bootstrapping gadget that is particularly\nsimple and efficient in the common optimistic case of few reconfigurations and\nno double-spending attempts."}
{"id": "2510.03879", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.03879", "abs": "https://arxiv.org/abs/2510.03879", "authors": ["Tianyu Li", "Ruishi Li", "Bo Wang", "Brandon Paulsen", "Umang Mathur", "Prateek Saxena"], "title": "Adversarial Agent Collaboration for C to Rust Translation", "comment": null, "summary": "Translating C to memory-safe languages, like Rust, prevents critical memory\nsafety vulnerabilities that are prevalent in legacy C software. Existing\napproaches for C to safe Rust translation, including LLM-assisted ones, do not\ngeneralize on larger (> 500 LoC) C codebases because they depend on complex\nprogram analyses that frequently break. In this work, we present ACToR\n(Adversarial C To Rust translator), a simple LLM agent-based approach. Inspired\nby GANs, ACToR pits a generator agent against a discriminator agent, which\ncollaborate to iteratively generate a Rust translation. On each iteration, the\ntranslator agent synthesizes and refines a Rust translation to pass an existing\nsuite of tests, and then the discriminator agent finds new failing tests. We\ndemonstrate that ACToR translates all of the 63 real-world command line\nutilities considered in our benchmarks, which have an average size of 485 lines\nof code, and it achieves over 90% test pass rate with zero human intervention.\nTo our knowledge, it is the first such system that reliably translates C\nprograms of this scale. Furthermore, ACToR improves translation correctness by\nup to 18.9% compared to baseline, non-adversarial approaches."}
{"id": "2510.03631", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03631", "abs": "https://arxiv.org/abs/2510.03631", "authors": ["Saleh Darzi", "Saif Eddine Nouma", "Kiarash Sedghighadikolaei", "Attila Altay"], "title": "QPADL: Post-Quantum Private Spectrum Access with Verified Location and DoS Resilience", "comment": "13 pages, 3 figures, 1 table, 4 algorithms", "summary": "With advances in wireless communication and growing spectrum scarcity,\nSpectrum Access Systems (SASs) offer an opportunistic solution but face\nsignificant security challenges. Regulations require disclosure of location\ncoordinates and transmission details, exposing user privacy and anonymity\nduring spectrum queries, while the database operations themselves permit\nDenial-of-Service (DoS) attacks. As location-based services, SAS is also\nvulnerable to compromised or malicious users conducting spoofing attacks. These\nthreats are further amplified given the quantum computing advancements. Thus,\nwe propose QPADL, the first post-quantum (PQ) secure framework that\nsimultaneously ensures privacy, anonymity, location verification, and DoS\nresilience while maintaining efficiency for large-scale spectrum access\nsystems. QPADL introduces SAS-tailored private information retrieval for\nlocation privacy, a PQ-variant of Tor for anonymity, and employs advanced\nsignature constructions for location verification alongside client puzzle\nprotocols and rate-limiting technique for DoS defense. We formally assess its\nsecurity and conduct a comprehensive performance evaluation, incorporating GPU\nparallelization and optimization strategies to demonstrate practicality and\nscalability."}
{"id": "2510.03890", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.03890", "abs": "https://arxiv.org/abs/2510.03890", "authors": ["Jose Garcia-Alonso", "Enrique Moguel", "Jaime Alvarado-Valiente", "Javier Romero-Alvarez", "Ãlvaro M. Aparicio-Morales", "Juan M. Murillo", "Francisco Javier Cavero", "AdriÃ¡n Romero-Flores", "Alfonso E. Marquez-Chamorro", "JosÃ© Antonio Parejo", "Antonio Ruiz-CortÃ©s", "Giuseppe Bisicchia", "Alessandro Bocci", "Antonio Brogi"], "title": "Rethinking Services in the Quantum Age: The SOQ Paradigm", "comment": "39 pages, 5 figures, 6 tables", "summary": "Quantum computing is rapidly progressing from theoretical promise to\npractical implementation, offering significant computational advantages for\ntasks in optimization, simulation, cryptography, and machine learning. However,\nits integration into real-world software systems remains constrained by\nhardware fragility, platform heterogeneity, and the absence of robust software\nengineering practices. This paper introduces Service-Oriented Quantum (SOQ), a\nnovel paradigm that reimagines quantum software systems through the lens of\nclassical service-oriented computing. Unlike prior approaches such as Quantum\nService-Oriented Computing (QSOC), which treat quantum capabilities as\nauxiliary components within classical systems, SOQ positions quantum services\nas autonomous, composable, and interoperable entities. We define the\nfoundational principles of SOQ, propose a layered technology stack to support\nits realization, and identify the key research and engineering challenges that\nmust be addressed, including interoperability, hybridity, pricing models,\nservice abstractions, and workforce development. This approach is of vital\nimportance for the advancement of quantum technology because it enables the\nscalable, modular, and interoperable integration of quantum computing into\nreal-world software systems independently and without relying on a dedicated\nclassical environment to manage quantum processing."}
{"id": "2510.03697", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03697", "abs": "https://arxiv.org/abs/2510.03697", "authors": ["Benjamin Marsh", "Paolo Serafino"], "title": "A Time-Bound Signature Scheme for Blockchains", "comment": "Accepted to the 2025 IEEE International Conference on Blockchain", "summary": "We introduce a modified Schnorr signature scheme to allow for time-bound\nsignatures for transaction fee auction bidding and smart contract purposes in a\nblockchain context, ensuring an honest producer can only validate a signature\nbefore a given block height. The immutable blockchain is used as a source of\nuniversal time for the signature scheme. We show the use of such a signature\nscheme leads to lower MEV revenue for builders. We then apply our time-bound\nsignatures to Ethereum's EIP-1559 and show how it can be used to mitigate the\neffect of MEV on predicted equilibrium strategies."}
{"id": "2510.03894", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.03894", "abs": "https://arxiv.org/abs/2510.03894", "authors": ["Antonios Saravanos"], "title": "A Brief History of the Waterfall Model: Past, Present, and Future", "comment": null, "summary": "The waterfall model, one of the earliest software development methodologies,\nhas played a foundational role in shaping contemporary software engineering\npractices. This paper provides a historical and critical overview of the model,\ntracing its conceptual origins in software engineering, its formalization by\nRoyce, and its evolution through decades of industry adoption and critique.\nAlthough often criticized for its rigidity, shortcomings, and high failure\nrates, the waterfall model persists in specific domains. Its principles\ncontinue to influence contemporary hybrid development frameworks that combine\ntraditional and agile methods. Drawing on a range of scholarly sources, this\nstudy synthesizes key developments in the perception and application of the\nwaterfall model. The analysis highlights how the model has shifted from a\nstandalone framework to a component within modern hybrid methodologies. By\nrevisiting its origins, assessing its present utility, and examining its role\nin contemporary development practices, this paper argues that the waterfall\nmodel remains relevant, not as a relic of the past but as part of context-aware\ndevelopment strategies. The paper contends that the model's enduring relevance\nlies in its adaptability. By recognizing both its limitations and its\nstrengths, and by understanding its integration within hybrid approaches,\npractitioners can make more informed decisions about methodology selection and\nprocess design in diverse development environments."}
{"id": "2510.03705", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03705", "abs": "https://arxiv.org/abs/2510.03705", "authors": ["Yulin Chen", "Haoran Li", "Yuan Sui", "Yangqiu Song", "Bryan Hooi"], "title": "Backdoor-Powered Prompt Injection Attacks Nullify Defense Methods", "comment": "EMNLP 2025 Findings", "summary": "With the development of technology, large language models (LLMs) have\ndominated the downstream natural language processing (NLP) tasks. However,\nbecause of the LLMs' instruction-following abilities and inability to\ndistinguish the instructions in the data content, such as web pages from search\nengines, the LLMs are vulnerable to prompt injection attacks. These attacks\ntrick the LLMs into deviating from the original input instruction and executing\nthe attackers' target instruction. Recently, various instruction hierarchy\ndefense strategies are proposed to effectively defend against prompt injection\nattacks via fine-tuning. In this paper, we explore more vicious attacks that\nnullify the prompt injection defense methods, even the instruction hierarchy:\nbackdoor-powered prompt injection attacks, where the attackers utilize the\nbackdoor attack for prompt injection attack purposes. Specifically, the\nattackers poison the supervised fine-tuning samples and insert the backdoor\ninto the model. Once the trigger is activated, the backdoored model executes\nthe injected instruction surrounded by the trigger. We construct a benchmark\nfor comprehensive evaluation. Our experiments demonstrate that backdoor-powered\nprompt injection attacks are more harmful than previous prompt injection\nattacks, nullifying existing prompt injection defense methods, even the\ninstruction hierarchy techniques."}
{"id": "2510.03902", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.03902", "abs": "https://arxiv.org/abs/2510.03902", "authors": ["Rana Nameer Hussain Khan", "Dawood Wasif", "Jin-Hee Cho", "Ali Butt"], "title": "Multi-Agent Code-Orchestrated Generation for Reliable Infrastructure-as-Code", "comment": null, "summary": "The increasing complexity of cloud-native infrastructure has made\nInfrastructure-as-Code (IaC) essential for reproducible and scalable\ndeployments. While large language models (LLMs) have shown promise in\ngenerating IaC snippets from natural language prompts, their monolithic,\nsingle-pass generation approach often results in syntactic errors, policy\nviolations, and unscalable designs. In this paper, we propose MACOG\n(Multi-Agent Code-Orchestrated Generation), a novel multi-agent LLM-based\narchitecture for IaC generation that decomposes the task into modular subtasks\nhandled by specialized agents: Architect, Provider Harmonizer, Engineer,\nReviewer, Security Prover, Cost and Capacity Planner, DevOps, and Memory\nCurator. The agents interact via a shared-blackboard, finite-state orchestrator\nlayer, and collectively produce Terraform configurations that are not only\nsyntactically valid but also policy-compliant and semantically coherent. To\nensure infrastructure correctness and governance, we incorporate Terraform Plan\nfor execution validation and Open Policy Agent (OPA) for customizable policy\nenforcement. We evaluate MACOG using the IaC-Eval benchmark, where MACOG is the\ntop enhancement across models, e.g., GPT-5 improves from 54.90 (RAG) to 74.02\nand Gemini-2.5 Pro from 43.56 to 60.13, with concurrent gains on BLEU,\nCodeBERTScore, and an LLM-judge metric. Ablations show constrained decoding and\ndeploy feedback are critical: removing them drops IaC-Eval to 64.89 and 56.93,\nrespectively."}
{"id": "2510.03720", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03720", "abs": "https://arxiv.org/abs/2510.03720", "authors": ["Dongyang Zhan", "Zhaofeng Yu", "Xiangzhan Yu", "Hongli Zhang", "Lin Ye"], "title": "Shrinking the Kernel Attack Surface Through Static and Dynamic Syscall Limitation", "comment": "13 pages, 5 figures. Accepted for publication in IEEE Transactions on\n  Services Computing (TSC), 2023", "summary": "Linux Seccomp is widely used by the program developers and the system\nmaintainers to secure the operating systems, which can block unused syscalls\nfor different applications and containers to shrink the attack surface of the\noperating systems. However, it is difficult to configure the whitelist of a\ncontainer or application without the help of program developers. Docker\ncontainers block about only 50 syscalls by default, and lots of unblocked\nuseless syscalls introduce a big kernel attack surface. To obtain the dependent\nsyscalls, dynamic tracking is a straight-forward approach but it cannot get the\nfull syscall list. Static analysis can construct an over-approximated syscall\nlist, but the list contains many false positives. In this paper, a systematic\ndependent syscall analysis approach, sysverify, is proposed by combining static\nanalysis and dynamic verification together to shrink the kernel attack surface.\nThe semantic gap between the binary executables and syscalls is bridged by\nanalyzing the binary and the source code, which builds the mapping between the\nlibrary APIs and syscalls systematically. To further reduce the attack surface\nat best effort, we propose a dynamic verification approach to intercept and\nanalyze the security of the invocations of indirect-call-related or rarely\ninvoked syscalls with low overhead."}
{"id": "2510.03914", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.03914", "abs": "https://arxiv.org/abs/2510.03914", "authors": ["Yonnel Chen Kuang Piao", "Jean Carlors Paul", "Leuson Da Silva", "Arghavan Moradi Dakhel", "Mohammad Hamdaqa", "Foutse Khomh"], "title": "Refactoring with LLMs: Bridging Human Expertise and Machine Understanding", "comment": "43 pages, 2 figures, 9 tables", "summary": "Code refactoring is a fundamental software engineering practice aimed at\nimproving code quality and maintainability. Despite its importance, developers\noften neglect refactoring due to the significant time, effort, and resources it\nrequires, as well as the lack of immediate functional rewards. Although several\nautomated refactoring tools have been proposed, they remain limited in\nsupporting a broad spectrum of refactoring types. In this study, we explore\nwhether instruction strategies inspired by human best-practice guidelines can\nenhance the ability of Large Language Models (LLMs) to perform diverse\nrefactoring tasks automatically. Leveraging the instruction-following and code\ncomprehension capabilities of state-of-the-art LLMs (e.g., GPT-mini and\nDeepSeek-V3), we draw on Martin Fowler's refactoring guidelines to design\nmultiple instruction strategies that encode motivations, procedural steps, and\ntransformation objectives for 61 well-known refactoring types. We evaluate\nthese strategies on benchmark examples and real-world code snippets from GitHub\nprojects. Our results show that instruction designs grounded in Fowler's\nguidelines enable LLMs to successfully perform all benchmark refactoring types\nand preserve program semantics in real-world settings, an essential criterion\nfor effective refactoring. Moreover, while descriptive instructions are more\ninterpretable to humans, our results show that rule-based instructions often\nlead to better performance in specific scenarios. Interestingly, allowing\nmodels to focus on the overall goal of refactoring, rather than prescribing a\nfixed transformation type, can yield even greater improvements in code quality."}
{"id": "2510.03737", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03737", "abs": "https://arxiv.org/abs/2510.03737", "authors": ["Dongyang Zhan", "Zhaofeng Yu", "Xiangzhan Yu", "Hongli Zhang", "Lin Ye", "Likun Liu"], "title": "Securing Operating Systems Through Fine-grained Kernel Access Limitation for IoT Systems", "comment": "14 pages, 3 figures. Accepted for publication in IEEE Internet of\n  Things Journal (IOTJ), 2023", "summary": "With the development of Internet of Things (IoT), it is gaining a lot of\nattention. It is important to secure the embedded systems with low overhead.\nThe Linux Seccomp is widely used by developers to secure the kernels by\nblocking the access of unused syscalls, which introduces less overhead.\nHowever, there are no systematic Seccomp configuration approaches for IoT\napplications without the help of developers. In addition, the existing Seccomp\nconfiguration approaches are coarse-grained, which cannot analyze and limit the\nsyscall arguments. In this paper, a novel static dependent syscall analysis\napproach for embedded applications is proposed, which can obtain all of the\npossible dependent syscalls and the corresponding arguments of the target\napplications. So, a fine-grained kernel access limitation can be performed for\nthe IoT applications. To this end, the mappings between dynamic library APIs\nand syscalls according with their arguments are built, by analyzing the control\nflow graphs and the data dependency relationships of the dynamic libraries. To\nthe best of our knowledge, this is the first work to generate the fine-grained\nSeccomp profile for embedded applications."}
{"id": "2510.03920", "categories": ["cs.SE", "cs.SI"], "pdf": "https://arxiv.org/pdf/2510.03920", "abs": "https://arxiv.org/abs/2510.03920", "authors": ["Ravi Kalluri"], "title": "Why Does the Engineering Manager Still Exist in Agile Software Development?", "comment": "12 pages, 3 figures, 2 tables", "summary": "Although Agile methodologies emphasize decentralized decision-making and team\nautonomy, engineering managers continue to be employed in Agile software\norganizations. This apparent paradox suggests that traditional managerial\nfunctions persist despite the theoretical displacement of managerial hierarchy\nin Agile. This paper explores the persistence of engineering managers through a\nmultidimensional framework encompassing historical context, theoretical\ntensions, organizational realities, empirical evidence, evolving managerial\nroles, and practical implications. A systematic literature review underpins our\nmultifaceted analysis, supplemented by illustrative case studies. We conclude\nby proposing a conceptual model that reconciles Agile principles with\nmanagerial necessity, offering guidance for practitioners, researchers, and\ntool designers. Implications for leadership development, tool integration, and\nfuture research are discussed."}
{"id": "2510.03752", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03752", "abs": "https://arxiv.org/abs/2510.03752", "authors": ["Rohit Chatterjee", "Changrui Mu", "Prashant Nalini Vasudevan"], "title": "Public-Key Encryption from the MinRank Problem", "comment": null, "summary": "We construct a public-key encryption scheme from the hardness of the\n(planted) MinRank problem over uniformly random instances. This corresponds to\nthe hardness of decoding random linear rank-metric codes. Existing\nconstructions of public-key encryption from such problems require hardness for\nstructured instances arising from the masking of efficiently decodable codes.\nCentral to our construction is the development of a new notion of duality for\nrank-metric codes."}
{"id": "2510.04078", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04078", "abs": "https://arxiv.org/abs/2510.04078", "authors": ["Han Hu", "Wei Minn", "Yonghui Liu", "Jiakun Liu", "Ferdian Thung", "Terry Yue Zhuo", "Lwin Khin Shar", "Debin Gao", "David Lo"], "title": "Bamboo: LLM-Driven Discovery of API-Permission Mappings in the Android Framework", "comment": null, "summary": "The permission mechanism in the Android Framework is integral to safeguarding\nthe privacy of users by managing users' and processes' access to sensitive\nresources and operations. As such, developers need to be equipped with an\nin-depth understanding of API permissions to build robust Android apps.\nUnfortunately, the official API documentation by Android chronically suffers\nfrom imprecision and incompleteness, causing developers to spend significant\neffort to accurately discern necessary permissions. This potentially leads to\nincorrect permission declarations in Android app development, potentially\nresulting in security violations and app failures. Recent efforts in improving\npermission specification primarily leverage static and dynamic code analyses to\nuncover API-permission mappings within the Android framework. Yet, these\nmethodologies encounter substantial shortcomings, including poor adaptability\nto Android SDK and Framework updates, restricted code coverage, and a\npropensity to overlook essential API-permission mappings in intricate\ncodebases. This paper introduces a pioneering approach utilizing large language\nmodels (LLMs) for a systematic examination of API-permission mappings. In\naddition to employing LLMs, we integrate a dual-role prompting strategy and an\nAPI-driven code generation approach into our mapping discovery pipeline,\nresulting in the development of the corresponding tool, \\tool{}. We formulate\nthree research questions to evaluate the efficacy of \\tool{} against\nstate-of-the-art baselines, assess the completeness of official SDK\ndocumentation, and analyze the evolution of permission-required APIs across\ndifferent SDK releases. Our experimental results reveal that \\tool{} identifies\n2,234, 3,552, and 4,576 API-permission mappings in Android versions 6, 7, and\n10 respectively, substantially outprforming existing baselines."}
{"id": "2510.03761", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.03761", "abs": "https://arxiv.org/abs/2510.03761", "authors": ["Richard A. Dubniczky", "Bertalan Borsos", "Tihanyi Norbert"], "title": "You Have Been LaTeXpOsEd: A Systematic Analysis of Information Leakage in Preprint Archives Using Large Language Models", "comment": null, "summary": "The widespread use of preprint repositories such as arXiv has accelerated the\ncommunication of scientific results but also introduced overlooked security\nrisks. Beyond PDFs, these platforms provide unrestricted access to original\nsource materials, including LaTeX sources, auxiliary code, figures, and\nembedded comments. In the absence of sanitization, submissions may disclose\nsensitive information that adversaries can harvest using open-source\nintelligence. In this work, we present the first large-scale security audit of\npreprint archives, analyzing more than 1.2 TB of source data from 100,000 arXiv\nsubmissions. We introduce LaTeXpOsEd, a four-stage framework that integrates\npattern matching, logical filtering, traditional harvesting techniques, and\nlarge language models (LLMs) to uncover hidden disclosures within\nnon-referenced files and LaTeX comments. To evaluate LLMs' secret-detection\ncapabilities, we introduce LLMSec-DB, a benchmark on which we tested 25\nstate-of-the-art models. Our analysis uncovered thousands of PII leaks,\nGPS-tagged EXIF files, publicly available Google Drive and Dropbox folders,\neditable private SharePoint links, exposed GitHub and Google credentials, and\ncloud API keys. We also uncovered confidential author communications, internal\ndisagreements, and conference submission credentials, exposing information that\nposes serious reputational risks to both researchers and institutions. We urge\nthe research community and repository operators to take immediate action to\nclose these hidden security gaps. To support open science, we release all\nscripts and methods from this study but withhold sensitive findings that could\nbe misused, in line with ethical principles. The source code and related\nmaterial are available at the project website https://github.com/LaTeXpOsEd"}
{"id": "2510.04135", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.04135", "abs": "https://arxiv.org/abs/2510.04135", "authors": ["Jingzhi Gong", "Yixin Bian", "Luis de la Cal", "Giovanni Pinna", "Anisha Uteem", "David Williams", "Mar Zamorano", "Karine Even-Mendoza", "W. B. Langdon", "Hector Menendez", "Federica Sarro"], "title": "GA4GC: Greener Agent for Greener Code via Multi-Objective Configuration Optimization", "comment": "Accepted by SSBSE'25 Challenge Track", "summary": "Coding agents powered by LLMs face critical sustainability and scalability\nchallenges in industrial deployment, with single runs consuming over 100k\ntokens and incurring environmental costs that may exceed optimization benefits.\nThis paper introduces GA4GC, the first framework to systematically optimize\ncoding agent runtime (greener agent) and code performance (greener code)\ntrade-offs by discovering Pareto-optimal agent hyperparameters and prompt\ntemplates. Evaluation on the SWE-Perf benchmark demonstrates up to 135x\nhypervolume improvement, reducing agent runtime by 37.7% while improving\ncorrectness. Our findings establish temperature as the most critical\nhyperparameter, and provide actionable strategies to balance agent\nsustainability with code optimization effectiveness in industrial deployment."}
{"id": "2510.03770", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03770", "abs": "https://arxiv.org/abs/2510.03770", "authors": ["David Megias"], "title": "Complex Domain Approach for Reversible Data Hiding and Homomorphic Encryption: General Framework and Application to Dispersed Data", "comment": null, "summary": "Ensuring the trustworthiness of data from distributed and\nresource-constrained environments, such as Wireless Sensor Networks or IoT\ndevices, is critical. Existing Reversible Data Hiding (RDH) methods for scalar\ndata suffer from low embedding capacity and poor intrinsic mixing between host\ndata and watermark. This paper introduces Hiding in the Imaginary Domain with\nData Encryption (H[i]dden), a novel framework based on complex number\narithmetic for simultaneous information embedding and encryption. The H[i]dden\nframework offers perfect reversibility, in-principle unlimited watermark size,\nand intrinsic data-watermark mixing. The paper further introduces two\nprotocols: H[i]dden-EG, for joint reversible data hiding and encryption, and\nH[i]dden-AggP, for privacy-preserving aggregation of watermarked data, based on\npartially homomorphic encryption. These protocols provide efficient and\nresilient solutions for data integrity, provenance and confidentiality, serving\nas a foundation for new schemes based on the algebraic properties of the\ncomplex domain."}
{"id": "2510.04143", "categories": ["cs.SE", "D.2.13"], "pdf": "https://arxiv.org/pdf/2510.04143", "abs": "https://arxiv.org/abs/2510.04143", "authors": ["Konstantinos Kitsios", "Francesco Sovrano", "Earl T. Barr", "Alberto Bacchelli"], "title": "Detecting Semantic Clones of Unseen Functionality", "comment": "13 pages, 3 figures, accepted for publication (to appear) in the 40th\n  IEEE/ACM International Conference on Automated Software Engineering, ASE 2025", "summary": "Semantic code clone detection is the task of detecting whether two snippets\nof code implement the same functionality (e.g., Sort Array). Recently, many\nneural models achieved near-perfect performance on this task. These models seek\nto make inferences based on their training data. Consequently, they better\ndetect clones similar to those they have seen during training and may struggle\nto detect those they have not. Developers seeking clones are, of course,\ninterested in both types of clones. We confirm this claim through a literature\nreview, identifying three practical clone detection tasks in which the model's\ngoal is to detect clones of a functionality even if it was trained on clones of\ndifferent functionalities. In light of this finding, we re-evaluate six\nstate-of-the-art models, including both task-specific models and generative\nLLMs, on the task of detecting clones of unseen functionality. Our experiments\nreveal a drop in F1 of up to 48% (average 31%) for task-specific models. LLMs\nperform on par with task-specific models without explicit training for clone\ndetection, but generalize better to unseen functionalities, where F1 drops up\nto 5% (average 3%) instead. We propose and evaluate the use of contrastive\nlearning to improve the performance of existing models on clones of unseen\nfunctionality. We draw inspiration from the computer vision and natural\nlanguage processing fields where contrastive learning excels at measuring\nsimilarity between two objects, even if they come from classes unseen during\ntraining. We replace the final classifier of the task-specific models with a\ncontrastive classifier, while for the generative LLMs we propose contrastive\nin-context learning, guiding the LLMs to focus on the differences between\nclones and non-clones. The F1 on clones of unseen functionality is improved by\nup to 26% (average 9%) for task-specific models and up to 5% (average 3%) for\nLLMs."}
{"id": "2510.03819", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03819", "abs": "https://arxiv.org/abs/2510.03819", "authors": ["Chunyi Zhang", "Qinghong Wei", "Xiaoqi Li"], "title": "Security Analysis of Ponzi Schemes in Ethereum Smart Contracts", "comment": null, "summary": "The rapid advancement of blockchain technology has precipitated the\nwidespread adoption of Ethereum and smart contracts across a variety of\nsectors. However, this has also given rise to numerous fraudulent activities,\nwith many speculators embedding Ponzi schemes within smart contracts, resulting\nin significant financial losses for investors. Currently, there is a lack of\neffective methods for identifying and analyzing such new types of fraudulent\nactivities. This paper categorizes these scams into four structural types and\nexplores the intrinsic characteristics of Ponzi scheme contract source code\nfrom a program analysis perspective. The Mythril tool is employed to conduct\nstatic and dynamic analyses of representative cases, thereby revealing their\nvulnerabilities and operational mechanisms. Furthermore, this paper employs\nshell scripts and command patterns to conduct batch detection of open-source\nsmart contract code, thereby unveiling the common characteristics of Ponzi\nscheme smart contracts."}
{"id": "2510.04166", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.04166", "abs": "https://arxiv.org/abs/2510.04166", "authors": ["Marco Edoardo Palma", "Pooja Rani", "Harald C. Gall"], "title": "Multi Language Models for On-the-Fly Syntax Highlighting", "comment": null, "summary": "Syntax highlighting is a critical feature in modern software development\nenvironments, enhancing code readability and developer productivity. However,\ndelivering accurate highlighting in real time remains challenging for online\nand web-based development tools due to strict time and memory constraints on\nbackend services. These systems must serve highlights rapidly and frequently,\neven when code is partially valid or invalid. This has led to on-the-fly syntax\nhighlighting, where visual annotations are generated just before content is\nserved, often at high request rates and under incomplete input conditions. To\nmeet these demands efficiently, state-of-the-art models use deep learning to\nlearn the behavior of brute-force syntax highlighting resolvers, tools that are\neasy to implement but too slow for production. Through the Deep Abstraction\nprocess, brute-force strategies are encoded into fast statistical models that\nachieve both high accuracy and low-latency inference. Despite their success,\nsuch models face key challenges: they support only one programming language per\nmodel, require large datasets from slow brute-force generators, and involve\nresource-intensive training. In multi-language environments, this means\nmaintaining multiple independent models, increasing system complexity and\noperational cost. This work addresses these issues by introducing a unified\nmodel capable of highlighting up to six mainstream programming languages,\nreducing deployment complexity by a factor of six and improving performance on\nunseen languages. A novel normalization technique significantly enhances model\ngeneralization, while few-shot learning experiments show that a small number of\noracle samples can replace large datasets, minimizing dependence on brute-force\ngenerators. Combined, these innovations enable efficient, scalable, and\ncost-effective syntax highlighting across diverse programming languages."}
{"id": "2510.03831", "categories": ["cs.CR", "cs.IT", "cs.LG", "eess.SP", "math.IT"], "pdf": "https://arxiv.org/pdf/2510.03831", "abs": "https://arxiv.org/abs/2510.03831", "authors": ["Pedro Ivo da Cruz", "Dimitri Silva", "Tito Spadini", "Ricardo Suyama", "Murilo Bellezoni Loiola"], "title": "Pilot Contamination Attacks Detection with Machine Learning for Multi-User Massive MIMO", "comment": "This version of the article has been accepted for publication, after\n  peer review and is subject to Springer Nature's AM terms of use, but is not\n  the Version of Record and does not reflect post-acceptance improvements, or\n  any corrections. The Version of Record is available online at:\n  https://doi.org/10.1007/s11235-024-01163-0", "summary": "Massive multiple-input multiple-output (MMIMO) is essential to modern\nwireless communication systems, like 5G and 6G, but it is vulnerable to active\neavesdropping attacks. One type of such attack is the pilot contamination\nattack (PCA), where a malicious user copies pilot signals from an authentic\nuser during uplink, intentionally interfering with the base station's (BS)\nchannel estimation accuracy. In this work, we propose to use a Decision Tree\n(DT) algorithm for PCA detection at the BS in a multi-user system. We present a\nmethodology to generate training data for the DT classifier and select the best\nDT according to their depth. Then, we simulate different scenarios that could\nbe encountered in practice and compare the DT to a classical technique based on\nlikelihood ratio testing (LRT) submitted to the same scenarios. The results\nrevealed that a DT with only one level of depth is sufficient to outperform the\nLRT. The DT shows a good performance regarding the probability of detection in\nnoisy scenarios and when the malicious user transmits with low power, in which\ncase the LRT fails to detect the PCA. We also show that the reason for the good\nperformance of the DT is its ability to compute a threshold that separates PCA\ndata from non-PCA data better than the LRT's threshold. Moreover, the DT does\nnot necessitate prior knowledge of noise power or assumptions regarding the\nsignal power of malicious users, prerequisites typically essential for LRT and\nother hypothesis testing methodologies."}
{"id": "2510.04274", "categories": ["cs.SE", "D.2; I.2; J.6; K.3; K.7"], "pdf": "https://arxiv.org/pdf/2510.04274", "abs": "https://arxiv.org/abs/2510.04274", "authors": ["Damjan Fujs", "Damjan VavpotiÄ", "TomaÅ¾ Hovelja", "Marko PoÅ¾enel"], "title": "Selecting Cybersecurity Requirements: Effects of LLM Use and Professional Software Development Experience", "comment": "5 pages, 1 figure, 2 tables, presented at IARIA CYBER 2025", "summary": "This study investigates how access to Large Language Models (LLMs) and\nvarying levels of professional software development experience affect the\nprioritization of cybersecurity requirements for web applications. Twenty-three\npostgraduate students participated in a research study to prioritize security\nrequirements (SRs) using the MoSCoW method and subsequently rated their\nproposed solutions against multiple evaluation criteria. We divided\nparticipants into two groups (one with and the other without access to LLM\nsupport during the task). Results showed no significant differences related to\nLLM use, suggesting that access to LLMs did not noticeably influence how\nparticipants evaluated cybersecurity solutions. However, statistically\nsignificant differences emerged between experience groups for certain criteria,\nsuch as estimated cost to develop a feature, perceived impact on user\nexperience, and risk assessment related to non-implementation of the proposed\nfeature. Participants with more professional experience tended to provide\nhigher ratings for user experience impact and lower risk estimates."}
{"id": "2510.03992", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.03992", "abs": "https://arxiv.org/abs/2510.03992", "authors": ["Jehyeok Yeon", "Isha Chaudhary", "Gagandeep Singh"], "title": "Quantifying Distributional Robustness of Agentic Tool-Selection", "comment": null, "summary": "Large language models (LLMs) are increasingly deployed in agentic systems\nwhere they map user intents to relevant external tools to fulfill a task. A\ncritical step in this process is tool selection, where a retriever first\nsurfaces candidate tools from a larger pool, after which the LLM selects the\nmost appropriate one. This pipeline presents an underexplored attack surface\nwhere errors in selection can lead to severe outcomes like unauthorized data\naccess or denial of service, all without modifying the agent's model or code.\nWhile existing evaluations measure task performance in benign settings, they\noverlook the specific vulnerabilities of the tool selection mechanism under\nadversarial conditions. To address this gap, we introduce ToolCert, the first\nstatistical framework that formally certifies tool selection robustness.\nToolCert models tool selection as a Bernoulli success process and evaluates it\nagainst a strong, adaptive attacker who introduces adversarial tools with\nmisleading metadata, and are iteratively refined based on the agent's previous\nchoices. By sampling these adversarial interactions, ToolCert produces a\nhigh-confidence lower bound on accuracy, formally quantifying the agent's\nworst-case performance. Our evaluation with ToolCert uncovers the severe\nfragility: under attacks injecting deceptive tools or saturating retrieval, the\ncertified accuracy bound drops near zero, an average performance drop of over\n60% compared to non-adversarial settings. For attacks targeting the retrieval\nand selection stages, the certified accuracy bound plummets to less than 20%\nafter just a single round of adversarial adaptation. ToolCert thus reveals\npreviously unexamined security threats inherent to tool selection and provides\na principled method to quantify an agent's robustness to such threats, a\nnecessary step for the safe deployment of agentic systems."}
{"id": "2510.04349", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.04349", "abs": "https://arxiv.org/abs/2510.04349", "authors": ["Dmitry Ustalov", "Egor Bogomolov", "Alexander Bezzubov", "Yaroslav Golubev", "Evgeniy Glukhov", "Georgii Levtsov", "Vladimir Kovalenko"], "title": "Challenge on Optimization of Context Collection for Code Completion", "comment": "7 pages, 3 figures, 5 tables. A report on the Context Collection\n  Workshop co-located with ASE'25", "summary": "The rapid advancement of workflows and methods for software engineering using\nAI emphasizes the need for a systematic evaluation and analysis of their\nability to leverage information from entire projects, particularly in large\ncode bases. In this challenge on optimization of context collection for code\ncompletion, organized by JetBrains in collaboration with Mistral AI as part of\nthe ASE 2025 conference, participants developed efficient mechanisms for\ncollecting context from source code repositories to improve fill-in-the-middle\ncode completions for Python and Kotlin. We constructed a large dataset of\nreal-world code in these two programming languages using permissively licensed\nopen-source projects. The submissions were evaluated based on their ability to\nmaximize completion quality for multiple state-of-the-art neural models using\nthe chrF metric. During the public phase of the competition, nineteen teams\nsubmitted solutions to the Python track and eight teams submitted solutions to\nthe Kotlin track. In the private phase, six teams competed, of which five\nsubmitted papers to the workshop."}
{"id": "2510.03995", "categories": ["cs.CR", "cs.AI", "I.2; E.m"], "pdf": "https://arxiv.org/pdf/2510.03995", "abs": "https://arxiv.org/abs/2510.03995", "authors": ["Nges Brian Njungle", "Eric Jahns", "Milan Stojkov", "Michel A. Kinsy"], "title": "PrivSpike: Employing Homomorphic Encryption for Private Inference of Deep Spiking Neural Networks", "comment": "13 pages, 5 figures", "summary": "Deep learning has become a cornerstone of modern machine learning. It relies\nheavily on vast datasets and significant computational resources for high\nperformance. This data often contains sensitive information, making privacy a\nmajor concern in deep learning. Spiking Neural Networks (SNNs) have emerged as\nan energy-efficient alternative to conventional deep learning approaches.\nNevertheless, SNNs still depend on large volumes of data, inheriting all the\nprivacy challenges of deep learning. Homomorphic encryption addresses this\nchallenge by allowing computations to be performed on encrypted data, ensuring\ndata confidentiality throughout the entire processing pipeline. In this paper,\nwe introduce PRIVSPIKE, a privacy-preserving inference framework for SNNs using\nthe CKKS homomorphic encryption scheme. PRIVSPIKE supports arbitrary depth SNNs\nand introduces two key algorithms for evaluating the Leaky Integrate-and-Fire\nactivation function: (1) a polynomial approximation algorithm designed for\nhigh-performance SNN inference, and (2) a novel scheme-switching algorithm that\noptimizes precision at a higher computational cost. We evaluate PRIVSPIKE on\nMNIST, CIFAR-10, Neuromorphic MNIST, and CIFAR-10 DVS using models from LeNet-5\nand ResNet-19 architectures, achieving encrypted inference accuracies of\n98.10%, 79.3%, 98.1%, and 66.0%, respectively. On a consumer-grade CPU, SNN\nLeNet-5 models achieved inference times of 28 seconds on MNIST and 212 seconds\non Neuromorphic MNIST. For SNN ResNet-19 models, inference took 784 seconds on\nCIFAR-10 and 1846 seconds on CIFAR-10 DVS. These results establish PRIVSPIKE as\na viable and efficient solution for secure SNN inference, bridging the gap\nbetween energy-efficient deep neural networks and strong cryptographic privacy\nguarantees while outperforming prior encrypted SNN solutions."}
{"id": "2510.04363", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.04363", "abs": "https://arxiv.org/abs/2510.04363", "authors": ["Hyunjun Kim", "Sejong Kim"], "title": "MacroBench: A Novel Testbed for Web Automation Scripts via Large Language Models", "comment": "NeurIPS 2025 Workshop on Lock-LLM", "summary": "We introduce MacroBench, a code-first benchmark that evaluates whether LLMs\ncan synthesize reusable browser automation programs from natural language goals\nby reading HTML/DOM and emitting Python with Selenium. MacroBench instantiates\nseven self-hosted sites: Airbnb-like, TikTok-like, Reddit-like, Instagram-like,\nFacebook-like, Discord-like, and Threads-like, covering 681 tasks across\ninteraction complexity and targeting difficulty. Our end-to-end protocol\nvalidates generated code via static checks, sandboxed execution, and outcome\nverification including DOM assertions and database snapshots, and includes a\nsafety suite for scraping, spam/abuse, and credential/privacy prompts. Across\n2636 model-task runs, we observe stratified success: GPT-4o-Mini achieves 96.8\npercent, GPT-4.1 achieves 95.3 percent, Gemini-2.5-Pro achieves 89.0 percent,\nand DeepSeek-V3.1 achieves 83.4 percent. Models handle simple tasks reliably at\n91.7 percent but fail on complex workflows at 0.0 percent, and none meet\nproduction-quality coding practices despite functional completion. We release\nour complete benchmark pipeline, evaluation framework, and experimental results\nto enable reproducible assessment of macro synthesis for web automation."}
{"id": "2510.03996", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03996", "abs": "https://arxiv.org/abs/2510.03996", "authors": ["Nges Brian Njungle", "Eric Jahns", "Michel A. Kinsy"], "title": "FHEON: A Configurable Framework for Developing Privacy-Preserving Neural Networks Using Homomorphic Encryption", "comment": "14 pages, 6 figures", "summary": "The widespread adoption of Machine Learning as a Service raises critical\nprivacy and security concerns, particularly about data confidentiality and\ntrust in both cloud providers and the machine learning models. Homomorphic\nEncryption (HE) has emerged as a promising solution to this problems, allowing\ncomputations on encrypted data without decryption. Despite its potential,\nexisting approaches to integrate HE into neural networks are often limited to\nspecific architectures, leaving a wide gap in providing a framework for easy\ndevelopment of HE-friendly privacy-preserving neural network models similar to\nwhat we have in the broader field of machine learning. In this paper, we\npresent FHEON, a configurable framework for developing privacy-preserving\nconvolutional neural network (CNN) models for inference using HE. FHEON\nintroduces optimized and configurable implementations of privacy-preserving CNN\nlayers including convolutional layers, average pooling layers, ReLU activation\nfunctions, and fully connected layers. These layers are configured using\nparameters like input channels, output channels, kernel size, stride, and\npadding to support arbitrary CNN architectures. We assess the performance of\nFHEON using several CNN architectures, including LeNet-5, VGG-11, VGG- 16,\nResNet-20, and ResNet-34. FHEON maintains encrypted-domain accuracies within\n+/- 1% of their plaintext counterparts for ResNet-20 and LeNet-5 models.\nNotably, on a consumer-grade CPU, the models build on FHEON achieved 98.5%\naccuracy with a latency of 13 seconds on MNIST using LeNet-5, and 92.2%\naccuracy with a latency of 403 seconds on CIFAR-10 using ResNet-20.\nAdditionally, FHEON operates within a practical memory budget requiring not\nmore than 42.3 GB for VGG-16."}
{"id": "2510.04380", "categories": ["cs.SE", "cs.AI", "cs.HC", "D.2.1; D.2.2; D.2.9; I.2.7"], "pdf": "https://arxiv.org/pdf/2510.04380", "abs": "https://arxiv.org/abs/2510.04380", "authors": ["Mateen Ahmed Abbasi", "Petri Ihantola", "Tommi Mikkonen", "Niko MÃ¤kitalo"], "title": "Reconsidering Requirements Engineering: Human-AI Collaboration in AI-Native Software Development", "comment": "Accepted at SEAA 2025. Appearing in Springer LNCS 16081, pages\n  164-180", "summary": "Requirement Engineering (RE) is the foundation of successful software\ndevelopment. In RE, the goal is to ensure that implemented systems satisfy\nstakeholder needs through rigorous requirements elicitation, validation, and\nevaluation processes. Despite its critical role, RE continues to face\npersistent challenges, such as ambiguity, conflicting stakeholder needs, and\nthe complexity of managing evolving requirements. A common view is that\nArtificial Intelligence (AI) has the potential to streamline the RE process,\nresulting in improved efficiency, accuracy, and management actions. However,\nusing AI also introduces new concerns, such as ethical issues, biases, and lack\nof transparency. This paper explores how AI can enhance traditional RE\npractices by automating labor-intensive tasks, supporting requirement\nprioritization, and facilitating collaboration between stakeholders and AI\nsystems. The paper also describes the opportunities and challenges that AI\nbrings to RE. In particular, the vision calls for ethical practices in AI,\nalong with a much-enhanced collaboration between academia and industry\nprofessionals. The focus should be on creating not only powerful but also\ntrustworthy and practical AI solutions ready to adapt to the fast-paced world\nof software development."}
{"id": "2510.04056", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.04056", "abs": "https://arxiv.org/abs/2510.04056", "authors": ["Rijha Safdar", "Danyail Mateen", "Syed Taha Ali", "Wajahat Hussain"], "title": "Real-VulLLM: An LLM Based Assessment Framework in the Wild", "comment": null, "summary": "Artificial Intelligence (AI) and more specifically Large Language Models\n(LLMs) have demonstrated exceptional progress in multiple areas including\nsoftware engineering, however, their capability for vulnerability detection in\nthe wild scenario and its corresponding reasoning remains underexplored.\nPrompting pre-trained LLMs in an effective way offers a computationally\neffective and scalable solution. Our contributions are (i)varied prompt designs\nfor vulnerability detection and its corresponding reasoning in the wild. (ii)a\nreal-world vector data store constructed from the National Vulnerability\nDatabase, that will provide real time context to vulnerability detection\nframework, and (iii)a scoring measure for combined measurement of accuracy and\nreasoning quality. Our contribution aims to examine whether LLMs are ready for\nwild deployment, thus enabling the reliable use of LLMs stronger for the\ndevelopment of secure software's."}
{"id": "2510.04437", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04437", "abs": "https://arxiv.org/abs/2510.04437", "authors": ["Fangzhe Wu", "Dongyang Lyu", "Xiaoqi Li"], "title": "Smart Hiring Redefined: An Intelligent Recruitment Management Platform", "comment": null, "summary": "Against the backdrop of deepening digital and intelligent transformation in\nhuman resource management, traditional recruitment models struggle to fully\nmeet enterprises' growing demand for precise talent acquisition due to limited\nefficiency, high costs, and information asymmetry. As a vital tool for\noptimizing recruitment processes, reducing labor and time costs, and enhancing\ncore competitiveness, intelligent recruitment management systems become an\nindispensable component of modern organizational talent strategies.Compared\nwith the labor intensive tasks of resume screening, candidate position\nmatching, and interview coordination in traditional manual recruitment,\nintelligent recruitment systems significantly enhance the efficiency and\naccuracy of the hiring process through automation and data driven approaches.\nThese systems enable rapid parsing of massive resume volumes, intelligent\nmatching of candidates to positions, and automated scheduling of interview\nprocesses."}
{"id": "2510.04085", "categories": ["cs.CR", "quant-ph"], "pdf": "https://arxiv.org/pdf/2510.04085", "abs": "https://arxiv.org/abs/2510.04085", "authors": ["Prabhanjan Ananth", "John Bostanci", "Aditya Gulati", "Yao-Ting Lin"], "title": "Gluing Random Unitaries with Inverses and Applications to Strong Pseudorandom Unitaries", "comment": "55 pages. A preliminary version, merging this paper and\n  arXiv:2509.24432, appears in the proceedings of the 45th Annual International\n  Cryptology Conference (CRYPTO 2025) under the title \"Pseudorandom Unitaries\n  in the Haar Random Oracle Model\". This is Part II of the full version", "summary": "Gluing theorem for random unitaries [Schuster, Haferkamp, Huang, QIP 2025]\nhave found numerous applications, including designing low depth random\nunitaries [Schuster, Haferkamp, Huang, QIP 2025], random unitaries in ${\\sf\nQAC0}$ [Foxman, Parham, Vasconcelos, Yuen'25] and generically shortening the\nkey length of pseudorandom unitaries [Ananth, Bostanci, Gulati, Lin\nEUROCRYPT'25]. We present an alternate method of combining Haar random\nunitaries from the gluing lemma from [Schuster, Haferkamp, Huang, QIP 2025]\nthat is secure against adversaries with inverse query access to the joined\nunitary. As a consequence, we show for the first time that strong pseudorandom\nunitaries can generically have their length extended, and can be constructed\nusing only $O(n^{1/c})$ bits of randomness, for any constant $c$, if any family\nof strong pseudorandom unitaries exists."}
{"id": "2510.04468", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04468", "abs": "https://arxiv.org/abs/2510.04468", "authors": ["Asif Mohammed Samir", "Mohammad Masudur Rahman"], "title": "Improving IR-based Bug Localization with Semantics-Driven Query Reduction", "comment": "56 pages, 16 figures, 11 tables", "summary": "Despite decades of research, software bug localization remains challenging\ndue to heterogeneous content and inherent ambiguities in bug reports. Existing\nmethods such as Information Retrieval (IR)-based approaches often attempt to\nmatch source documents to bug reports, overlooking the context and semantics of\nthe source code. On the other hand, Large Language Models (LLM) (e.g.,\nTransformer models) show promising results in understanding both texts and\ncode. However, they have not been yet adapted well to localize software bugs\nagainst bug reports. They could be also data or resource-intensive. To bridge\nthis gap, we propose, IQLoc, a novel bug localization approach that capitalizes\non the strengths of both IR and LLM-based approaches. In particular, we\nleverage the program semantics understanding of transformer-based models to\nreason about the suspiciousness of code and reformulate queries during bug\nlocalization using Information Retrieval. To evaluate IQLoc, we refine the\nBench4BL benchmark dataset and extend it by incorporating ~30% more recent bug\nreports, resulting in a benchmark containing ~7.5K bug reports. We evaluated\nIQLoc using three performance metrics and compare it against four baseline\ntechniques. Experimental results demonstrate its superiority, achieving up to\n58.52% and 60.59% in MAP, 61.49% and 64.58% in MRR, and 69.88% and 100.90% in\nHIT@K for the test bug reports with random and time-wise splits, respectively.\nMoreover, IQLoc improves MAP by 91.67% for bug reports with stack traces,\n72.73% for those that include code elements, and 65.38% for those containing\nonly descriptions in natural language. By integrating program semantic\nunderstanding into Information Retrieval, IQLoc mitigates several longstanding\nchallenges of traditional IR-based approaches in bug localization."}
{"id": "2510.04118", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.04118", "abs": "https://arxiv.org/abs/2510.04118", "authors": ["Prakhar Paliwal", "Atul Kabra", "Manjesh Kumar Hanawal"], "title": "Cyber Warfare During Operation Sindoor: Malware Campaign Analysis and Detection Framework", "comment": "Accepted for presentation at the 21st International Conference on\n  Information Systems Security (ICISS 2025)", "summary": "Rapid digitization of critical infrastructure has made cyberwarfare one of\nthe important dimensions of modern conflicts. Attacking the critical\ninfrastructure is an attractive pre-emptive proposition for adversaries as it\ncan be done remotely without crossing borders. Such attacks disturb the support\nsystems of the opponents to launch any offensive activities, crippling their\nfighting capabilities. Cyberattacks during cyberwarfare can not only be used to\nsteal information, but also to spread disinformation to bring down the morale\nof the opponents. Recent wars in Europe, Africa, and Asia have demonstrated the\nscale and sophistication that the warring nations have deployed to take the\nearly upper hand. In this work, we focus on the military action launched by\nIndia, code-named Operation Sindoor, to dismantle terror infrastructure\nemanating from Pakistan and the cyberattacks launched by Pakistan. In\nparticular, we study the malware used by Pakistan APT groups to deploy Remote\nAccess Trojans in Indian systems. We provide details of the tactics and\ntechniques used in the RAT deployment and develop a telemetry framework to\ncollect necessary event logs using Osquery with a custom extension. Finally, we\ndevelop a detection rule that can be readily deployed to detect the presence of\nthe RAT or any exploitation performed by the malware."}
{"id": "2510.04469", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04469", "abs": "https://arxiv.org/abs/2510.04469", "authors": ["Wenqi Yan", "Toby Murray", "Benjamin Rubinstein", "Van-Thuan Pham"], "title": "DynamiQ: Unlocking the Potential of Dynamic Task Allocation in Parallel Fuzzing", "comment": null, "summary": "We present DynamiQ, a full-fledged and optimized successor to AFLTeam that\nsupports dynamic and adaptive parallel fuzzing. Unlike most existing approaches\nthat treat individual seeds as tasks, DynamiQ leverages structural information\nfrom the program's call graph to define tasks and continuously refines task\nallocation using runtime feedback. This design significantly reduces redundant\nexploration and enhances fuzzing efficiency at scale. Built on top of the\nstate-of-the-art LibAFL framework, DynamiQ incorporates several practical\noptimizations in both task allocation and task-aware fuzzing. Evaluated on 12\nreal-world targets from OSS-Fuzz and FuzzBench over 25,000 CPU hours, DynamiQ\noutperforms state-of-the-art parallel fuzzers in both code coverage and\nvulnerability discovery, uncovering 9 previously unknown bugs in widely used\nand extensively fuzzed open-source software."}
{"id": "2510.04153", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.04153", "abs": "https://arxiv.org/abs/2510.04153", "authors": ["Haoqi Wu", "Wei Dai", "Ming Xu", "Li Wang", "Qiang Yan"], "title": "ObCLIP: Oblivious CLoud-Device Hybrid Image Generation with Privacy Preservation", "comment": "Accepted by NeurIPS 2025", "summary": "Diffusion Models have gained significant popularity due to their remarkable\ncapabilities in image generation, albeit at the cost of intensive computation\nrequirement. Meanwhile, despite their widespread deployment in inference\nservices such as Midjourney, concerns about the potential leakage of sensitive\ninformation in uploaded user prompts have arisen. Existing solutions either\nlack rigorous privacy guarantees or fail to strike an effective balance between\nutility and efficiency. To bridge this gap, we propose ObCLIP, a plug-and-play\nsafeguard that enables oblivious cloud-device hybrid generation. By oblivious,\neach input prompt is transformed into a set of semantically similar candidate\nprompts that differ only in sensitive attributes (e.g., gender, ethnicity). The\ncloud server processes all candidate prompts without knowing which one is the\nreal one, thus preventing any prompt leakage. To mitigate server cost, only a\nsmall portion of denoising steps is performed upon the large cloud model. The\nintermediate latents are then sent back to the client, which selects the\ntargeted latent and completes the remaining denoising using a small device\nmodel. Additionally, we analyze and incorporate several cache-based\naccelerations that leverage temporal and batch redundancy, effectively reducing\ncomputation cost with minimal utility degradation. Extensive experiments across\nmultiple datasets demonstrate that ObCLIP provides rigorous privacy and\ncomparable utility to cloud models with slightly increased server cost."}
{"id": "2510.04495", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04495", "abs": "https://arxiv.org/abs/2510.04495", "authors": ["Napasorn Tevarut", "Brittany Reid", "Yutaro Kashiwa", "Pattara Leelaprute", "Arnon Rungsawang", "Bundit Manaskasemsak", "Hajimu Iida"], "title": "Detecting and Characterizing Low and No Functionality Packages in the NPM Ecosystem", "comment": "Accepted in PROFES 2025", "summary": "Trivial packages, small modules with low functionality, are common in the npm\necosystem and can pose security risks despite their simplicity. This paper\nrefines existing definitions and introduce data-only packages that contain no\nexecutable logic. A rule-based static analysis method is developed to detect\ntrivial and data-only packages and evaluate their prevalence and associated\nrisks in the 2025 npm ecosystem. The analysis shows that 17.92% of packages are\ntrivial, with vulnerability levels comparable to non-trivial ones, and\ndata-only packages, though rare, also contain risks. The proposed detection\ntool achieves 94% accuracy (macro-F1 0.87), enabling effective large-scale\nanalysis to reduce security exposure. This findings suggest that trivial and\ndata-only packages warrant greater attention in dependency management to reduce\npotential technical debt and security exposure."}
{"id": "2510.04257", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.04257", "abs": "https://arxiv.org/abs/2510.04257", "authors": ["Yanjie Li", "Yiming Cao", "Dong Wang", "Bin Xiao"], "title": "AgentTypo: Adaptive Typographic Prompt Injection Attacks against Black-box Multimodal Agents", "comment": "13 pages, 8 figures. Submitted to IEEE Transactions on Information\n  Forensics & Security", "summary": "Multimodal agents built on large vision-language models (LVLMs) are\nincreasingly deployed in open-world settings but remain highly vulnerable to\nprompt injection, especially through visual inputs. We introduce AgentTypo, a\nblack-box red-teaming framework that mounts adaptive typographic prompt\ninjection by embedding optimized text into webpage images. Our automatic\ntypographic prompt injection (ATPI) algorithm maximizes prompt reconstruction\nby substituting captioners while minimizing human detectability via a stealth\nloss, with a Tree-structured Parzen Estimator guiding black-box optimization\nover text placement, size, and color. To further enhance attack strength, we\ndevelop AgentTypo-pro, a multi-LLM system that iteratively refines injection\nprompts using evaluation feedback and retrieves successful past examples for\ncontinual learning. Effective prompts are abstracted into generalizable\nstrategies and stored in a strategy repository, enabling progressive knowledge\naccumulation and reuse in future attacks. Experiments on the VWA-Adv benchmark\nacross Classifieds, Shopping, and Reddit scenarios show that AgentTypo\nsignificantly outperforms the latest image-based attacks such as AgentAttack.\nOn GPT-4o agents, our image-only attack raises the success rate from 0.23 to\n0.45, with consistent results across GPT-4V, GPT-4o-mini, Gemini 1.5 Pro, and\nClaude 3 Opus. In image+text settings, AgentTypo achieves 0.68 ASR, also\noutperforming the latest baselines. Our findings reveal that AgentTypo poses a\npractical and potent threat to multimodal agents and highlight the urgent need\nfor effective defense."}
{"id": "2510.04519", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04519", "abs": "https://arxiv.org/abs/2510.04519", "authors": ["Heiko Koziolek", "Thilo Braun", "Virendra Ashiwal", "Sofia Linsbauer", "Marthe Ahlgreen Hansen", "Karoline Grotterud"], "title": "Spec2Control: Automating PLC/DCS Control-Logic Engineering from Natural Language Requirements with LLMs - A Multi-Plant Evaluation", "comment": "12 pages, 9 figures", "summary": "Distributed control systems (DCS) manage the automation for many industrial\nproduction processes (e.g., power plants, chemical refineries, steel mills).\nProgramming the software for such systems remains a largely manual and tedious\nprocess, incurring costs of millions of dollars for extensive facilities. Large\nlanguage models (LLMs) have been found helpful in generating DCS control logic,\nresulting in commercial copilot tools. Today, these tools are focused on\ntextual notations, they provide limited automation, and have not been tested on\nlarge datasets with realistic test cases. We introduce Spec2Control, a highly\nautomated LLM workflow to generate graphical control logic directly from\nnatural language user requirements. Experiments using an open dataset with 10\ncontrol narratives and 65 complex test cases demonstrate that Spec2Control can\nsuccessfully identify control strategies, can generate 98.6% of correct control\nstrategy connections autonomously, and can save between 94-96% of human labor.\nSpec2Control is being integrated into commercial ABB engineering tools, but is\nalso available as an open-source variant for independent validation."}
{"id": "2510.04261", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.04261", "abs": "https://arxiv.org/abs/2510.04261", "authors": ["Yu Cui", "Sicheng Pan", "Yifei Liu", "Haibin Zhang", "Cong Zuo"], "title": "VortexPIA: Indirect Prompt Injection Attack against LLMs for Efficient Extraction of User Privacy", "comment": null, "summary": "Large language models (LLMs) have been widely deployed in Conversational AIs\n(CAIs), while exposing privacy and security threats. Recent research shows that\nLLM-based CAIs can be manipulated to extract private information from human\nusers, posing serious security threats. However, the methods proposed in that\nstudy rely on a white-box setting that adversaries can directly modify the\nsystem prompt. This condition is unlikely to hold in real-world deployments.\nThe limitation raises a critical question: can unprivileged attackers still\ninduce such privacy risks in practical LLM-integrated applications? To address\nthis question, we propose \\textsc{VortexPIA}, a novel indirect prompt injection\nattack that induces privacy extraction in LLM-integrated applications under\nblack-box settings. By injecting token-efficient data containing false\nmemories, \\textsc{VortexPIA} misleads LLMs to actively request private\ninformation in batches. Unlike prior methods, \\textsc{VortexPIA} allows\nattackers to flexibly define multiple categories of sensitive data. We evaluate\n\\textsc{VortexPIA} on six LLMs, covering both traditional and reasoning LLMs,\nacross four benchmark datasets. The results show that \\textsc{VortexPIA}\nsignificantly outperforms baselines and achieves state-of-the-art (SOTA)\nperformance. It also demonstrates efficient privacy requests, reduced token\nconsumption, and enhanced robustness against defense mechanisms. We further\nvalidate \\textsc{VortexPIA} on multiple realistic open-source LLM-integrated\napplications, demonstrating its practical effectiveness."}
{"id": "2510.04603", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04603", "abs": "https://arxiv.org/abs/2510.04603", "authors": ["Johan LinÃ¥ker", "Sachiko Muto"], "title": "Advancing Digital Government: Integrating Open Source Software Enablement Indicators in Maturity Indexes", "comment": "In submission", "summary": "Context: Open Source Software (OSS) is a vital public good, included across\nmost of modern software stacks, significantly impacting GDP and national tech\ngrowth, while supporting interoperability, sovereignty, and transparency.\nHowever, systematic measurement of governmental OSS adoption remain limited.\n  Research Aim: This study contributes to digital government maturity indexes\nby analyzing policies and support actions leveraging OSS for software reuse and\ncollaborative development across 16 digitally mature countries, and proposing\npotential indicators for said indexes. It examines OSS policy formation, stated\ngoals, key actors, and support mechanisms.\n  Methodology: A qualitative approach is used combining desk research of policy\ndocuments with semi-structured interviews of government representatives,\nproducing detailed country reports. These are cross-analyzed, focusing on OSS\npolicy promotion, rationale, and implementation support.\n  Results: Policies facilitating OSS reuse are widespread, targeting both\ninbound acquisition and outbound sharing, and are predominantly governed by\ncentral public sector organizations. Policy goals include interoperability,\ndigital sovereignty, transparency, and cost efficiency, with security framed\nboth as a risk and strength. Implementation is supported by diverse Open Source\nProgram Offices (OSPOs) at multiple government levels, which foster capacity\nbuilding, resource pooling, and sustainable project governance. Indicators are\nsynthesized and proposed across 14 areas covering policy incentives and design,\nand implementation and support.\n  Conclusions: OSS is a strategic enabler for public sector digital\ntransformation. Clear policy frameworks, coupled with institutional support\nsuch as OSPOs, are essential. International digital maturity frameworks should\nexpand OSS indicators to better guide and assess government adoption and\nimpact."}
{"id": "2510.04397", "categories": ["cs.CR", "cs.AI", "cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04397", "abs": "https://arxiv.org/abs/2510.04397", "authors": ["Van Nguyen", "Surya Nepal", "Xingliang Yuan", "Tingmin Wu", "Fengchao Chen", "Carsten Rudolph"], "title": "MulVuln: Enhancing Pre-trained LMs with Shared and Language-Specific Knowledge for Multilingual Vulnerability Detection", "comment": null, "summary": "Software vulnerabilities (SVs) pose a critical threat to safety-critical\nsystems, driving the adoption of AI-based approaches such as machine learning\nand deep learning for software vulnerability detection. Despite promising\nresults, most existing methods are limited to a single programming language.\nThis is problematic given the multilingual nature of modern software, which is\noften complex and written in multiple languages. Current approaches often face\nchallenges in capturing both shared and language-specific knowledge of source\ncode, which can limit their performance on diverse programming languages and\nreal-world codebases. To address this gap, we propose MULVULN, a novel\nmultilingual vulnerability detection approach that learns from source code\nacross multiple languages. MULVULN captures both the shared knowledge that\ngeneralizes across languages and the language-specific knowledge that reflects\nunique coding conventions. By integrating these aspects, it achieves more\nrobust and effective detection of vulnerabilities in real-world multilingual\nsoftware systems. The rigorous and extensive experiments on the real-world and\ndiverse REEF dataset, consisting of 4,466 CVEs with 30,987 patches across seven\nprogramming languages, demonstrate the superiority of MULVULN over thirteen\neffective and state-of-the-art baselines. Notably, MULVULN achieves\nsubstantially higher F1-score, with improvements ranging from 1.45% to 23.59%\ncompared to the baseline methods."}
{"id": "2510.04605", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04605", "abs": "https://arxiv.org/abs/2510.04605", "authors": ["Jingyao Zhang", "Tianlin Li", "Xiaoyu Zhang", "Qiang Hu", "Bin Shi"], "title": "Exploring the Power of Diffusion Large Language Models for Software Engineering: An Empirical Investigation", "comment": null, "summary": "Autoregressive Large Language Models (AR-LLMs) are widely used in software\nengineering (SE) but face limitations in processing code structure information\nand suffer from high inference latency. Diffusion LLMs (DLLMs) offer a\npromising alternative with global bidirectional encoding and decoupled\ngeneration steps. This work presents the first comprehensive evaluation of\nDLLMs across the software development lifecycle, including code generation,\ndefect detection, and program repair. On a large-scale benchmark of 52,937\ntasks, 7Bparameter DLLMs outperform AR-LLMs with a 30% average accuracy\nimprovement achieving a 113% gain on cross-file repair, while maintaining\nsuperior efficiency and reduced latency. Our results establish DLLMs as a\nsuperior paradigm for SE tasks."}
{"id": "2510.04503", "categories": ["cs.CR", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.04503", "abs": "https://arxiv.org/abs/2510.04503", "authors": ["Shuai Zhao", "Xinyi Wu", "Shiqian Zhao", "Xiaobao Wu", "Zhongliang Guo", "Yanhao Jia", "Anh Tuan Luu"], "title": "P2P: A Poison-to-Poison Remedy for Reliable Backdoor Defense in LLMs", "comment": null, "summary": "During fine-tuning, large language models (LLMs) are increasingly vulnerable\nto data-poisoning backdoor attacks, which compromise their reliability and\ntrustworthiness. However, existing defense strategies suffer from limited\ngeneralization: they only work on specific attack types or task settings. In\nthis study, we propose Poison-to-Poison (P2P), a general and effective backdoor\ndefense algorithm. P2P injects benign triggers with safe alternative labels\ninto a subset of training samples and fine-tunes the model on this re-poisoned\ndataset by leveraging prompt-based learning. This enforces the model to\nassociate trigger-induced representations with safe outputs, thereby overriding\nthe effects of original malicious triggers. Thanks to this robust and\ngeneralizable trigger-based fine-tuning, P2P is effective across task settings\nand attack types. Theoretically and empirically, we show that P2P can\nneutralize malicious backdoors while preserving task performance. We conduct\nextensive experiments on classification, mathematical reasoning, and summary\ngeneration tasks, involving multiple state-of-the-art LLMs. The results\ndemonstrate that our P2P algorithm significantly reduces the attack success\nrate compared with baseline models. We hope that the P2P can serve as a\nguideline for defending against backdoor attacks and foster the development of\na secure and trustworthy LLM community."}
{"id": "2510.04611", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2510.04611", "abs": "https://arxiv.org/abs/2510.04611", "authors": ["Pawel Weichbroth", "Maciej Lotysz", "Michal Wrobel"], "title": "A survey on the impact of emotions on the productivity among software developers", "comment": "29 pages, 5 tables, 96 references", "summary": "The time pressure associated with software development, among other factors,\noften leads to a diminished emotional state among developers. However, whether\nemotions affect perceived productivity remains an open question. This study\naims to determine the strength and direction of the relationship between\nemotional state and perceived productivity among software developers. We\nemployed a two-stage approach. First, a survey was conducted with a pool of\nnine experts to validate the measurement model. Second, a survey was\nadministered to a pool of 88 software developers to empirically test the\nformulated hypothesis by using Partial Least Squares, as the data analysis\nmethod. The results of the path analysis clearly confirm the formulated\nhypothesis, showing that the emotional state of a software developer has a\nstrong positive, and significant impact (beta = 0.893, p < 0.001) on perceived\nproductivity among software developers. The findings highlight the importance\nof managing and improving developers emotional well-being to enhance\nproductivity in software development environments. Additionally, interventions\naimed at reducing burnout, stress, and other negative factors could have a\nconsiderable impact on their performance outcomes."}
{"id": "2510.04528", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.04528", "abs": "https://arxiv.org/abs/2510.04528", "authors": ["Santhosh KumarRavindran"], "title": "Unified Threat Detection and Mitigation Framework (UTDMF): Combating Prompt Injection, Deception, and Bias in Enterprise-Scale Transformers", "comment": null, "summary": "The rapid adoption of large language models (LLMs) in enterprise systems\nexposes vulnerabilities to prompt injection attacks, strategic deception, and\nbiased outputs, threatening security, trust, and fairness. Extending our\nadversarial activation patching framework (arXiv:2507.09406), which induced\ndeception in toy networks at a 23.9% rate, we introduce the Unified Threat\nDetection and Mitigation Framework (UTDMF), a scalable, real-time pipeline for\nenterprise-grade models like Llama-3.1 (405B), GPT-4o, and Claude-3.5. Through\n700+ experiments per model, UTDMF achieves: (1) 92% detection accuracy for\nprompt injection (e.g., jailbreaking); (2) 65% reduction in deceptive outputs\nvia enhanced patching; and (3) 78% improvement in fairness metrics (e.g.,\ndemographic bias). Novel contributions include a generalized patching algorithm\nfor multi-threat detection, three groundbreaking hypotheses on threat\ninteractions (e.g., threat chaining in enterprise workflows), and a\ndeployment-ready toolkit with APIs for enterprise integration."}
{"id": "2510.04689", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04689", "abs": "https://arxiv.org/abs/2510.04689", "authors": ["Chengwei Liu", "Wenbo Guo", "Yuxin Zhang", "Limin Wang", "Sen Chen", "Lei Bu", "Yang Liu"], "title": "Evolaris: A Roadmap to Self-Evolving Software Intelligence Management", "comment": null, "summary": "In recent years, the landscape of software threats has become significantly\nmore dynamic and distributed. Security vulnerabilities are no longer discovered\nand shared only through formal channels such as public vulnerability databases\nor vendor advisories. Increasingly, criti- cal threat information emerges\ninformally through blogs, social media, developer forums, open source\nrepositories, and even underground com- munities. To this end, capturing such\nintelligence in a timely manner is essential for maintaining situational\nawareness and enabling prompt security responses. However, this remains a\ncomplex challenge due to the fragmented nature of data sources and the\ntechnical difficulty of collecting, parsing, mapping, and validating\ninformation at scale. To ad- dress this, we propose Evolaris, a self-evolving\nsoftware intelligence sys- tem built on a multi-agent framework. Evolaris is\ndesigned to support a full-stack workflow, where agents operate independently\nbut coordinate through shared context to perform tasks such as information\ndiscovery, reasoning, gap completion, validation, and risk detection. This\narchi- tecture enables the platform to learn from new inputs, refine its\ninternal knowledge, and adapt to emerging threat patterns over time, which\ncould continuously improve the precision, timeliness, and scalability of\nsoftware threat analysis, and offers a sustainable foundation for proactive\nsecu- rity decision-making and strengthens the broader ecosystem of security\nthreat understanding."}
{"id": "2510.04529", "categories": ["cs.CR", "quant-ph"], "pdf": "https://arxiv.org/pdf/2510.04529", "abs": "https://arxiv.org/abs/2510.04529", "authors": ["Yuki Takeuchi", "Duo Xu"], "title": "Computational Certified Deletion Property of Magic Square Game and its Application to Classical Secure Key Leasing", "comment": null, "summary": "We present the first construction of a computational Certified Deletion\nProperty (CDP) achievable with classical communication, derived from the\ncompilation of the non-local Magic Square Game (MSG). We leverage the KLVY\ncompiler to transform the non-local MSG into a 2-round interactive protocol,\nrigorously demonstrating that this compilation preserves the game-specific CDP.\nPreviously, the quantum value and rigidity of the compiled game were\ninvestigated. We emphasize that we are the first to investigate CDP (local\nrandomness in [Fu and Miller, Phys. Rev. A 97, 032324 (2018)]) for the compiled\ngame. Then, we combine this CDP with the framework [Kitagawa, Morimae, and\nYamakawa, Eurocrypt 2025] to construct Secure Key Leasing with classical Lessor\n(cSKL). SKL enables the Lessor to lease the secret key to the Lessee and verify\nthat a quantum Lessee has indeed deleted the key. In this paper, we realize\ncSKL for PKE, PRF, and digital signature. Compared to prior works for cSKL, we\nrealize cSKL for PRF and digital signature for the first time. In addition, we\nsucceed in weakening the assumption needed to construct cSKL."}
{"id": "2510.04711", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04711", "abs": "https://arxiv.org/abs/2510.04711", "authors": ["Aoyang Fang", "Songhan Zhang", "Yifan Yang", "Haotong Wu", "Junjielong Xu", "Xuyang Wang", "Rui Wang", "Manyi Wang", "Qisheng Lu", "Pinjia He"], "title": "An Empirical Study of SOTA RCA Models: From Oversimplified Benchmarks to Realistic Failures", "comment": "Our project is available on https://operationspai.github.io/", "summary": "While cloud-native microservice architectures have transformed software\ndevelopment, their complexity makes Root Cause Analysis (RCA) both crucial and\nchallenging. Although many data-driven RCA models have been proposed, we find\nthat existing benchmarks are often oversimplified and fail to capture\nreal-world conditions. Our preliminary study shows that simple rule-based\nmethods can match or even outperform state-of-the-art (SOTA) models on four\nwidely used benchmarks, suggesting performance overestimation due to benchmark\nsimplicity. To address this, we systematically analyze popular RCA benchmarks\nand identify key limitations in fault injection, call graph design, and\ntelemetry patterns. Based on these insights, we develop an automated framework\nto generate more realistic benchmarks, yielding a dataset of 1,430 validated\nfailure cases from 9,152 injections, covering 25 fault types under dynamic\nworkloads with hierarchical ground-truth labels and verified SLI impact.\nRe-evaluation of 11 SOTA models on this dataset shows low Top@1 accuracy\n(average 0.21, best 0.37) and significantly longer execution times. Our\nanalysis highlights three common failure patterns: scalability issues,\nobservability blind spots, and modeling bottlenecks."}
{"id": "2510.04619", "categories": ["cs.CR", "cs.NI"], "pdf": "https://arxiv.org/pdf/2510.04619", "abs": "https://arxiv.org/abs/2510.04619", "authors": ["Ivan Homoliak", "Martin PereÅ¡Ã­ni", "Marek TamaÅ¡koviÄ", "Timotej Ponek", "LukÃ¡Å¡ Hellebrandt", "Kamil Malinka"], "title": "PoS-CoPOR: Proof-of-Stake Consensus Protocol with Native Onion Routing Providing Scalability and DoS-Resistance", "comment": null, "summary": "Proof-of-Stake (PoS) consensus protocols often face a trade-off between\nperformance and security. Protocols that pre-elect leaders for subsequent\nrounds are vulnerable to Denial-of-Service (DoS) attacks, which can disrupt the\nnetwork and compromise liveness. In this work, we present PoS-CoPOR, a\nsingle-chain PoS consensus protocol that mitigates this vulnerability by\nintegrating a native onion routing mechanism into the consensus protocol\nitself. PoS-CoPOR combines stake-weighted probabilistic leader election with an\nanonymization layer that conceals the network identity of the next block\nproposer. This approach prevents targeted DoS attacks on leaders before they\nproduce a block, thus enhancing network resilience. We implemented and\nevaluated PoS-CoPOR, demonstrating its ability to achieve a throughput of up to\n110 tx/s with 6 nodes, even with the overhead of the anonymization layer. The\nresults show that native anonymization can provide robust DoS resistance with\nonly a modest impact on performance, offering a solution to build secure and\nscalable PoS blockchains."}
{"id": "2510.04760", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.04760", "abs": "https://arxiv.org/abs/2510.04760", "authors": ["Sisay Deresa Sima", "Ayalew Belay Habtie"], "title": "Agile Software Effort Estimation using Regression Techniques", "comment": null, "summary": "Software development effort estimation is one of the most critical aspect in\nsoftware development process, as the success or failure of the entire project\ndepends on the accuracy of estimations. Researchers are still conducting\nstudies on agile effort estimation. The aim of this research is to develop a\nstory point based agile effort estimation model using LASSO and Elastic Net\nregression techniques. The experimental work is applied to the agile story\npoint approach using 21 software projects collected from six firms. The two\nalgorithms are trained using their default parameters and tuned grid search\nwith 5-fold cross-validation to get an enhanced model. The experiment result\nshows LASSO regression achieved better predictive performance PRED (8%) and\nPRED (25%) results of 100.0, MMRE of 0.0491, MMER of 0.0551, MdMRE of 0.0593,\nMdMER of 0.063, and MSE of 0.0007. The results are also compared with other\nrelated literature."}
{"id": "2510.04640", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.04640", "abs": "https://arxiv.org/abs/2510.04640", "authors": ["Ali Asghar", "Andreas Becher", "Daniel Ziener"], "title": "Backing the Wrong Horse: How Bit-Level Netlist Augmentation can Counter Power Side Channel Attacks", "comment": "5 pages, 3 figures", "summary": "The dependence of power-consumption on the processed data is a known\nvulnerability of CMOS circuits, resulting in side channels which can be\nexploited by power-based side channel attacks (SCAs). These attacks can extract\nsensitive information, such as secret keys, from the implementation of\ncryptographic algorithms. Existing countermeasures against power-based side\nchannel attacks focus on analyzing information leakage at the byte level.\nHowever, this approach neglects the impact of individual bits on the overall\nresistance of a cryptographic implementation. In this work, we present a\ncountermeasure based on single-bit leakage. The results suggest that the\nproposed countermeasure cannot be broken by attacks using conventional SCA\nleakage models."}
{"id": "2510.04791", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04791", "abs": "https://arxiv.org/abs/2510.04791", "authors": ["Kristian Kolthoff", "Felix Kretzer", "Simone Paolo Ponzetto", "Alexander Maedche", "Christian Bartelt"], "title": "GUISpector: An MLLM Agent Framework for Automated Verification of Natural Language Requirements in GUI Prototypes", "comment": null, "summary": "GUIs are foundational to interactive systems and play a pivotal role in early\nrequirements elicitation through prototyping. Ensuring that GUI implementations\nfulfill NL requirements is essential for robust software engineering,\nespecially as LLM-driven programming agents become increasingly integrated into\ndevelopment workflows. Existing GUI testing approaches, whether traditional or\nLLM-driven, often fall short in handling the complexity of modern interfaces,\nand typically lack actionable feedback and effective integration with automated\ndevelopment agents. In this paper, we introduce GUISpector, a novel framework\nthat leverages a multi-modal (M)LLM-based agent for the automated verification\nof NL requirements in GUI prototypes. First, GUISpector adapts a MLLM agent to\ninterpret and operationalize NL requirements, enabling to autonomously plan and\nexecute verification trajectories across GUI applications. Second, GUISpector\nsystematically extracts detailed NL feedback from the agent's verification\nprocess, providing developers with actionable insights that can be used to\niteratively refine the GUI artifact or directly inform LLM-based code\ngeneration in a closed feedback loop. Third, we present an integrated tool that\nunifies these capabilities, offering practitioners an accessible interface for\nsupervising verification runs, inspecting agent rationales and managing the\nend-to-end requirements verification process. We evaluated GUISpector on a\ncomprehensive set of 150 requirements based on 900 acceptance criteria\nannotations across diverse GUI applications, demonstrating effective detection\nof requirement satisfaction and violations and highlighting its potential for\nseamless integration of actionable feedback into automated LLM-driven\ndevelopment workflows. The video presentation of GUISpector is available at:\nhttps://youtu.be/JByYF6BNQeE, showcasing its main capabilities."}
{"id": "2510.04652", "categories": ["cs.CR", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2510.04652", "abs": "https://arxiv.org/abs/2510.04652", "authors": ["Ines Akaichi", "Giorgos Flouris", "Irini Fundulaki", "Sabrina Kirrane"], "title": "Modeling and Managing Temporal Obligations in GUCON Using SPARQL-star and RDF-star", "comment": null, "summary": "In the digital age, data frequently crosses organizational and jurisdictional\nboundaries, making effective governance essential. Usage control policies have\nemerged as a key paradigm for regulating data usage, safeguarding privacy,\nprotecting intellectual property, and ensuring compliance with regulations. A\ncentral mechanism for usage control is the handling of obligations, which arise\nas a side effect of using and sharing data. Effective monitoring of obligations\nrequires capturing usage traces and accounting for temporal aspects such as\nstart times and deadlines, as obligations may evolve over times into different\nstates, such as fulfilled, violated, or expired. While several solutions have\nbeen proposed for obligation monitoring, they often lack formal semantics or\nprovide limited support for reasoning over obligation states. To address these\nlimitations, we extend GUCON, a policy framework grounded in the formal\nsemantics of SPAQRL graph patterns, to explicitly model the temporal aspects of\nan obligation. This extension enables the expressing of temporal obligations\nand supports continuous monitoring of their evolving states based on usage\ntraces stored in temporal knowledge graphs. We demonstrate how this extended\nmodel can be represented using RDF-star and SPARQL-star and propose an\nObligation State Manager that monitors obligation states and assess their\ncompliance with respect to usage traces. Finally, we evaluate both the extended\nmodel and its prototype implementation."}
{"id": "2510.04796", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04796", "abs": "https://arxiv.org/abs/2510.04796", "authors": ["Samah Kansab", "Francis Bordeleau", "Ali Tizghadam"], "title": "RevMine: An LLM-Assisted Tool for Code Review Mining and Analysis Across Git Platforms", "comment": null, "summary": "Empirical research on code review processes is increasingly central to\nunderstanding software quality and collaboration. However, collecting and\nanalyzing review data remains a time-consuming and technically intensive task.\nMost researchers follow similar workflows - writing ad hoc scripts to extract,\nfilter, and analyze review data from platforms like GitHub and GitLab. This\npaper introduces RevMine, a conceptual tool that streamlines the entire code\nreview mining pipeline using large language models (LLMs). RevMine guides users\nthrough authentication, endpoint discovery, and natural language-driven data\ncollection, significantly reducing the need for manual scripting. After\nretrieving review data, it supports both quantitative and qualitative analysis\nbased on user-defined filters or LLM-inferred patterns. This poster outlines\nthe tool's architecture, use cases, and research potential. By lowering the\nbarrier to entry, RevMine aims to democratize code review mining and enable a\nbroader range of empirical software engineering studies."}
{"id": "2510.04882", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.04882", "abs": "https://arxiv.org/abs/2510.04882", "authors": ["Elian Morel"], "title": "Enhancing TreePIR for a Single-Server Setting via Resampling", "comment": null, "summary": "Private Information Retrieval (PIR) allows a client to retrieve an entry\n$\\text{DB}[i]$ from a public database $\\text{DB}$ held by one or more servers,\nwithout revealing the queried index $i$. Traditional PIR schemes achieve\nsublinear server computation only under strong assumptions, such as the\npresence of multiple non-colluding servers or the use of public-key\ncryptography. To overcome these limitations, \\textit{preprocessing PIR} schemes\nintroduce a query-independent offline phase where the client collects\n\\textit{hints} that enable efficient private queries during the online phase.\n  In this work, we focus on preprocessing PIR schemes relying solely on\n\\textit{One-Way Functions} (OWFs), which provide minimal cryptographic\nassumptions and practical implementability. We study three main constructions\n-- TreePIR, PIANO, and PPPS -- that explore different trade-offs between\ncommunication, storage, and server trust assumptions. Building upon the\nmechanisms introduced in PIANO and PPPS, we propose an adaptation of TreePIR to\nthe single-server setting by introducing a dual-table hint structure (primary\nand backup tables) and a \\textit{resampling} technique to refresh hints\nefficiently.\n  Our proposed scheme achieves logarithmic upload bandwidth and $O(\\sqrt{n}\\log\nn)$ download complexity while requiring $O(\\sqrt{n}\\log n)$ client storage.\nThis represents a significant improvement over prior single-server\npreprocessing PIR schemes such as PIANO ($O(\\sqrt{n})$ bandwidth) and PPPS\n($O(n^{1/4})$ bandwidth), while maintaining the simplicity and minimal\nassumptions of the OWF-based setting."}
{"id": "2510.04835", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04835", "abs": "https://arxiv.org/abs/2510.04835", "authors": ["Wentao Gao", "Renata Borovica-Gajic", "Sang Kil Cha", "Tian Qiu", "Van-Thuan Pham"], "title": "InsightQL: Advancing Human-Assisted Fuzzing with a Unified Code Database and Parameterized Query Interface", "comment": null, "summary": "Fuzzing is a highly effective automated testing method for uncovering\nsoftware vulnerabilities. Despite advances in fuzzing techniques, such as\ncoverage-guided greybox fuzzing, many fuzzers struggle with coverage plateaus\ncaused by fuzz blockers, limiting their ability to find deeper vulnerabilities.\nHuman expertise can address these challenges, but analyzing fuzzing results to\nguide this support remains labor-intensive. To tackle this, we introduce\nInsightQL, the first human-assisting framework for fuzz blocker analysis.\nPowered by a unified database and an intuitive parameterized query interface,\nInsightQL aids developers in systematically extracting insights and efficiently\nunblocking fuzz blockers. Our experiments on 14 popular real-world libraries\nfrom the FuzzBench benchmark demonstrate the effectiveness of InsightQL,\nleading to the unblocking of many fuzz blockers and considerable improvements\nin code coverage (up to 13.90%)."}
{"id": "2510.04885", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.04885", "abs": "https://arxiv.org/abs/2510.04885", "authors": ["Yuxin Wen", "Arman Zharmagambetov", "Ivan Evtimov", "Narine Kokhlikyan", "Tom Goldstein", "Kamalika Chaudhuri", "Chuan Guo"], "title": "RL Is a Hammer and LLMs Are Nails: A Simple Reinforcement Learning Recipe for Strong Prompt Injection", "comment": null, "summary": "Prompt injection poses a serious threat to the reliability and safety of LLM\nagents. Recent defenses against prompt injection, such as Instruction Hierarchy\nand SecAlign, have shown notable robustness against static attacks. However, to\nmore thoroughly evaluate the robustness of these defenses, it is arguably\nnecessary to employ strong attacks such as automated red-teaming. To this end,\nwe introduce RL-Hammer, a simple recipe for training attacker models that\nautomatically learn to perform strong prompt injections and jailbreaks via\nreinforcement learning. RL-Hammer requires no warm-up data and can be trained\nentirely from scratch. To achieve high ASRs against industrial-level models\nwith defenses, we propose a set of practical techniques that enable highly\neffective, universal attacks. Using this pipeline, RL-Hammer reaches a 98% ASR\nagainst GPT-4o and a $72\\%$ ASR against GPT-5 with the Instruction Hierarchy\ndefense. We further discuss the challenge of achieving high diversity in\nattacks, highlighting how attacker models tend to reward-hack diversity\nobjectives. Finally, we show that RL-Hammer can evade multiple prompt injection\ndetectors. We hope our work advances automatic red-teaming and motivates the\ndevelopment of stronger, more principled defenses. Code is available at\nhttps://github.com/facebookresearch/rl-injector."}
{"id": "2510.04852", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.04852", "abs": "https://arxiv.org/abs/2510.04852", "authors": ["Victor May", "Diganta Misra", "Yanqi Luo", "Anjali Sridhar", "Justine Gehring", "Silvio Soares Ribeiro Junior"], "title": "FreshBrew: A Benchmark for Evaluating AI Agents on Java Code Migration", "comment": "18 pages, 11 figures", "summary": "AI coding assistants are rapidly becoming integral to modern software\ndevelopment. A key challenge in this space is the continual need to migrate and\nmodernize codebases in response to evolving software ecosystems. Traditionally,\nsuch migrations have relied on rule-based systems and human intervention. With\nthe advent of powerful large language models (LLMs), AI-driven agentic\nframeworks offer a promising alternative-but their effectiveness has not been\nsystematically evaluated. In this paper, we introduce FreshBrew, a novel\nbenchmark for evaluating AI agents on project-level Java migrations, with a\nspecific focus on measuring an agent's ability to preserve program semantics\nand avoid reward hacking, which we argue requires projects with high test\ncoverage for a rigorous and reliable evaluation. We benchmark several\nstate-of-the-art LLMs, and compare their performance against established\nrule-based tools. Our evaluation of AI agents on this benchmark of 228\nrepositories shows that the top-performing model, Gemini 2.5 Flash, can\nsuccessfully migrate 52.3 percent of projects to JDK 17. Our empirical analysis\nreveals novel insights into the critical strengths and limitations of current\nagentic approaches, offering actionable insights into their real-world\napplicability. Our empirical study reveals failure modes of current AI agents\nin realistic Java modernization tasks, providing a foundation for evaluating\ntrustworthy code-migration systems. By releasing FreshBrew, we aim to\nfacilitate rigorous, reproducible evaluation and catalyze progress in AI-driven\ncodebase modernization."}
{"id": "2510.04987", "categories": ["cs.CR", "I.2"], "pdf": "https://arxiv.org/pdf/2510.04987", "abs": "https://arxiv.org/abs/2510.04987", "authors": ["Avilash Rath", "Weiliang Qi", "Youpeng Li", "Xinda Wang"], "title": "NatGVD: Natural Adversarial Example Attack towards Graph-based Vulnerability Detection", "comment": "10 pages, 2 figures (2 additional figures in Appendices)", "summary": "Graph-based models learn rich code graph structural information and present\nsuperior performance on various code analysis tasks. However, the robustness of\nthese models against adversarial example attacks in the context of\nvulnerability detection remains an open question. This paper proposes NatGVD, a\nnovel attack methodology that generates natural adversarial vulnerable code to\ncircumvent GNN-based and graph-aware transformer-based vulnerability detectors.\nNatGVD employs a set of code transformations that modify graph structure while\npreserving code semantics. Instead of injecting dead or unrelated code like\nprevious works, NatGVD considers naturalness requirements: generated examples\nshould not be easily recognized by humans or program analysis tools. With\nextensive evaluation of NatGVD on state-of-the-art vulnerability detection\nsystems, the results reveal up to 53.04% evasion rate across GNN-based\ndetectors and graph-aware transformer-based detectors. We also explore\npotential defense strategies to enhance the robustness of these systems against\nNatGVD."}
{"id": "2510.04905", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.04905", "abs": "https://arxiv.org/abs/2510.04905", "authors": ["Yicheng Tao", "Yao Qin", "Yepang Liu"], "title": "Retrieval-Augmented Code Generation: A Survey with Focus on Repository-Level Approaches", "comment": null, "summary": "Recent advancements in large language models (LLMs) have substantially\nimproved automated code generation. While function-level and file-level\ngeneration have achieved promising results, real-world software development\ntypically requires reasoning across entire repositories. This gives rise to the\nchallenging task of Repository-Level Code Generation (RLCG), where models must\ncapture long-range dependencies, ensure global semantic consistency, and\ngenerate coherent code spanning multiple files or modules. To address these\nchallenges, Retrieval-Augmented Generation (RAG) has emerged as a powerful\nparadigm that integrates external retrieval mechanisms with LLMs, enhancing\ncontext-awareness and scalability. In this survey, we provide a comprehensive\nreview of research on Retrieval-Augmented Code Generation (RACG), with an\nemphasis on repository-level approaches. We categorize existing work along\nseveral dimensions, including generation strategies, retrieval modalities,\nmodel architectures, training paradigms, and evaluation protocols. Furthermore,\nwe summarize widely used datasets and benchmarks, analyze current limitations,\nand outline key challenges and opportunities for future research. Our goal is\nto establish a unified analytical framework for understanding this rapidly\nevolving field and to inspire continued progress in AI-powered software\nengineering."}
{"id": "2510.05052", "categories": ["cs.CR", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.05052", "abs": "https://arxiv.org/abs/2510.05052", "authors": ["Weiliang Zhao", "Jinjun Peng", "Daniel Ben-Levi", "Zhou Yu", "Junfeng Yang"], "title": "Proactive defense against LLM Jailbreak", "comment": null, "summary": "The proliferation of powerful large language models (LLMs) has necessitated\nrobust safety alignment, yet these models remain vulnerable to evolving\nadversarial attacks, including multi-turn jailbreaks that iteratively search\nfor successful queries. Current defenses, primarily reactive and static, often\nfail to counter these search-based attacks. In this paper, we introduce ProAct,\na novel proactive defense framework designed to disrupt and mislead autonomous\njailbreaking processes. Our core idea is to intentionally provide adversaries\nwith \"spurious responses\" that appear to be results of successful jailbreak\nattacks but contain no actual harmful content. These misleading responses\nprovide false signals to the attacker's internal optimization loop, causing the\nadversarial search to terminate prematurely and effectively jailbreaking the\njailbreak. By conducting extensive experiments across state-of-the-art LLMs,\njailbreaking frameworks, and safety benchmarks, our method consistently and\nsignificantly reduces attack success rates by up to 92\\%. When combined with\nother defense frameworks, it further reduces the success rate of the latest\nattack strategies to 0\\%. ProAct represents an orthogonal defense strategy that\ncan serve as an additional guardrail to enhance LLM safety against the most\neffective jailbreaking attacks."}
{"id": "2510.04964", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04964", "abs": "https://arxiv.org/abs/2510.04964", "authors": ["Kelechi G. Kalu", "James C. Davis"], "title": "Why Software Signing (Still) Matters: Trust Boundaries in the Software Supply Chain", "comment": "8 Pages, 3 Figures", "summary": "Software signing provides a formal mechanism for provenance by ensuring\nartifact integrity and verifying producer identity. It also imposes tooling and\noperational costs to implement in practice. In an era of centralized registries\nsuch as PyPI, npm, Maven Central, and Hugging Face, it is reasonable to ask\nwhether hardening registry security controls obviates the need for end-to-end\nartifact signing. In this work, we posit that the core guarantees of signing,\nprovenance, integrity, and accountability are not automatically carried across\ndifferent software distribution boundaries. These boundaries include mirrors,\ncorporate proxies, re-hosting, and air-gapped transfers, where registry\nsecurity controls alone cannot provide sufficient assurance. We synthesize\nhistorical practice and present a trust model for modern distribution modes to\nidentify when signing is necessary to extend trust beyond registry control.\nTreating signing as a baseline layer of defense strengthens software supply\nchain assurance even when registries are secure."}
{"id": "2510.03461", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.03461", "abs": "https://arxiv.org/abs/2510.03461", "authors": ["Sanjay Malakar", "Michael D. Ernst", "Martin Kellogg", "Manu Sridharan"], "title": "Repairing Leaks in Resource Wrappers", "comment": null, "summary": "A resource leak occurs when a program fails to release a finite resource like\na socket, file descriptor or database connection. While sound static analysis\ntools can detect all leaks, automatically repairing them remains challenging.\nPrior work took the output of a detection tool and attempted to repair only\nleaks from a hard-coded list of library resource types. That approach limits\nthe scope of repairable leaks: real-world code uses resource wrappers that\nstore a resource in a field and must themselves be closed. This paper makes\nfour key contributions to improve resource leak repair in the presence of\nwrappers. (1) It integrates inference of resource management specifications\ninto the repair pipeline, enabling extant fixing approaches to reason about\nwrappers. (2) It transforms programs into variants that are easier to analyze,\nmaking inference, detection, and fixing tools more effective; for instance, it\nmakes detection tools report problems closer to the root cause, often in a\nclient of a resource wrapper rather than within the wrapper class itself. (3) A\nnovel field containment analysis reasons about resource lifetimes, enabling\nrepair of more leaks involving resources stored in fields. (4) It introduces a\nnew repair pattern and more precise reasoning to better handle resources stored\nin non-final fields. Prior work fixed 41% of resource leak warnings in the NJR\nbenchmark suite; our implementation Arodnap fixes 68%."}
{"id": "2510.04982", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04982", "abs": "https://arxiv.org/abs/2510.04982", "authors": ["Aakash Ahmad", "Muhammad Waseem", "Bakheet Aljedaani", "Mahdi Fahmideh", "Peng Liang", "Feras Awaysheh"], "title": "Quantum Computing as a Service - a Software Engineering Perspective", "comment": "37 pages, 10 images, 5 tables, Manuscript submitted to a Journal\n  (2025)", "summary": "Quantum systems have started to emerge as a disruptive technology and\nenabling platforms - exploiting the principles of quantum mechanics via\nprogrammable quantum bits (QuBits) - to achieve quantum supremacy in computing.\nAcademic research, industrial projects (e.g., Amazon Braket, IBM Qiskit), and\nconsortiums like 'Quantum Flagship' are striving to develop practically capable\nand commercially viable quantum computing (QC) systems and technologies.\nQuantum Computing as a Service (QCaaS) is viewed as a solution attuned to the\nphilosophy of service-orientation that can offer QC resources and platforms, as\nutility computing, to individuals and organisations who do not own quantum\ncomputers. This research investigates a process-centric and architecture-driven\napproach to offer a software engineering perspective on enabling QCaaS - a.k.a\nquantum service-orientation. We employed a two-phase research method comprising\n(a) a systematic mapping study and (b) an architecture-based development, first\nto identify the phases of the quantum service development life cycle and\nsubsequently to integrate these phases into a reference architecture that\nsupports QCaaS. The SMS process retrieved a collection of potentially relevant\nresearch literature and based on a multi-step selection and qualitative\nassessment, we selected 41 peer-reviewed studies to answer three RQs. The RQs\ninvestigate (i) demographic details in terms of frequency, types, and trends of\nresearch, (ii) phases of quantum service development lifecycle to derive a\nreference architecture for conception, modeling, assembly, and deployment of\nservices, and (iii) The results identify a 4-phased development lifecycle along\nwith quantum significant requirements (QSRs), various modeling notations,\ncatalogue of patterns, programming languages, and deployment platforms that can\nbe integrated in a layered reference architecture to engineer QCaaS."}
{"id": "2510.04997", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.04997", "abs": "https://arxiv.org/abs/2510.04997", "authors": ["Jiongchi Yu", "Weipeng Jiang", "Xiaoyu Zhang", "Qiang Hu", "Xiaofei Xie", "Chao Shen"], "title": "AutoEmpirical: LLM-Based Automated Research for Empirical Software Fault Analysis", "comment": "5 pages", "summary": "Understanding software faults is essential for empirical research in software\ndevelopment and maintenance. However, traditional fault analysis, while\nvaluable, typically involves multiple expert-driven steps such as collecting\npotential faults, filtering, and manual investigation. These processes are both\nlabor-intensive and time-consuming, creating bottlenecks that hinder\nlarge-scale fault studies in complex yet critical software systems and slow the\npace of iterative empirical research.\n  In this paper, we decompose the process of empirical software fault study\ninto three key phases: (1) research objective definition, (2) data preparation,\nand (3) fault analysis, and we conduct an initial exploration study of applying\nLarge Language Models (LLMs) for fault analysis of open-source software.\nSpecifically, we perform the evaluation on 3,829 software faults drawn from a\nhigh-quality empirical study. Our results show that LLMs can substantially\nimprove efficiency in fault analysis, with an average processing time of about\ntwo hours, compared to the weeks of manual effort typically required. We\nconclude by outlining a detailed research plan that highlights both the\npotential of LLMs for advancing empirical fault studies and the open challenges\nthat required be addressed to achieve fully automated, end-to-end software\nfault analysis."}
{"id": "2510.04397", "categories": ["cs.CR", "cs.AI", "cs.SE"], "pdf": "https://arxiv.org/pdf/2510.04397", "abs": "https://arxiv.org/abs/2510.04397", "authors": ["Van Nguyen", "Surya Nepal", "Xingliang Yuan", "Tingmin Wu", "Fengchao Chen", "Carsten Rudolph"], "title": "MulVuln: Enhancing Pre-trained LMs with Shared and Language-Specific Knowledge for Multilingual Vulnerability Detection", "comment": null, "summary": "Software vulnerabilities (SVs) pose a critical threat to safety-critical\nsystems, driving the adoption of AI-based approaches such as machine learning\nand deep learning for software vulnerability detection. Despite promising\nresults, most existing methods are limited to a single programming language.\nThis is problematic given the multilingual nature of modern software, which is\noften complex and written in multiple languages. Current approaches often face\nchallenges in capturing both shared and language-specific knowledge of source\ncode, which can limit their performance on diverse programming languages and\nreal-world codebases. To address this gap, we propose MULVULN, a novel\nmultilingual vulnerability detection approach that learns from source code\nacross multiple languages. MULVULN captures both the shared knowledge that\ngeneralizes across languages and the language-specific knowledge that reflects\nunique coding conventions. By integrating these aspects, it achieves more\nrobust and effective detection of vulnerabilities in real-world multilingual\nsoftware systems. The rigorous and extensive experiments on the real-world and\ndiverse REEF dataset, consisting of 4,466 CVEs with 30,987 patches across seven\nprogramming languages, demonstrate the superiority of MULVULN over thirteen\neffective and state-of-the-art baselines. Notably, MULVULN achieves\nsubstantially higher F1-score, with improvements ranging from 1.45% to 23.59%\ncompared to the baseline methods."}
