<div id=toc></div>

# Table of Contents

- [cs.CR](#cs.CR) [Total: 19]
- [cs.SE](#cs.SE) [Total: 31]


<div id='cs.CR'></div>

# cs.CR [[Back]](#toc)

### [1] [Towards the ideals of Self-Recovery and Metadata Privacy in Social Vault Recovery](https://arxiv.org/abs/2507.19484)
*Shailesh Mishra,Simone Colombo,Pasindu Tennage,Martin Burkhart,Bryan Ford*

Main category: cs.CR

TL;DR: Apollo is a novel social key recovery framework that utilizes multi-layered secret sharing to balance user memorability and metadata privacy by distributing indistinguishable data among a user's social circle, reducing malicious recovery chances significantly.


<details>
  <summary>Details</summary>
Motivation: Existing social key recovery mechanisms require users to memorize recovery metadata (e.g., threshold number of trustees), creating a burden while exposing privacy risks. The tradeoff between metadata memorability and privacy needs a new approach.

Method: Apollo distributes indistinguishable data (trustees hold relevant data; non-trustees store random) and employs a multi-layered secret sharing scheme to mitigate overhead and enhance anonymity sets within a user's social circle.

Result: Prototyping shows Apollo reduces malicious recovery chances to 0.005%-1.8% and achieves latency reductions (1.1x to 740kx) over single-layered approaches, depending on reconnection quantity and adversary compromise capabilities.

Conclusion: Apollo addresses the metadata memorability-privacy tradeoff by eliminating reliance on user memory through social circle data gathering while maintaining anonymity and scalability via its multi-layered design.

Abstract: Social key recovery mechanisms enable users to recover their vaults with the
help of trusted contacts, or trustees, avoiding the need for a single point of
trust or memorizing complex strings. However, existing mechanisms overlook the
memorability demands on users for recovery, such as the need to recall a
threshold number of trustees. Therefore, we first formalize the notion of
recovery metadata in the context of social key recovery, illustrating the
tradeoff between easing the burden of memorizing the metadata and maintaining
metadata privacy. We present Apollo, the first framework that addresses this
tradeoff by distributing indistinguishable data within a user's social circle,
where trustees hold relevant data and non-trustees store random data. Apollo
eliminates the need to memorize recovery metadata since a user eventually
gathers sufficient data from her social circle for recovery. Due to
indistinguishability, Apollo protects metadata privacy by forming an anonymity
set that hides the trustees among non-trustees. To make the anonymity set
scalable, Apollo proposes a novel multi-layered secret sharing scheme that
mitigates the overhead due to the random data distributed among non-trustees.
Finally, we provide a prototype implementation of Apollo and report on its
performance. Apollo reduces the chances of malicious recovery to between 0.005%
and 1.8%, depending on the adversary's ability to compromise. The multi-layered
design shows a latency reduction from 1.1x to 740kx compared to a
single-layered approach, depending on the number of reconnections.

</details>


### [2] [Securing the Internet of Medical Things (IoMT): Real-World Attack Taxonomy and Practical Security Measures](https://arxiv.org/abs/2507.19609)
*Suman Deb,Emil Lupu,Emm Mic Drakakis,Anil Anthony Bharath,Zhen Kit Leung,Guang Rui Ma,Anupam Chattopadhyay*

Main category: cs.CR

TL;DR: This paper addresses cybersecurity challenges in IoMT by creating a taxonomy of attacks, identifying vulnerabilities, and proposing guidelines to safeguard medical devices and healthcare systems against threats.


<details>
  <summary>Details</summary>
Motivation: IoMT's connectivity and intelligent devices expose patients to severe cybersecurity risks (e.g., system manipulation leading to health harm). The paper aims to address why IoMT security requires distinct approaches from traditional IT, how to mitigate medical device threats, and aid secure system design for healthcare.

Method: The analysis combines historical cyber incident studies, layered architectural examination of IoMT vulnerabilities, and synthesis of attack surfaces. It integrates technical and standardization frameworks to evaluate mitigation strategies.

Result: A comprehensive taxonomy of IoMT attacks, explicit vulnerabilities in device-to-network layers, practical security guidelines for engineers, and identification of compliance frameworks to address critical gaps in current standards.

Conclusion: The work bridges academic research and healthcare implementation by providing actionable security frameworks, emphasizing the need for device-centric security design, and equipping stakeholders with tools to build resilient IoMT systems.

Abstract: The Internet of Medical Things (IoMT) has the potential to radically improve
healthcare by enabling real-time monitoring, remote diagnostics, and AI-driven
decision making. However, the connectivity, embedded intelligence, and
inclusion of a wide variety of novel sensors expose medical devices to severe
cybersecurity threats, compromising patient safety and data privacy. In
addition, many devices also have direct capacity - individually or in
conjunction with other IoMT devices - to perform actions on the patient, such
as delivering an electrical stimulus, administering a drug, or activating a
motor, which can potentially be life-threatening. We provide a taxonomy of
potential attacks targeting IoMT, presenting attack surfaces, vulnerabilities,
and mitigation strategies across all layers of the IoMT architecture. It
answers key questions such as: What makes IoMT security different from
traditional IT security? What are the cybersecurity threats to medical devices?
How can engineers design secure IoMT systems and protect hospital networks from
cyberattacks? By analyzing historical cyber incidents, we highlight critical
security gaps and propose practical security guidelines for medical device
engineers and security professionals. This work bridges the gap between
research and implementation, equipping healthcare stakeholders with actionable
insights to build resilient and privacy-preserving IoMT ecosystems. Finally, we
present the latest standardization and compliance frameworks, that IoMT
security designers should be aware of.

</details>


### [3] [Trivial Trojans: How Minimal MCP Servers Enable Cross-Tool Exfiltration of Sensitive Data](https://arxiv.org/abs/2507.19880)
*Nicola Croce,Tobin South*

Main category: cs.CR

TL;DR: This paper highlights critical security vulnerabilities in the Model Context Protocol (MCP), showing how low-skill attackers can exploit its trust model to steal sensitive financial data via social engineering attacks on combined servers, while proposing mitigations and protocol improvements.


<details>
  <summary>Details</summary>
Motivation: Research focuses on MCP's unexplored attack vectors, addressing potential risks of its trust model as AI ecosystems increasingly rely on interconnected external services for enhanced functionality.

Method: Authors designed a proof-of-concept attack using a malicious weather-server mimicry (requiring basic Python skills and free tools) to intercept and exfiltrate data from legitimate financial tools within the MCP framework.

Result: Demonstrated cross-server attack feasibility with minimal resources, successfully extracting user account information without advanced technical infrastructure or financial investment.

Conclusion: MCP enables powerful AI workflows but introduces novel security risks; the study emphasizes the urgent need for protocol-level reforms to address implicit trust assumptions and prevent surface-exploiting attacks.

Abstract: The Model Context Protocol (MCP) represents a significant advancement in
AI-tool integration, enabling seamless communication between AI agents and
external services. However, this connectivity introduces novel attack vectors
that remain largely unexplored. This paper demonstrates how unsophisticated
threat actors, requiring only basic programming skills and free web tools, can
exploit MCP's trust model to exfiltrate sensitive financial data. We present a
proof-of-concept attack where a malicious weather MCP server, disguised as
benign functionality, discovers and exploits legitimate banking tools to steal
user account balances. The attack chain requires no advanced technical
knowledge, server infrastructure, or monetary investment. The findings reveal a
critical security gap in the emerging MCP ecosystem: while individual servers
may appear trustworthy, their combination creates unexpected cross-server
attack surfaces. Unlike traditional cybersecurity threats that assume
sophisticated adversaries, our research shows that the barrier to entry for
MCP-based attacks is alarmingly low. A threat actor with undergraduate-level
Python knowledge can craft convincing social engineering attacks that exploit
the implicit trust relationships MCP establishes between AI agents and tool
providers. This work contributes to the nascent field of MCP security by
demonstrating that current MCP implementations allow trivial cross-server
attacks and proposing both immediate mitigations and protocol improvements to
secure this emerging ecosystem.

</details>


### [4] [ConSeg: Contextual Backdoor Attack Against Semantic Segmentation](https://arxiv.org/abs/2507.19905)
*Bilal Hussain Abbasi,Zirui Gong,Yanjun Zhang,Shang Gao,Antonio Robles-Kelly,Leo Zhang*

Main category: cs.CR

TL;DR: Introduces ConSeg, a context-based backdoor attack for semantic segmentation with 15.55\% higher Attack Success Rate (ASR) and resilience against leading defenses.


<details>
  <summary>Details</summary>
Motivation: Existing backdoor defenses are insufficient when target classes co-occur with victim classes. Leveraging contextual relationships can enhance attack effectiveness.

Method: ConSeg mimics target class contextual features and rebuilds them in victim regions, exploiting natural co-occurrence patterns to create misleading contextual dependencies.

Result: 15.55\% ASR improvement over prior methods with comparable benign segmentation accuracy, while resisting detection by state-of-the-art backdoor defenses.

Conclusion: ConSeg offers a new attack paradigm for segmentation models using contextual relationships, demonstrating superior effectiveness and evasion capability.

Abstract: Despite significant advancements in computer vision, semantic segmentation
models may be susceptible to backdoor attacks. These attacks, involving hidden
triggers, aim to cause the models to misclassify instances of the victim class
as the target class when triggers are present, posing serious threats to the
reliability of these models. To further explore the field of backdoor attacks
against semantic segmentation, in this paper, we propose a simple yet effective
backdoor attack called Contextual Segmentation Backdoor Attack (ConSeg). ConSeg
leverages the contextual information inherent in semantic segmentation models
to enhance backdoor performance. Our method is motivated by an intriguing
observation, i.e., when the target class is set as the `co-occurring' class of
the victim class, the victim class can be more easily `mis-segmented'. Building
upon this insight, ConSeg mimics the contextual information of the target class
and rebuilds it in the victim region to establish the contextual relationship
between the target class and the victim class, making the attack easier. Our
experiments reveal that ConSeg achieves improvements in Attack Success Rate
(ASR) with increases of 15.55\%, compared to existing methods, while exhibiting
resilience against state-of-the-art backdoor defenses.

</details>


### [5] ["Blockchain-Enabled Zero Trust Framework for Securing FinTech Ecosystems Against Insider Threats and Cyber Attacks"](https://arxiv.org/abs/2507.19976)
*Avinash Singh,Vikas Pareek,Asish Sharma*

Main category: cs.CR

TL;DR: This paper proposes integrating blockchain into a Zero Trust framework to enhance cybersecurity for Fintech organizations by addressing limitations of traditional defenses against insider attacks, malware, and APTs through Ethereum-based policy engines and DApp validation.


<details>
  <summary>Details</summary>
Motivation: Traditional perimeter-based cybersecurity is vulnerable to evolving threats in Fintech, risking financial losses and data breaches due to insufficient countermeasures against insider attacks, malware intrusions, and advanced persistent threats.

Method: The approach utilizes Ethereum smart contracts to implement Multi Factor Authentication (MFA), Role-Based Access Control (RBAC), and Just-In-Time (JIT) access privileges. Blockchain serves as a Policy Engine (PE) and Policy Enforcement Point (PEP) for immutable access control, micro-segmentation, and audit trails, validated via STRIDE threat modeling and 200-node simulations.

Result: The framework demonstrated resilience against spoofing, tampering, and privilege escalation. Compared to perimeter systems (74.0 ms vs. 49.33 ms latency, 30.77 vs. 50.0 requests/sec throughput), it significantly improved security through decentralization but with performance trade-offs. Simulations confirmed robustness in policy enforcement.

Conclusion: This work establishes a decentralized, cost-effective Zero Trust model using blockchain for Fintech security. Future optimizations will employ Layer-2 solutions to enhance scalability while confirming the framework's ability to mitigate critical threats through experimental validation.

Abstract: Fintech provides technological services to increase operational efficiency in
financial institutions, but traditional perimeter-based defense mechanisms are
insufficient against evolving cyber threats like insider attacks, malware
intrusions, and Advanced Persistent Threats (APTs). These vulnerabilities
expose Fintech organizations to significant risks, including financial losses
and data breaches. To address these challenges, this paper proposes a
blockchain-integrated Zero Trust framework, adhering to the principle of "Never
Trust, Always Verify." The framework uses Ethereum smart contracts to enforce
Multi Factor Authentication (MFA), Role-Based Access Control (RBAC), and
Just-In-Time (JIT) access privileges, effectively mitigating credential theft
and insider threats, the effect of malware and APT attacks.
  The proposed solution transforms blockchain into a Policy Engine (PE) and
Policy Enforcement Point (PEP), and policy storage, ensuring immutable access
control and micro-segmentation. A decentralized application (DApp) prototype
was developed and tested using STRIDE threat modeling, demonstrating resilience
against spoofing, tampering, and privilege escalation. Comparative analysis
with Perimeter-based systems revealed a trade-off: while the framework
introduced a marginal latency increase (74.0 ms vs. 49.33 ms) and reduced
throughput (30.77 vs. 50.0 requests/sec), it significantly enhanced security by
eliminating single points of failure and enabling tamper-proof audit trails.
  Experimental validation on a 200-node simulated network confirmed the
framework's robustness, with future optimizations targeting Layer-2 solutions
for scalability. This work bridges the gap between Zero Trust theory and
practical blockchain implementation, offering Fintech organizations a
decentralized, cost-effective security model.

</details>


### [6] [Policy-Driven AI in Dataspaces: Taxonomy, Explainability, and Pathways for Compliant Innovation](https://arxiv.org/abs/2507.20014)
*Joydeep Chandra,Satyam Kumar Navneet*

Main category: cs.CR

TL;DR: This paper reviews AI techniques for privacy, performance, and policy compliance in dataspaces, proposing a novel taxonomy and analyzing key metrics while identifying research gaps and future directions.


<details>
  <summary>Details</summary>
Motivation: AI-driven dataspaces face challenges in balancing privacy, performance, and regulatory compliance, necessitating a structured framework to navigate these trade-offs effectively.

Method: A comprehensive review of privacy-preserving and policy-aware AI methods (Federated Learning, Differential Privacy, etc.) with a taxonomy categorizing techniques based on privacy, performance, and compliance complexity.

Result: Highlighting multi-dimensional optimization challenges in metrics like latency and fairness; identifying gaps in standardized KPIs, federated explainable AI, and semantic policy enforcement across fragmented regulations.

Conclusion: The proposed taxonomy and analysis provide actionable insights for developing compliant, secure AI systems, while future directions emphasize automated validation, benchmarks, and alignment with European data initiatives.

Abstract: As AI-driven dataspaces become integral to data sharing and collaborative
analytics, ensuring privacy, performance, and policy compliance presents
significant challenges. This paper provides a comprehensive review of
privacy-preserving and policy-aware AI techniques, including Federated
Learning, Differential Privacy, Trusted Execution Environments, Homomorphic
Encryption, and Secure Multi-Party Computation, alongside strategies for
aligning AI with regulatory frameworks such as GDPR and the EU AI Act. We
propose a novel taxonomy to classify these techniques based on privacy levels,
performance impacts, and compliance complexity, offering a clear framework for
practitioners and researchers to navigate trade-offs. Key performance metrics
-- latency, throughput, cost overhead, model utility, fairness, and
explainability -- are analyzed to highlight the multi-dimensional optimization
required in dataspaces. The paper identifies critical research gaps, including
the lack of standardized privacy-performance KPIs, challenges in explainable AI
for federated ecosystems, and semantic policy enforcement amidst regulatory
fragmentation. Future directions are outlined, proposing a conceptual framework
for policy-driven alignment, automated compliance validation, standardized
benchmarking, and integration with European initiatives like GAIA-X, IDS, and
Eclipse EDC. By synthesizing technical, ethical, and regulatory perspectives,
this work lays the groundwork for developing trustworthy, efficient, and
compliant AI systems in dataspaces, fostering innovation in secure and
responsible data-driven ecosystems.

</details>


### [7] [Cryptographic Data Exchange for Nuclear Warheads](https://arxiv.org/abs/2507.20074)
*Neil Perry,Daniil Zhukov*

Main category: cs.CR

TL;DR: This paper proposes a cryptographic protocol using zkSNARKs and commitment schemes for secure, verifiable nuclear warhead tracking without intrusive inspections. It introduces a 'Warhead Passport' system that chains commitments across warhead lifecycles while maintaining data confidentiality through dual-hash combiners.


<details>
  <summary>Details</summary>
Motivation: Nuclear arms control treaties traditionally focus on delivery systems, not warheads, leading to verification gaps. Physical inspections are intrusive and politically challenging, necessitating a secure, non-intrusive digital verification solution that preserves sensitive data confidentiality.

Method: The approach combines cryptographic commitment schemes with zkSNARKs to create a 'Warhead Passport' tracking system. It chains commitments to individual warheads throughout their lifecycle, enabling periodic challenges and real-time verification. Dual-hash combiners (SHA-family & GOST R 34.11) are integrated for cryptographic robustness and political accommodation, ensuring forward security.

Result: An implementation of the Warhead Passport system was developed that adheres to actual treaty constraints. The protocol achieves secure, auditable verification of nuclear warheads while maintaining data privacy and enabling real-time compliance checks through cryptographic techniques.

Conclusion: This work establishes a practical framework for NSNW verification using cryptography, complementing prior arms control policy research. By addressing both technical and political constraints through dual-hash integration and forward security, it provides a viable path toward verifiable warhead accountability without compromising secrecy.

Abstract: Nuclear arms control treaties have historically focused on strategic nuclear
delivery systems, leaving nuclear warheads outside formal verification
frameworks. This paper presents a cryptographic protocol for secure and
verifiable warhead tracking, addressing challenges in nuclear warhead
verification without requiring intrusive physical inspections. Our system
leverages commitment schemes and zero-knowledge succinct non-interactive
arguments of knowledge (zkSNARKs) to ensure compliance with treaty constraints
while preserving the confidentiality of sensitive nuclear warhead data. We
propose a cryptographic "Warhead Passport" tracking system that chains
commitments to individual warheads over their life cycle, enabling periodic
challenges and real-time verification of treaty compliance. Our implementation
follows real-world treaty constraints, integrates U.S. and Russian dual-hash
combiners (SHA-family & GOST R 34.11 family) for cryptographic robustness and
political constraints, and ensures forward security by preventing retroactive
data manipulation. This work builds on policy research from prior arms control
studies and provides a practical foundation for implementing secure, auditable
NSNW verification mechanisms.

</details>


### [8] [SoK: Root Cause of \$1 Billion Loss in Smart Contract Real-World Attacks via a Systematic Literature Review of Vulnerabilities](https://arxiv.org/abs/2507.20175)
*Hadis Rezaei,Mojtaba Eshghie,Karl Anderesson,Francesco Palmieri*

Main category: cs.CR

TL;DR: This paper addresses the gap between academic understanding of Ethereum smart contract vulnerabilities and real-world financial losses, analyzing 71 papers and 50 major exploits to identify root causes across four tiers: protocol logic design, lifecycle/governance, external dependencies, and implementation bugs.


<details>
  <summary>Details</summary>
Motivation: The Ethereum ecosystem experiences billions in annual losses from smart contract attacks, yet existing research primarily focuses on implementation-level bugs rather than comprehensively addressing real-world exploit root causes.

Method: 1) Systematic literature review of 71 academic papers to catalog 24 active vulnerabilities. 2) Empirical analysis of 50 high-impact exploits (2022-2025, $1.09B+ losses) using 'exploit chain' analysis to identify how human, operational, and economic design flaws interact with code bugs.

Result: Identified four tiers of root causes in real-world Ethereum exploits: protocol logic design flaws (26.5% of incidents), lifecycle/governance issues (10.3%), external dependency problems (31.2%), and traditional implementation bugs (32%). Developed a framework for categorizing exploits beyond code-level vulnerabilities.

Conclusion: Real-world Ethereum attacks stem from a complex interplay of design flaws across multiple tiers, not just implementation-level bugs. The four-tier framework provides a more holistic approach to understanding and mitigating financial risks in blockchain systems.

Abstract: The Ethereum ecosystem, despite its maturity, continues to witness
catastrophic attacks, with billions of dollars in assets lost annually. In
response, a significant body of research has focused on identifying and
mitigating smart contract vulnerabilities. However, these efforts predominantly
focus on implementation-level bugs, leaving a critical gap between academic
understanding of vulnerabilities and the root causes of real-world high-impact
financial losses. We employ a two-pronged methodology: first, a systematic
literature review of 71 academic papers to build a comprehensive and up-to-date
catalog of 24 active and 5 deprecated vulnerabilities as understood by the
research community. Second, we conduct an in-depth, empirical analysis of 50 of
the most severe real-world exploits between 2022 and 2025, collectively
incurring over \$1.09B in losses, to identify their true root causes. We
introduce the concept of "exploit chains" by revealing that many incidents are
not caused by isolated vulnerabilities but by combinations of human,
operational, and economic design flaws that link with implementation bugs to
enable an attack. Our analysis yields insights on how DApps are exploited in
practice, leading to a novel, four-tier root-cause framework that moves beyond
code-level vulnerabilities. We find that real-world successful attacks on
Ethereum (and related networks) trace back to one of the four tiers of (1)
protocol logic design, (2) lifecycle and governance, (3) external dependencies,
and (4) traditional implementation bugs (classic smart contract
vulnerabilities). We investigate the suitability of this multi-tier incident
root-cause framework via a case study.

</details>


### [9] [Measuring and Explaining the Effects of Android App Transformations in Online Malware Detection](https://arxiv.org/abs/2507.20361)
*Guozhu Meng,Zhixiu Guo,Xiaodong Zhang,Haoyu Wang,Kai Chen,Yang Liu*

Main category: cs.CR

TL;DR: The paper presents a data-driven study measuring how app transformations affect malware detection by antivirus engines, using 971K reports from 179K apps tracked on VirusTotal over one month to analyze detection mechanisms.


<details>
  <summary>Details</summary>
Motivation: Antivirus engines frequently fail to detect malware variants created through obfuscation and other transformations, but it is unclear whether this is due to evasion effectiveness or engine limitations. This study aims to quantify the impact of code transformations and analyze engine behavior.

Method: 1) Developed an antivirus engine interaction model to correlate input app transformations with detection outcomes. 2) Implemented six Android app transformation techniques for controlled variation generation. 3) Tracked detection results across multiple antivirus engines using VirusTotal, collecting 971K reports for 179K apps. 4) Analyzed these results through signature-based, static analysis-based, and dynamic analysis-based detection lenses.

Result: The analysis reveals seven key findings identifying 1) internal detection mechanisms of antivirus engines 2) detectable indicators of compromise in transformed apps 3) quantified impact of various obfuscation techniques on detection rates across signature-based, static, and dynamic analysis approaches.

Conclusion: This study uncovers the interplay between app transformations and antivirus detection capabilities, providing actionable insights into engine limitations and detection patterns to guide improved malware analysis and antivirus evaluation methods.

Abstract: It is well known that antivirus engines are vulnerable to evasion techniques
(e.g., obfuscation) that transform malware into its variants. However, it
cannot be necessarily attributed to the effectiveness of these evasions, and
the limits of engines may also make this unsatisfactory result. In this study,
we propose a data-driven approach to measure the effect of app transformations
to malware detection, and further explain why the detection result is produced
by these engines. First, we develop an interaction model for antivirus engines,
illustrating how they respond with different detection results in terms of
varying inputs. Six app transformation techniques are implemented in order to
generate a large number of Android apps with traceable changes. Then we
undertake a one-month tracking of app detection results from multiple antivirus
engines, through which we obtain over 971K detection reports from VirusTotal
for 179K apps in total. Last, we conduct a comprehensive analysis of antivirus
engines based on these reports from the perspectives of signature-based, static
analysis-based, and dynamic analysis-based detection techniques. The results,
together with 7 highlighted findings, identify a number of sealed working
mechanisms occurring inside antivirus engines and what are the indicators of
compromise in apps during malware detection.

</details>


### [10] [Is Crunching Public Data the Right Approach to Detect BGP Hijacks?](https://arxiv.org/abs/2507.20434)
*Alessandro Giaconia,Muoi Tran,Laurent Vanbever,Stefano Vissicchio*

Main category: cs.CR

TL;DR: This paper identifies a critical vulnerability in ML-based BGP hijack detection systems like DFOH and BEAM, showing attackers can evade detection through data poisoning by injecting bogus routes into BGP monitors.


<details>
  <summary>Details</summary>
Motivation: Despite ongoing ROV deployment, post-ROV attacks like forged-origin hijacks persist, and existing ML-based detection frameworks rely on the assumption that anomalies in public BGP data are easily discernible, ignoring the risk of compromised BGP monitors.

Method: The authors use large-scale BGP simulations to demonstrate that attackers can corrupt ML-based defenses' knowledge bases and manipulate detection metrics using a small number of strategically crafted route announcements.

Result: Experimental results reveal that just a few crafted announcements beyond the actual hijack can enable attackers to avoid detection by ML systems, undermining their effectiveness through poisoned training data.

Conclusion: Relying solely on public BGP data for hijack detection leaves ML-based systems vulnerable to data poisoning attacks, emphasizing the need for defenses that account for potential adversarial manipulation of monitoring infrastructure.

Abstract: The Border Gateway Protocol (BGP) remains a fragile pillar of Internet
routing. BGP hijacks still occurr daily. While full deployment of Route Origin
Validation (ROV) is ongoing, attackers have already adapted, launching post-ROV
attacks such as forged-origin hijacks. To detect these, recent approaches like
DFOH [Holterbach et al., USENIX NSDI '24] and BEAM [Chen et al., USENIX
Security '24] apply machine learning (ML) to analyze data from globally
distributed BGP monitors, assuming anomalies will stand out against historical
patterns. However, this assumption overlooks a key threat: BGP monitors
themselves can be misled by adversaries injecting bogus routes. This paper
shows that state-of-the-art hijack detection systems like DFOH and BEAM are
vulnerable to data poisoning. Using large-scale BGP simulations, we show that
attackers can evade detection with just a handful of crafted announcements
beyond the actual hijack. These announcements are indeed sufficient to corrupt
the knowledge base used by ML-based defenses and distort the metrics they rely
on. Our results highlight a worrying weakness of relying solely on public BGP
data.

</details>


### [11] [MPC-EVM: Enabling MPC Execution by Smart Contracts In An Asynchronous Manner](https://arxiv.org/abs/2507.20554)
*Yichen Zhou,Chenxing Li,Fan Long*

Main category: cs.CR

TL;DR: MPC-EVM is a blockchain prototype extending Ethereum Virtual Machine (EVM) to support asynchronous Multiparty Computation (MPC) invocations during transaction execution while maintaining consistency and throughput, achieving <3% TPS reduction.


<details>
  <summary>Details</summary>
Motivation: Traditional EVM lacks native support for asynchronous MPC, which is critical for privacy-preserving transactions, leading to performance bottlenecks. This paper addresses these limitations to enable scalable MPC in blockchains.

Method: MPC-EVM employs (1) an asynchronous execution model that pauses transaction progress upon MPC invocation and resumes after completion, and (2) access control mechanisms to prevent state inconsistency during concurrent operations.

Result: Throughput benchmarking showed a <3% decrease in TPS when executing MPC-invoking transactions alongside regular transactions, demonstrating minimal performance impact compared to a baseline.

Conclusion: MPC-EVM successfully integrates asynchronous MPC into EVM-based blockchains without compromising consistency or throughput, providing a viable solution for privacy-critical, scalable smart contract applications.

Abstract: This paper presents MPC-EVM, the first blockchain prototype that extends the
EVM to enable asynchronous MPC invocations by smart contracts during
transaction executions without compromising consistency or throughput. MPC-EVM
uses an asynchronous execution model to process MPC-invoking transactions in a
non-blocking fashion, saving the transaction's progress when it enters an MPC
and resuming its execution upon MPC's completion. Additionally, it employs an
access control mechanism that prevents inconsistent state access and
modifications as a result of asynchronous executions. Benchmarking MPC-EVM's
throughput show that the transactions per second (TPS) decreased by less than
3% compared to the baseline when MPC-invoking transactions are executed
alongside regular transactions.

</details>


### [12] [Hot-Swap MarkBoard: An Efficient Black-box Watermarking Approach for Large-scale Model Distribution](https://arxiv.org/abs/2507.20650)
*Zhicheng Zhang,Peizhuo Lv,Mengke Wan,Jiang Fang,Diandian Guo,Yezeng Chen,Yinlong Liu,Wei Ma,Jiyan Sun,Liru Geng*

Main category: cs.CR

TL;DR: The paper proposes Hot-Swap MarkBoard, a scalable watermarking method for on-device AI that enables efficient customization of user-specific watermarks without retraining, outperforming existing approaches in adaptability and verification accuracy.


<details>
  <summary>Details</summary>
Motivation: On-device AI deployment increases IP risks due to distributed models, but existing watermarking solutions require retraining for customization and are unsuitable for large-scale distribution scenarios.

Method: Hot-Swap MarkBoard encodes n-bit binary signatures using multi-branch Low-Rank Adaptation (LoRA) modules, allowing branch swapping for watermark customization. Parameter obfuscation entangles watermark weights with base model parameters to prevent removal without performance degradation.

Result: Experiments across three tasks (classification, image/text generation) and six models show 100% verification accuracy and superior efficiency compared to retraining-based methods, with detailed comparisons on adaptability and attack resistance.

Conclusion: Hot-Swap MarkBoard provides a practical solution for IP protection in on-device AI by enabling zero-retraining watermark customization, maintaining model performance during obfuscation, and supporting black-box verification across diverse tasks and architectures.

Abstract: Recently, Deep Learning (DL) models have been increasingly deployed on
end-user devices as On-Device AI, offering improved efficiency and privacy.
However, this deployment trend poses more serious Intellectual Property (IP)
risks, as models are distributed on numerous local devices, making them
vulnerable to theft and redistribution. Most existing ownership protection
solutions (e.g., backdoor-based watermarking) are designed for cloud-based
AI-as-a-Service (AIaaS) and are not directly applicable to large-scale
distribution scenarios, where each user-specific model instance must carry a
unique watermark. These methods typically embed a fixed watermark, and
modifying the embedded watermark requires retraining the model. To address
these challenges, we propose Hot-Swap MarkBoard, an efficient watermarking
method. It encodes user-specific $n$-bit binary signatures by independently
embedding multiple watermarks into a multi-branch Low-Rank Adaptation (LoRA)
module, enabling efficient watermark customization without retraining through
branch swapping. A parameter obfuscation mechanism further entangles the
watermark weights with those of the base model, preventing removal without
degrading model performance. The method supports black-box verification and is
compatible with various model architectures and DL tasks, including
classification, image generation, and text generation. Extensive experiments
across three types of tasks and six backbone models demonstrate our method's
superior efficiency and adaptability compared to existing approaches, achieving
100\% verification accuracy.

</details>


### [13] [Program Analysis for High-Value Smart Contract Vulnerabilities: Techniques and Insights](https://arxiv.org/abs/2507.20672)
*Yannis Smaragdakis,Neville Grech,Sifis Lagouvardos,Konstantinos Triantafyllou,Ilias Tsatiris,Yannis Bollanos,Tony Rocco Valentine*

Main category: cs.CR

TL;DR: This paper challenges the belief that automated techniques can't detect high-value blockchain bugs, presenting methods achieving $3M+ in bug bounty rewards through advanced static analysis and domain knowledge inference.


<details>
  <summary>Details</summary>
Motivation: The paper addresses the misconception that automated methods are only suitable for shallow smart contract bugs, demonstrating their effectiveness in identifying high-impact vulnerabilities with substantial reward value.

Method: 1) High-completeness static analysis with precision-acceptance balance 2) Domain knowledge acquisition through expert input and statistical inference from 10k+ deployed contracts 3) Novel corpus-based analysis techniques for vulnerability pattern identification

Result: 10 high-profile bug bounties totaling $3M in disclosed vulnerabilities, plus 100s of pre-audit/deployment bugs detected. Achieved under-1% false-negative rate despite 95% false-positive rate - contrary to academic analysis standards.

Conclusion: High-value vulnerability detection requires prioritizing complete static analysis coverage over low false-positives, accepting up to 95% false-alarms since real-world value emerges from finding true positives in critical contracts (only 1 in 20 reports being actionable shows 5% accuracy suffices for million-dollar rewards).

Abstract: A widespread belief in the blockchain security community is that automated
techniques are only good for detecting shallow bugs, typically of small value.
In this paper, we present the techniques and insights that have led us to
repeatable success in automatically discovering high-value smart contract
vulnerabilities. Our vulnerability disclosures have yielded 10 bug bounties,
for a total of over $3M, over high-profile deployed code, as well as hundreds
of bugs detected in pre-deployment or under-audit code.
  We argue that the elements of this surprising success are a) a very
high-completeness static analysis approach that manages to maintain acceptable
precision; b) domain knowledge, provided by experts or captured via statistical
inference. We present novel techniques for automatically inferring domain
knowledge from statistical analysis of a large corpus of deployed contracts, as
well as discuss insights on the ideal precision and warning rate of a promising
vulnerability detector. In contrast to academic literature in program analysis,
which routinely expects false-positive rates below 50% for publishable results,
we posit that a useful analysis for high-value real-world vulnerabilities will
likely flag very few programs (under 1%) and will do so with a high
false-positive rate (e.g., 95%, meaning that only one-of-twenty human
inspections will yield an exploitable vulnerability).

</details>


### [14] [A Novel Post-Quantum Secure Digital Signature Scheme Based on Neural Network](https://arxiv.org/abs/2507.20676)
*Satish Kumar,Md. Arzoo Jamal*

Main category: cs.CR

TL;DR: This paper proposes a novel multivariate polynomial digital signature scheme using neural networks with binary weights and a recurrent random vector to enhance security against quantum attacks, with proven EUF-CMA security and computational infeasibility of key recovery.


<details>
  <summary>Details</summary>
Motivation: Post-quantum security threats to classical digital signatures necessitate the development of cryptographic alternatives. Neural networks' ability to model non-linear relationships (via weights/biases) offers potential for constructing quantum-resistant architectures.

Method: Leverages a binary-weighted neural network as the core mathematical structure, combined with a state-dependent recurrent random vector that provides dynamic randomness similar to attention mechanisms in neural models.

Result: The scheme achieves EUF-CMA security proof, demonstrates resistance to polynomial-time quantum key-recovery attacks, and exhibits operational efficiency validated through practical implementation analysis.

Conclusion: Neural network-based signature schemes with binary weights and recurrent randomness represent a promising post-quantum cryptographic approach, offering both theoretical security against quantum adversaries and practical computational viability.

Abstract: Digital signatures are fundamental cryptographic primitives that ensure the
authenticity and integrity of digital documents. In the post-quantum era,
classical public key-based signature schemes become vulnerable to brute-force
and key-recovery attacks due to the computational power of quantum algorithms.
Multivariate polynomial based signature schemes are among the one of the
cryptographic constructions that offers strong security guarantees against such
quantum threats. With the growing capabilities of neural networks, it is
natural to explore their potential application in the design of cryptographic
primitives. Neural networks inherently captures the non-linear relationships
within the data, which are encoded in their synaptic weight matrices and bias
vectors. In this paper, we propose a novel construction of a multivariate
polynomial based digital signature scheme that leverages neural network
architectures. A neural network with binary weights is employed to define the
central structure of the signature scheme. The design introduces a recurrent
random vector, functionally analogous to an attention mechanism, which
contributes dynamic randomness based on the previous state, thereby enhancing
the scheme's security. It is demonstrated that the proposed signature scheme
provide security against Existential Unforgeability under adaptive
Chosen-Message Attacks (EUF-CMA). Furthermore, it is proven that direct attacks
aimed to recover the private keys are computationally infeasible within
polynomial time, even in the presence of quantum computing abilities. The
operational characteristics of the proposed scheme are also evaluated, with
results indicating notable efficiency and practical viability in post-quantum
cryptographic applications.

</details>


### [15] [Guard-GBDT: Efficient Privacy-Preserving Approximated GBDT Training on Vertical Dataset](https://arxiv.org/abs/2507.20688)
*Anxiao Song,Shujie Cui,Jianli Bai,Ke Cheng,Yulong Shen,Giovanni Russello*

Main category: cs.CR

TL;DR: Guard-GBDT introduces an efficient privacy-preserving GBDT framework using secure multiparty computation (MPC) with optimized approximations and communication reduction techniques. It achieves up to 12.21× speed improvements over state-of-the-art methods while maintaining comparable accuracy.


<details>
  <summary>Details</summary>
Motivation: Existing MPC-based GBDT frameworks face efficiency challenges from high communication costs and computations of non-linear operations (division, sigmoid functions). Privacy concerns and legal regulations demand practical secure collaborative machine learning solutions.

Method: Proposes Guard-GBDT: 1) Replaces division and sigmoid functions with streamlined approximations to avoid MPC-unfriendly operations. 2) Implements message compression during gradient aggregation to reduce communication overhead. 3) Optimizes efficiency for vertical dataset scenarios through secure computation design.

Result: Guard-GBDT outperforms HEP-XGB (CIKM'21) by 2.71× in LAN and 2.7× in WAN environments. Achieves 12.21× LAN and 8.2× WAN speed improvements over SiGBDT (ASIACCS'24). Maintains accuracy with ±1–2% deviation compared to plaintext XGBoost and matching SiGBDT.

Conclusion: Guard-GBDT provides a practical solution for privacy-preserving GBDT via vertical federated learning, significantly improving computation and communication efficiency while satisfying accuracy requirements. The results demonstrate its potential for wide adoption in regulated data collaboration scenarios.

Abstract: In light of increasing privacy concerns and stringent legal regulations,
using secure multiparty computation (MPC) to enable collaborative GBDT model
training among multiple data owners has garnered significant attention. Despite
this, existing MPC-based GBDT frameworks face efficiency challenges due to high
communication costs and the computation burden of non-linear operations, such
as division and sigmoid calculations. In this work, we introduce Guard-GBDT, an
innovative framework tailored for efficient and privacy-preserving GBDT
training on vertical datasets. Guard-GBDT bypasses MPC-unfriendly division and
sigmoid functions by using more streamlined approximations and reduces
communication overhead by compressing the messages exchanged during gradient
aggregation. We implement a prototype of Guard-GBDT and extensively evaluate
its performance and accuracy on various real-world datasets. The results show
that Guard-GBDT outperforms state-of-the-art HEP-XGB (CIKM'21) and SiGBDT (ASIA
CCS'24) by up to $2.71\times$ and $12.21 \times$ on LAN network and up to
$2.7\times$ and $8.2\times$ on WAN network. Guard-GBDT also achieves comparable
accuracy with SiGBDT and plaintext XGBoost (better than HEP-XGB ), which
exhibits a deviation of $\pm1\%$ to $\pm2\%$ only. Our implementation code is
provided at https://github.com/XidianNSS/Guard-GBDT.git.

</details>


### [16] [An Open-source Implementation and Security Analysis of Triad's TEE Trusted Time Protocol](https://arxiv.org/abs/2507.20851)
*Matthieu Bettinger,Sonia Ben Mokhtar,Anthony Simonet-Boulogne*

Main category: cs.CR

TL;DR: The paper demonstrates vulnerabilities in the Triad protocol for maintaining trusted time in TEEs like Intel SGX, showing how OS-controlled scheduling can manipulate time perception and propagate time-skips across honest machines, then proposes protocol modifications to enhance resilience.


<details>
  <summary>Details</summary>
Motivation: Many protocols rely on time measurements, but TEEs depend on untrusted external time sources. Existing solutions like Triad lack sufficient protection against time manipulation by malicious hosting systems that control OS scheduling.

Method: Empirical analysis using a public Triad implementation to showcase vulnerabilities through attack scenarios where system-wide clock speed manipulation compromises time consistency across TEE instances.

Result: Single-malfunction scenarios prove an attacker can force honest machines to adopt arbitrarily far-future timestamps through scheduling attacks, enabling malicious time propagation across the network. The Triad protocol was directly tested.

Conclusion: Current trusted time protocols for TEEs are insufficient; proposed protocol changes aim to prevent time manipulation through scheduling attacks. Future work should address time propagation resilience in TEE environments.

Abstract: The logic of many protocols relies on time measurements. However, in Trusted
Execution Environments (TEEs) like Intel SGX, the time source is outside the
Trusted Computing Base: a malicious system hosting the TEE can manipulate that
TEE's notion of time, e.g., jumping in time or affecting the perceived time
speed. Previous work like Triad propose protocols for TEEs to maintain a
trustworthy time source. However, in this paper, based on a public
implementation of Triad that we contribute, we empirically showcase
vulnerabilities to this protocol. For example, an attacker controlling the
operating system, and consequently the scheduling algorithm, may arbitrarily
manipulate their local TEE's clock speed. What is worse, in case of faster
malicious clock speeds, an attacker on a single compromised machine may
propagate the attack to honest machines participating in Triad's Trusted Time
protocol, causing them to skip to timestamps arbitrarily far in the future.
Then, infected honest machines propagate time-skips themselves to other honest
machines interacting with them. We discuss protocol changes to Triad for higher
resilience against such attacks.

</details>


### [17] [Testbed and Software Architecture for Enhancing Security in Industrial Private 5G Networks](https://arxiv.org/abs/2507.20873)
*Song Son Ha,Florian Foerster,Thomas Robert Doebbert,Tim Kittel,Dominik Merli,Gerd Scholl*

Main category: cs.CR

TL;DR: The paper introduces a testbed and software architecture to enhance security in Private 5G Networks for industrial communication environments, addressing the challenges of secure and efficient systems in the Industry 4.0 era.


<details>
  <summary>Details</summary>
Motivation: Industry 4.0 demands secure and efficient communication systems, which 5G networks aim to provide. However, 5G deployment poses significant security risks due to sophisticated cyber threats, necessitating robust solutions for industrial contexts.

Method: The authors propose and develop a testbed and software architecture tailored for securing Private 5G Networks, focusing on industrial use cases with specific requirements like low latency and massive connectivity.

Result: The proposed testbed and software architecture are evaluated for their effectiveness in mitigating security challenges in private 5G networks, demonstrating potential to counter cyber threats in industrial settings.

Conclusion: The paper concludes that the proposed framework provides a structured approach to securing Private 5G Networks in industrial environments, addressing critical requirements for secure, low-latency, and high-capacity communication systems.

Abstract: In the era of Industry 4.0, the growing need for secure and efficient
communication systems has driven the development of fifth-generation (5G)
networks characterized by extremely low latency, massive device connectivity
and high data transfer speeds. However, the deployment of 5G networks presents
significant security challenges, requiring advanced and robust solutions to
counter increasingly sophisticated cyber threats. This paper proposes a testbed
and software architecture to strengthen the security of Private 5G Networks,
particularly in industrial communication environments.

</details>


### [18] [Characterizing the Sensitivity to Individual Bit Flips in Client-Side Operations of the CKKS Scheme](https://arxiv.org/abs/2507.20891)
*Matias Mazzanti,Augusto Vega,Esteban Mocskos*

Main category: cs.CR

TL;DR: This paper studies the impact of bit-flip errors on the CKKS homomorphic encryption scheme, revealing that performance optimizations like RNS/NTT reduce fault tolerance, laying groundwork for more resilient HE designs.


<details>
  <summary>Details</summary>
Motivation: Modern HE schemes like CKKS lack systematic analysis of how soft errors (e.g., bit flips) propagate, especially under RNS/NTT optimizations, critical for maintaining integrity in privacy-sensitive applications.

Method: Theoretical and empirical analysis of CKKS fault tolerance focusing on client-side operations (encoding, encryption, decryption, decoding) under single bit-flip errors and RNS/NTT optimizations.

Result: Vanilla CKKS shows resilience to bit-flip errors, but RNS/NTT optimizations introduce significant fragility by amplifying error sensitivity in the encryption pipeline.

Conclusion: Characterizing error propagation in CKKS highlights vulnerabilities from performance optimizations, providing essential insights for developing error-resilient HE implementations with guaranteed integrity.

Abstract: Homomorphic Encryption (HE) enables computation on encrypted data without
decryption, making it a cornerstone of privacy-preserving computation in
untrusted environments. As HE sees growing adoption in sensitive applications
such as secure machine learning and confidential data analysis ensuring its
robustness against errors becomes critical. Faults (e.g., transmission errors,
hardware malfunctions, or synchronization failures) can corrupt encrypted data
and compromise the integrity of HE operations. However, the impact of soft
errors (such as bit flips) on modern HE schemes remains unexplored.
Specifically, the CKKS scheme-one of the most widely used HE schemes for
approximate arithmetic-lacks a systematic study of how such errors propagate
across its pipeline, particularly under optimizations like the Residue Number
System (RNS) and Number Theoretic Transform (NTT). This work bridges that gap
by presenting a theoretical and empirical analysis of CKKS's fault tolerance
under single bit-flip errors. We focus on client-side operations (encoding,
encryption, decryption, and decoding) and demonstrate that while the vanilla
CKKS scheme exhibits some resilience, performance optimizations (RNS/NTT)
introduce significant fragility, amplifying error sensitivity. By
characterizing these failure modes, we lay the groundwork for error-resilient
HE designs, ensuring both performance and integrity in privacy-critical
applications.

</details>


### [19] [Development and analysis of a secured VoIP system for surveillance activities](https://arxiv.org/abs/2507.21038)
*M. Matsive Ali*

Main category: cs.CR

TL;DR: A secure VoIP system is proposed using encrypted data transfer and IoT technology to mitigate man-in-the-middle attacks while maintaining signal integrity.


<details>
  <summary>Details</summary>
Motivation: Traditional telephony faces limitations as Voice over Internet Protocol (VoIP) emerges as a cost-effective communication method. However, security risks like man-in-the-middle attacks during IP network data transfers necessitate solutions to preserve signal integrity and confidentiality in daily communication.

Method: The authors developed an embedded system integrating an electret microphone (MAX9814), Embedded C, Node.js, Particle Photon microcontroller, and IoT technology. This system enables encrypted voice transmission within a router range, with a TCP server facilitating secure data download and local storage, followed by Google Drive uploads for remote access.

Result: The proposed system successfully achieves secure voice communication over the internet within a router range. It maintains the original signal integrity and demonstrates effective encrypted data transmission and storage through TCP servers and Google Drive integration.

Conclusion: The embedded VoIP system addresses security concerns in internet-based communication by employing encryption and a compact design. Its suitability for deployment in automobiles, surveillance, or covert listening tools highlights its practical value as a secure signal-verified solution in the expanding IoT landscape.

Abstract: Since the 1990s, the telephone has been the primary mode of communication.
However, Voice over Internet Protocol (VoIP), which is a highly straightforward
and affordable form of data transfer, is now becoming an important part of
daily communication. VoIP is the technology that makes it possible to send
speech and multimedia data packets across either a public or private IP
network. However, a cyberattack known as a man-in-the-middle attack poses a
serious concern in transferring data through any network. Therefore, the
authors have designed a system that sends voice over the internet within the
range of a router using encrypted data transfer. An embedded system comprising
an electret microphone, Embedded C, Node.js, Particle Photon microcontroller,
and Internet of Things (IoT) technology is developed. Due to its compact size,
this type of device may be incorporated into automobiles, surveillance systems,
or covert listening tools. The VoIP system gathers sound signals using the
MAX9814 microphone, while the Particle Photon microcontroller securely
transmits the data. Devices with access can download data from the VoIP systems
Transmission Control Protocol (TCP) server. The accessed device stores the
audio locally and uploads the corresponding data to Google Drive. This VoIP
system provides a secure method of communication while conserving the integrity
of the original signal.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [20] [AccessGuru: Leveraging LLMs to Detect and Correct Web Accessibility Violations in HTML Code](https://arxiv.org/abs/2507.19549)
*Nadeen Fathallah,Daniel Hernández,Steffen Staab*

Main category: cs.SE

TL;DR: The paper introduces AccessGuru, a method combining existing tools and LLMs to detect and correct web accessibility violations across three categories (Syntactic, Semantic, Layout). It outperforms prior work by reducing violation scores by 84% compared to existing methods' 50% maximum improvement, supported by a new benchmark of real-world accessibility issues.


<details>
  <summary>Details</summary>
Motivation: Most web pages violate accessibility guidelines, excluding users with disabilities and requiring manual effort. Automating detection and correction would reduce labor and increase inclusiveness by making access barriers disappear without developer intervention.

Method: 1) Developed a novel 3-category accessibility violation taxonomy (Syntactic, Semantic, Layout)
2) Created AccessGuru, a system integrating accessibility testing tools with LLMs
3) Implemented taxonomy-driven prompting strategies for violation correction
4) Constructed a benchmark of real-world accessibility violations with compliance and semantic accuracy metrics

Result: AccessGuru achieved:
- 84% average violation score decrease
- Benchmark evaluates syntactic/layout compliance and semantic accuracy
- Comparative analysis confirms superiority over prior methods that max at 50% improvement
- Taxonomy-based approach enables better systematic evaluation of accessibility fixes

Conclusion: The introduced taxonomy and AccessGuru provide a structured solution to the longstanding challenge of automated web accessibility correction. The 84% performance improvement demonstrates the effectiveness of combining specialized tools with LLMs through taxonomy-based prompting, establishing a new baseline for accessibility remediation systems.

Abstract: The vast majority of Web pages fail to comply with established Web
accessibility guidelines, excluding a range of users with diverse abilities
from interacting with their content. Making Web pages accessible to all users
requires dedicated expertise and additional manual efforts from Web page
providers. To lower their efforts and promote inclusiveness, we aim to
automatically detect and correct Web accessibility violations in HTML code.
While previous work has made progress in detecting certain types of
accessibility violations, the problem of automatically detecting and correcting
accessibility violations remains an open challenge that we address. We
introduce a novel taxonomy classifying Web accessibility violations into three
key categories - Syntactic, Semantic, and Layout. This taxonomy provides a
structured foundation for developing our detection and correction method and
redefining evaluation metrics. We propose a novel method, AccessGuru, which
combines existing accessibility testing tools and Large Language Models (LLMs)
to detect violations and applies taxonomy-driven prompting strategies to
correct all three categories. To evaluate these capabilities, we develop a
benchmark of real-world Web accessibility violations. Our benchmark quantifies
syntactic and layout compliance and judges semantic accuracy through
comparative analysis with human expert corrections. Evaluation against our
benchmark shows that AccessGuru achieves up to 84% average violation score
decrease, significantly outperforming prior methods that achieve at most 50%.

</details>


### [21] [LastMerge: A language-agnostic structured tool for code integration](https://arxiv.org/abs/2507.19687)
*Joao Pedro Duarte,Paulo Borba,Guilherme Cavalcanti*

Main category: cs.SE

TL;DR: LastMerge is a generic structured merge tool that reduces support effort for structured merging. Experiments with Java specific tools and their generic counterparts show that generic tools achieve comparable merge accuracy and performance, with fewer false positives and negatives, suggesting they can replace language-specific tools in industry.


<details>
  <summary>Details</summary>
Motivation: Structured AST-based merge tools improve accuracy but are language-specific and costly. To enable structured merging across diverse programming languages with lower effort, a generic solution is proposed.

Method: The study compares four merge tools (jDime, Spork, LastMerge, Mergiraf) by replaying merge scenarios from a significant dataset. Metrics include runtime, behavioral divergences, and merge accuracy.

Result: Generic tools show no significant accuracy impact compared to language-specific tools. LastMerge reduces false positives by 15% vs. jDime, and Mergiraf reduces false negatives by 42% vs. Spork. Runtime performance is comparable between generic and specific tools.

Conclusion: Generic structured merge tools can effectively replace language-specific implementations without compromising accuracy or performance, supporting broader industry adoption of structured merging through lower configuration cost.

Abstract: Unstructured line-based merge tools are widely used in practice. Structured
AST-based merge tools show significantly improved merge accuracy, but are
rarely used in practice because they are language specific and costly,
consequently not being available for many programming languages. To improve
merge accuracy for a wide range of languages, we propose LastMerge, a generic
structured merge tool that can be configured through a thin interface that
significantly reduces the effort of supporting structured merge. To understand
the impact that generic structured merge might have on merge accuracy and
performance, we run an experiment with four structured merge tools: two Java
specific tools, jDime and Spork, and their generic counterparts, respectively
LastMerge and Mergiraf. Using each tool, we replay merge scenarios from a
significant dataset, and collect data on runtime, behavioral divergences, and
merge accuracy. Our results show no evidence that generic structured merge
significantly impacts merge accuracy. Although we observe a difference rate of
approximately 10% between the Java specific tools and their generic
counterparts, most of the differences stem from implementation details and
could be avoided. We find that LastMerge reports 15% fewer false positives than
jDime while Mergiraf misses 42% fewer false negatives than Spork. Both generic
tools exhibit comparable runtime performance to the state of the art language
specific implementations. These results suggest that generic structured merge
tools can effectively replace language-specific ones, paving the way for
broader adoption of structured merge in industry.

</details>


### [22] [Refactoring $\neq$ Bug-Inducing: Improving Defect Prediction with Code Change Tactics Analysis](https://arxiv.org/abs/2507.19714)
*Feifei Niu,Junqian Shao,Christoph Mayr-Dorn,Liguo Huang,Wesley K. G. Assunção,Chuanyi Li,Jidong Ge,Alexander Egyed*

Main category: cs.SE

TL;DR: The paper addresses the impact of code refactoring on just-in-time defect prediction (JIT-DP), proposing a CAT analysis to categorize refactoring and its propagation, resulting in improved labeling accuracy (13.7%) and model performance (up to 43.2% recall, 32.5% F1-score).


<details>
  <summary>Details</summary>
Motivation: Prior JIT-DP research has ignored code refactoring despite its prevalence in commits mixed with bug-fixing and bug-inducing changes, introducing bias into model learning and evaluation.

Method: Investigated refactoring's impact on six JIT-DP methods, introduced Code chAnge Tactics (CAT) for refactoring classification, enhanced JIT-Defects4J dataset labeling accuracy by 13.7%, and integrated refactoring information into baseline approaches.

Result: Omitting refactoring data reduced model performance (18.6%–37.3% F1-score drop) while incorporating it improved recall (up to 43.2%) and F1-score (up to 32.5%).

Conclusion: Refactoring information must be included in JIT-DP methodology and evaluation; CAT offers broader applications for software maintenance analysis.

Abstract: Just-in-time defect prediction (JIT-DP) aims to predict the likelihood of
code changes resulting in software defects at an early stage. Although code
change metrics and semantic features have enhanced prediction accuracy, prior
research has largely ignored code refactoring during both the evaluation and
methodology phases, despite its prevalence. Refactoring and its propagation
often tangle with bug-fixing and bug-inducing changes within the same commit
and statement. Neglecting refactoring can introduce bias into the learning and
evaluation of JIT-DP models. To address this gap, we investigate the impact of
refactoring and its propagation on six state-of-the-art JIT-DP approaches. We
propose Code chAnge Tactics (CAT) analysis to categorize code refactoring and
its propagation, which improves labeling accuracy in the JIT-Defects4J dataset
by 13.7%. Our experiments reveal that failing to consider refactoring
information in the dataset can diminish the performance of models, particularly
semantic-based models, by 18.6% and 37.3% in F1-score. Additionally, we propose
integrating refactoring information to enhance six baseline approaches,
resulting in overall improvements in recall and F1-score, with increases of up
to 43.2% and 32.5%, respectively. Our research underscores the importance of
incorporating refactoring information in the methodology and evaluation of
JIT-DP. Furthermore, our CAT has broad applicability in analyzing refactoring
and its propagation for software maintenance.

</details>


### [23] [Clean Code In Practice: Challenges and Opportunities](https://arxiv.org/abs/2507.19721)
*Dapeng Yan,Wenjie Yang,Kui Liu,Zhiming Liu,Zhikuang Cai*

Main category: cs.SE

TL;DR: The paper investigates the integration of software reliability metrics with safety and security aspects to improve system robustness and provides actionable guidelines for practitioners.


<details>
  <summary>Details</summary>
Motivation: Modern software systems require reliable, safe, and secure practices, yet industry metrics often lack a unified framework to address these interrelated concerns.

Method: The authors conduct a comprehensive analysis of industry metrics and introduce a threat estimation framework combining reliability with safety and security perspectives.

Result: Integration of reliability metrics with safety/security considerations was shown to enhance robustness, and a practical framework for threat estimation was proposed.

Conclusion: By unifying reliability, safety, and security analyses, developers can build more resilient systems through the suggested guidelines and framework implementation.

Abstract: Reliability prediction is crucial for ensuring the safety and security of
software systems, especially in the context of industry practices. While
various metrics and measurements are employed to assess software reliability,
the complexity of modern systems necessitates a deeper understanding of how
these metrics interact with security and safety concerns. This paper explores
the interplay between software reliability, safety, and security, offering a
comprehensive analysis of key metrics and measurement techniques used in the
industry for reliability prediction. We identify critical threats to software
reliability and provide a threat estimation framework that incorporates both
safety and security aspects. Our findings suggest that integrating reliability
metrics with safety and security considerations can enhance the robustness of
software systems. Furthermore, we propose a set of actionable guidelines for
practitioners to improve their reliability prediction models while
simultaneously addressing the security and safety challenges of contemporary
software applications.

</details>


### [24] [Defining ethically sourced code generation](https://arxiv.org/abs/2507.19743)
*Zhuolin Xu,Chenglin Li,Qiushi Li,Shin Hwei Tan*

Main category: cs.SE

TL;DR: This paper introduces Ethically Sourced Code Generation (ES-CodeGen), a framework emphasizing ethical and sustainable practices in code generation model development. Through a literature review and survey of practitioners, it identifies 11 dimensions, highlights code quality as a critical new dimension, and reveals practitioner neglect of social-related ethical aspects.


<details>
  <summary>Details</summary>
Motivation: Code generation models require ethical consideration due to issues like licensing, privacy, fairness, and environmental impact. While attention to ethical AI has grown, it remains underexplored in the code generation domain, necessitating a structured approach like ES-CodeGen for responsible development.

Method: 1. Conducted a two-phase literature review of 803 AI-based code generation papers, narrowing to 71 relevant ones to identify 10 initial ES-CodeGen dimensions. 2. Surveyed 32 practitioners, including 6 GitHub issue submitters, to refine dimensions, assess consequences, and gather insights on artifacts/stages. 3. Analyzed post-survey reflections on adoption and awareness.

Result: 1. Finalized 11 ES-CodeGen dimensions (including new 'code quality' dimension). 2. Documented consequences, artifacts, and stages of ethical code generation. 3. Found practitioners often overlook social-related dimensions while emphasizing code quality. 4. Survey improved practitioners' understanding of ES-CodeGen, with mixed engagement with environmental/socio-ethical aspects.

Conclusion: The study establishes ES-CodeGen as a critical framework for ethical code generation practices, exposes gaps in addressing social-related ethics, and highlights areas for further research to align technical development with broader responsibilities in fairness, privacy, and long-term societal impacts.

Abstract: Several code generation models have been proposed to help reduce time and
effort in solving software-related tasks. To ensure responsible AI, there are
growing interests over various ethical issues (e.g., unclear licensing,
privacy, fairness, and environment impact). These studies have the overarching
goal of ensuring ethically sourced generation, which has gained growing
attentions in speech synthesis and image generation. In this paper, we
introduce the novel notion of Ethically Sourced Code Generation (ES-CodeGen) to
refer to managing all processes involved in code generation model development
from data collection to post-deployment via ethical and sustainable practices.
To build a taxonomy of ES-CodeGen, we perform a two-phase literature review
where we read 803 papers across various domains and specific to AI-based code
generation. We identified 71 relevant papers with 10 initial dimensions of
ES-CodeGen. To refine our dimensions and gain insights on consequences of
ES-CodeGen, we surveyed 32 practitioners, which include six developers who
submitted GitHub issues to opt-out from the Stack dataset (these impacted users
have real-world experience of ethically sourcing issues in code generation
models). The results lead to 11 dimensions of ES-CodeGen with a new dimension
on code quality as practitioners have noted its importance. We also identified
consequences, artifacts, and stages relevant to ES-CodeGen. Our post-survey
reflection showed that most practitioners tend to ignore social-related
dimensions despite their importance. Most practitioners either agreed or
strongly agreed that our survey help improve their understanding of ES-CodeGen.
Our study calls for attentions of various ethical issues towards ES-CodeGen.

</details>


### [25] [From Few-Label to Zero-Label: An Approach for Cross-System Log-Based Anomaly Detection with Meta-Learning](https://arxiv.org/abs/2507.19806)
*Xinlong Zhao,Tong Jia,Minghua He,Yihan Wu,Ying Li,Gang Huang*

Main category: cs.SE

TL;DR: FreeLog proposes a system-agnostic meta-learning approach for zero-label cross-system log anomaly detection, achieving performance comparable to state-of-the-art methods using small labeled data.


<details>
  <summary>Details</summary>
Motivation: Existing log anomaly detection methods require large labeled datasets or face cold-start issues with limited labeled target system data, limiting practical applicability.

Method: Introduces FreeLog, a meta-learning framework that constructs system-agnostic representations by training on diverse source systems. This eliminates dependency on target system labels through domain-invariant feature learning.

Result: Experiments on three public log datasets demonstrate FreeLog's performance matches SOTA methods that require 5-10% labeled data from the target system, validating zero-label cross-system feasibility.

Conclusion: FreeLog enables practical cross-system log anomaly detection without requiring labeled target system data, addressing cold-start limitations and offering a scalable solution for real-world applications.

Abstract: Log anomaly detection plays a critical role in ensuring the stability and
reliability of software systems. However, existing approaches rely on large
amounts of labeled log data, which poses significant challenges in real-world
applications. To address this issue, cross-system transfer has been identified
as a key research direction. State-of-the-art cross-system approaches achieve
promising performance with only a few labels from the target system. However,
their reliance on labeled target logs makes them susceptible to the cold-start
problem when labeled logs are insufficient. To overcome this limitation, we
explore a novel yet underexplored setting: zero-label cross-system log anomaly
detection, where the target system logs are entirely unlabeled. To this end, we
propose FreeLog, a system-agnostic representation meta-learning method that
eliminates the need for labeled target system logs, enabling cross-system log
anomaly detection under zero-label conditions. Experimental results on three
public log datasets demonstrate that FreeLog achieves performance comparable to
state-of-the-art methods that rely on a small amount of labeled data from the
target system.

</details>


### [26] [A Cooperative Approach for Knowledge-based Business Process Design in a Public Authority](https://arxiv.org/abs/2507.19842)
*Mohammad Azarijafari,Luisa Mich,Michele Missikoff,Oleg Missikoff*

Main category: cs.SE

TL;DR: A knowledge-based method for designing business processes without prior KE expertise


<details>
  <summary>Details</summary>
Motivation: Enterprises, including SMEs, need to adapt organizational structures and operations due to digital transformation to remain competitive.

Method: The method uses simple text-based knowledge artefacts and progresses to formal representations, guiding designers through structured steps to create a diagrammatic workflow.

Result: The approach enables a shared, collaborative design process for all stakeholders involved in business process design.

Conclusion: The method provides a practical tool for business experts to design business processes without needing Knowledge Engineering expertise, facilitating organizational adaptation.

Abstract: Enterprises are currently undergoing profound transformations due to the
unpostponable digital transformation. Then, to remain competitive, enterprises
must adapt their organisational structures and operations. This organisational
shift is also important for small and medium-sized enterprises. A key
innovation frontier is the adoption of process-oriented production models. This
paper presents a knowledge-based method to support business experts in
designing business processes. The method requires no prior expertise in
Knowledge Engineering and guides designers through a structured sequence of
steps to produce a diagrammatic workflow of the target process. The
construction of the knowledge base starts from simple, text-based, knowledge
artefacts and then progresses towards more structured, formal representations.
The approach has been conceived to allow a shared approach for all stakeholders
and actors who participate in the BP design.

</details>


### [27] [AgentMesh: A Cooperative Multi-Agent Generative AI Framework for Software Development Automation](https://arxiv.org/abs/2507.19902)
*Sourena Khanzadeh*

Main category: cs.SE

TL;DR: AgentMesh is a Python-based framework using multiple LLM-powered agents (Planner, Coder, Debugger, Reviewer) to automate software development tasks through collaborative task decomposition, code generation, iterative debugging, and quality validation.


<details>
  <summary>Details</summary>
Motivation: Traditional software development relies on human collaboration across complex phases. AgentMesh addresses this by leveraging cooperative LLM agents to automate the process, utilizing their collective strengths while mitigating individual limitations in complex multi-phase workflows.

Method: The framework employs four specialized agents working in sequence: Planner (task decomposition), Coder (code implementation), Debugger (automated testing/fixing), and Reviewer (quality validation). Architecture includes agent communication protocols, implementation details on prompt strategies, and workflow orchestration mechanisms.

Result: A case study demonstrates AgentMesh's capability to handle non-trivial development requests using sequential task planning, code generation, iterative debugging, and final code review, validating the framework's effectiveness in automating software development pipelines.

Conclusion: The framework shows promise but faces challenges in error propagation and context scaling. Future work focuses on enhancing robustness, scalability, and practicality for broader software engineering automation applications.

Abstract: Software development is a complex, multi-phase process traditionally
requiring collaboration among individuals with diverse expertise. We propose
AgentMesh, a Python-based framework that uses multiple cooperating LLM-powered
agents to automate software development tasks. In AgentMesh, specialized agents
- a Planner, Coder, Debugger, and Reviewer - work in concert to transform a
high-level requirement into fully realized code. The Planner agent first
decomposes user requests into concrete subtasks; the Coder agent implements
each subtask in code; the Debugger agent tests and fixes the code; and the
Reviewer agent validates the final output for correctness and quality. We
describe the architecture and design of these agents and their communication,
and provide implementation details including prompt strategies and workflow
orchestration. A case study illustrates AgentMesh handling a non-trivial
development request via sequential task planning, code generation, iterative
debugging, and final code review. We discuss how dividing responsibilities
among cooperative agents leverages the strengths of large language models while
mitigating single-agent limitations. Finally, we examine current limitations -
such as error propagation and context scaling - and outline future work toward
more robust, scalable multi-agent AI systems for software engineering
automation.

</details>


### [28] [CrossPL: Evaluating Large Language Models on Cross Programming Language Code Generation](https://arxiv.org/abs/2507.19904)
*Zhanhang Xiong,Dongxia Wang,Yuekang Li,Xinyuan An,Wenhai Wang*

Main category: cs.SE

TL;DR: CrossPL is the first benchmark designed to evaluate large language models (LLMs) in generating cross-programming-language (CPL) interoperable code through inter-process communication (IPC) scenarios. Key findings show state-of-the-art LLMs struggle with these tasks, emphasizing the need for targeted research. The benchmark includes 1,982 tasks across six languages and seven CPL techniques.


<details>
  <summary>Details</summary>
Motivation: Modern software systems increasingly require integration of components written in multiple programming languages. Existing LLM benchmarks systematically overlook this critical capability, which is essential for building complex systems via mechanisms like inter-process communication (IPC).

Method: Developers created CrossPL by (1) analyzing 19,169 multi-language GitHub repositories using 156 hand-crafted finite state machines (FSMs), and (2) building an LLM-based pipeline to automatically extract CPL code snippets, generate task instructions, and validate functional correctness through three annual evaluations via FSM-based validation.

Result: Evaluation of 14 general-purpose LLMs and 6 code-specialist models (2021-2024) showed even the highest-performing models struggle with CPL scenarios. All models exhibited significant performance gaps compared to a human baseline (95.3%) while maintaining functional correctness.

Conclusion: CrossPL reveals critical limitations in LLMs for CPL interoperability tasks and establishes baseline requirements for training and evaluation. The benchmark and associated code will be publicly released to enable future research improvements in this domain (availability: https://anonymous.4open.science/r/crosspl-2814).

Abstract: As large language models (LLMs) become increasingly embedded in software
engineering workflows, a critical capability remains underexplored: generating
correct code that enables cross-programming-language (CPL) interoperability.
This skill is essential for building complex systems that integrate components
written in multiple languages via mechanisms like inter-process communication
(IPC). To bridge this gap, we present CrossPL, the first benchmark designed to
systematically evaluate LLMs' ability to generate CPL-interoperating code.
CrossPL comprises 1,982 tasks centered around IPC, covering six widely-used
programming languages and seven representative CPL techniques. We construct
this benchmark by (i) analyzing 19,169 multi-language GitHub repositories using
156 hand-crafted finite state machines (FSMs), and (ii) developing an LLM-based
pipeline that automatically extracts CPL code snippets, generates task
instructions, and validates functional correctness. We evaluate 14
state-of-the-art general-purpose LLMs and 6 code-oriented LLMs released in the
past three years on CrossPL via FSM-based validation. Results reveal that even
the best-performing models struggle with CPL scenarios, underscoring the need
for more targeted research in this space. Our benchmark and code are available
at: https://anonymous.4open.science/r/crosspl-2814.

</details>


### [29] [The Impact of Fine-tuning Large Language Models on Automated Program Repair](https://arxiv.org/abs/2507.19909)
*Roman Macháček,Anastasiia Grishina,Max Hort,Leon Moonen*

Main category: cs.SE

TL;DR: The study evaluates the effectiveness of fine-tuning techniques on LLMs for Automated Program Repair (APR), finding that parameter-efficient methods outperform full fine-tuning by mitigating overfitting and computational costs.


<details>
  <summary>Details</summary>
Motivation: Training LLMs from scratch for APR is resource-intensive, while fine-tuning offers a cost-effective adaptation strategy. The paper addresses the need to identify optimal fine-tuning approaches for improving LLM-based APR methods.

Method: Empirical evaluation of six pre-trained code LLMs (CodeGen, CodeT5, StarCoder, DeepSeekCoder, Bloom, CodeLlama-2) across three APR benchmarks (QuixBugs, Defects4J, HumanEval-Java) using three training regimens: no fine-tuning, full fine-tuning, and parameter-efficient fine-tuning (LoRA and IA3).

Result: Full fine-tuning reduced performance due to data distribution misalignment and overfitting. Parameter-efficient fine-tuning (PEFT) maintained model robustness, constrained trainable parameters, and achieved superior APR results across all benchmarks.

Conclusion: Parameter-efficient fine-tuning methods are more effective for adapting LLMs to APR tasks compared to full fine-tuning, as they reduce computational costs and prevent performance degradation from overfitting.

Abstract: Automated Program Repair (APR) uses various tools and techniques to help
developers achieve functional and error-free code faster. In recent years,
Large Language Models (LLMs) have gained popularity as components in APR tool
chains because of their performance and flexibility. However, training such
models requires a significant amount of resources. Fine-tuning techniques have
been developed to adapt pre-trained LLMs to specific tasks, such as APR, and
enhance their performance at far lower computational costs than training from
scratch. In this study, we empirically investigate the impact of various
fine-tuning techniques on the performance of LLMs used for APR. Our experiments
provide insights into the performance of a selection of state-of-the-art LLMs
pre-trained on code. The evaluation is done on three popular APR benchmarks
(i.e., QuixBugs, Defects4J and HumanEval-Java) and considers six different LLMs
with varying parameter sizes (resp. CodeGen, CodeT5, StarCoder, DeepSeekCoder,
Bloom, and CodeLlama-2). We consider three training regimens: no fine-tuning,
full fine-tuning, and parameter-efficient fine-tuning (PEFT) using LoRA and
IA3. We observe that full fine-tuning techniques decrease the benchmarking
performance of various models due to different data distributions and
overfitting. By using parameter-efficient fine-tuning methods, we restrict
models in the amount of trainable parameters and achieve better results.
  Keywords: large language models, automated program repair,
parameter-efficient fine-tuning, AI4Code, AI4SE, ML4SE.

</details>


### [30] [Prometheus: Unified Knowledge Graphs for Issue Resolution in Multilingual Codebases](https://arxiv.org/abs/2507.19942)
*Zimin Chen,Yue Pan,Siyu Lu,Jiayi Xu,Claire Le Goues,Martin Monperrus,He Ye*

Main category: cs.SE

TL;DR: Prometheus is a multi-agent system for resolving real-world, multi-language issues in code repositories by constructing a unified knowledge graph, outperforming prior Python-specific methods in both benchmark settings and actual GitHub projects.


<details>
  <summary>Details</summary>
Motivation: Existing language model agents like SWE-agent and OpenHands primarily address Python-only issues within pre-defined SWE-bench containers, limiting their real-world applicability and multi-language repository support.

Method: Prometheus transforms code repositories into a unified knowledge graph using typed nodes and five general edge types, encoding files, abstract syntax trees, and natural language text. It leverages Neo4j for graph persistence and integrates the DeepSeek-V3 model to enable cross-language reasoning.

Result: Prometheus resolves 28.67% and 13.7% of issues on SWE-bench Lite and Multilingual datasets, with an average API cost of $0.23 and $0.38 per issue. It resolves 10 unique issues previously unaddressed and achieves cross-language effectiveness in seven programming languages.

Conclusion: Prometheus demonstrates superior performance in real-world and multi-language issue resolution compared to prior work, showcasing scalability and practical value for diverse codebases like LangChain and OpenHands. It is publicly available at https://github.com/Pantheon-temple/Prometheus.

Abstract: Language model (LM) agents, such as SWE-agent and OpenHands, have made
progress toward automated issue resolution. However, existing approaches are
often limited to Python-only issues and rely on pre-constructed containers in
SWE-bench with reproduced issues, restricting their applicability to real-world
and work for multi-language repositories. We present Prometheus, designed to
resolve real-world issues beyond benchmark settings. Prometheus is a
multi-agent system that transforms an entire code repository into a unified
knowledge graph to guide context retrieval for issue resolution. Prometheus
encodes files, abstract syntax trees, and natural language text into a graph of
typed nodes and five general edge types to support multiple programming
languages. Prometheus uses Neo4j for graph persistence, enabling scalable and
structured reasoning over large codebases. Integrated by the DeepSeek-V3 model,
Prometheus resolves 28.67% and 13.7% of issues on SWE-bench Lite and SWE-bench
Multilingual, respectively, with an average API cost of $0.23 and $0.38 per
issue. Prometheus resolves 10 unique issues not addressed by prior work and is
the first to demonstrate effectiveness across seven programming languages.
Moreover, it shows the ability to resolve real-world GitHub issues in the
LangChain and OpenHands repositories. We have open-sourced Prometheus at:
https://github.com/Pantheon-temple/Prometheus

</details>


### [31] [PDLogger: Automated Logging Framework for Practical Software Development](https://arxiv.org/abs/2507.19951)
*Shengcheng Duan,Yihua Xu,Sheng Zhang,Shen Wang,Yue Duan*

Main category: cs.SE

TL;DR: The paper introduces PDLogger, an end-to-end log generation technique for practical, multi-log scenarios using LLMs with three phases (log position prediction, generation, and refinement) to produce high-quality logs with improved precision and semantic context.


<details>
  <summary>Details</summary>
Motivation: Existing logging tools focus on isolated sub-tasks (e.g., single log positions, levels, or messages) and fail to handle real-world multi-log methods. They neglect inter-method semantics and rely on limited variable sets, resulting in incomplete or superficial logs.

Method: PDLogger employs: (1) Block-type-aware prompts for control-flow block log position prediction; (2) Backward program slicing with expanded variable extraction (member and external variables) to generate full log statements; (3) Level correction and context-sensitive deduplication during refinement.

Result: Evaluations on 3,113 Java log statements show PDLogger improves log-position precision (+139.0%), F1 (+69.2%), level accuracy (+82.3%), variable precision (+131.8%), and message quality (BERTScore +65.7%) over prior systems. It demonstrates robustness with mainstream LLMs.

Conclusion: PDLogger fills gaps in automated logging by addressing multi-log scenarios through structured prompting, inter-procedural context, and iterative refinement. Its open-source implementation enables future research and practical adoption of comprehensive log generation.

Abstract: Logging is indispensable for maintaining the reliability and diagnosability
of modern software, yet developers still struggle to decide where and how to
log effectively. Existing automated logging techniques focus on isolated
sub-tasks - predicting a single log position, level, or message - and therefore
cannot produce complete, high-quality log statements that reflect real-world
practice in which multiple logs often appear inside one method. They also
neglect deeper semantic dependencies among methods and consider only a narrow
set of candidate variables, leading to superficial or incomplete logs. In this
paper, we present PDLogger, the first end-to-end log generation technique
expressly designed for practical, multi-log scenarios. PDLogger operates in
three phases. (1) Log position prediction: block-type-aware structured prompts
guide a large language model (LLM) to suggest candidate positions across all
control-flow blocks of a method. (2) Log generation: backward program slicing
supplies precise inter-procedural control and data-dependency context, while an
expanded variable extractor captures both member and external function
expressions; the enriched prompt enables the LLM to emit a full log statement
(position, level, message, variables). (3) Log refinement: level correction and
context-sensitive deduplication prune false positives and redundant logs. We
evaluate PDLogger on 3,113 log statements drawn from two widely used Java
projects. Compared with the strongest prior systems, PDLogger improves
log-position precision by 139.0 percent, F1 by 69.2 percent, level accuracy by
82.3 percent, variable precision by 131.8 percent, and message quality
(BERTScore) by 65.7 percent. The framework consistently performs well with
different mainstream LLMs, demonstrating robustness and generality. PDLogger's
implementation is available as open source to foster future research and
adoption.

</details>


### [32] [The Effect of Pointer Analysis on Semantic Conflict Detection](https://arxiv.org/abs/2507.20081)
*Matheus Barbosa,Paulo Borba,Rodrigo Bonifácio,Victor Lira,Galileu Santos*

Main category: cs.SE

TL;DR: The paper investigates whether pointer analysis can reduce false positives in semantic conflict detection, finding that while timeouts and false positives decrease, false negatives increase significantly, prompting a need for hybrid approaches.


<details>
  <summary>Details</summary>
Motivation: Current merge tools fail to detect semantic conflicts when code changes are textually integrated but semantically incompatible. Existing static analysis methods for this problem have high false positive rates, motivating exploration of optimization strategies like pointer analysis.

Method: The authors implemented identical semantic conflict analyses with and without pointer analysis, evaluated them on two datasets, and compared accuracy metrics (recall, F1-score) and computational performance (timeouts).

Result: Pointer analysis significantly reduced timeouts and false positives, but led to prohibitive decreases in recall and F1-score due to increased false negatives, indicating a precision-recall trade-off.

Conclusion: Pointer analysis alone cannot resolve the challenges in semantic conflict detection; hybrid techniques combining strengths of both implementations are recommended to balance accuracy and performance.

Abstract: Current merge tools don't detect semantic conflicts, which occur when changes
from different developers are textually integrated but semantically interfere
with each other. Although researchers have proposed static analyses for
detecting semantic conflicts, these analyses suffer from significant false
positive rates. To understand whether such false positives could be reduced by
using pointer analysis in the implementation of semantic conflict static
analyses, we conduct an empirical study. We implement the same analysis with
and without pointer analysis, run them on two datasets, observe how often they
differ, and compare their accuracy and computational performance. Although
pointer analysis is known to improve precision in static analysis, we find that
its effect on semantic conflict detection can be drastic: we observe a
significant reduction in timeouts and false positives, but also a significant
increase in false negatives, with prohibitive drops in recall and F1-score.
These results suggest that, in the context of semantic conflict detection, we
should explore hybrid analysis techniques, combining aspects of both
implementations we compare in our study.

</details>


### [33] [From First Use to Final Commit: Studying the Evolution of Multi-CI Service Adoption](https://arxiv.org/abs/2507.20095)
*Nitika Chopra,Taher A. Ghaleb*

Main category: cs.SE

TL;DR: This paper investigates multi-CI adoption in 18,924 Java projects, finding that nearly 20% use multiple CI services over time, with Travis CI being the most frequently replaced and GitHub Actions gaining prominence. It highlights the need for tools to support CI service migration.


<details>
  <summary>Details</summary>
Motivation: Existing research focuses on individual CI services in isolation, but how projects co-adopt or migrate between multiple services over time remains understudied. This work addresses the gap by analyzing historical CI adoption patterns to inform strategies for service coordination and migration.

Method: The study analyzes historical adoption data (Jan 2008-Dec 2024) of 18,924 Java projects on GitHub using eight CI services (Travis CI, AppVeyor, CircleCI, Azure Pipelines, GitHub Actions, Bitbucket, GitLab CI, Cirrus CI). It examines co-adoption frequencies, replacement patterns, and maintenance activity variations across services.

Result: 19.5% of projects adopted multiple CI services simultaneously, indicating migration rather than coexistence. Travis CI had the highest de-adoption rate (39.4%) and projects with GitHub Actions had fewer commits/pull requests compared to other services, suggesting potential learning curves in adoption.

Conclusion: This preliminary study establishes multi-CI adoption as a common practice in software evolution. It provides foundational insights for future research and demonstrates the need for practical tools to manage CI service selection, coordination, and migration in dynamic development environments.

Abstract: Continuous Integration (CI) services, such as GitHub Actions and Travis CI,
are widely adopted in open-source development to automate testing and
deployment. Though existing research often examines individual services in
isolation, it remains unclear how projects adopt and transition between
multiple services over time. To understand how CI adoption is evolving across
services, we present a preliminary study analyzing the historical CI adoption
of 18,924 Java projects hosted on GitHub between January 2008 and December
2024, adopting at least one of eight CI services, namely Travis CI, AppVeyor,
CircleCI, Azure Pipelines, GitHub Actions, Bitbucket, GitLab CI, and Cirrus CI.
Specifically, we investigate: (1) how frequently CI services are co-adopted or
replaced, and (2) how maintenance activity varies across different services.
Our analysis shows that the use of multiple CI services within the same project
is a recurring pattern observed in nearly one in five projects, often
reflecting migration across CI services. Our study is among the first to
examine multi-CI adoption in practice, offering new insights for future
research and highlighting the need for strategies and tools to support service
selection, coordination, and migration in evolving CI environments.

</details>


### [34] [Learning to Align Human Code Preferences](https://arxiv.org/abs/2507.20109)
*Xin Yin,Chao Ni,Liushan Chen,Xiaohu Yang*

Main category: cs.SE

TL;DR: This paper proposes Adaptive Preference Optimization (APO), a dynamic training strategycombining Supervised Fine-Tuning (SFT) and Direct Preference Optimization (DPO) to improveLLM alignment with diverse code preferences. Extensive experiments show APO consistently outperformsexisting SFT and S&D strategies in six code preference tasks.


<details>
  <summary>Details</summary>
Motivation: The paper addresses the unclear optimal training strategy for aligning LLMs with differencing code preference scenarios, aiming to provide theoretical foundations and practical guidance for selecting SFT, DPO, or combined approaches.

Method: The authors conduct (1) theoretical analysis to form hypotheses about when SFT excels versuswhen S&D should be used, and (2) empirical experiments by proposing APO which: 
- Dynamically amplifies preferred responses
- Suppresses dispreferred responses
- Encourages exploration of superior solutions through a staged training approach.
They evaluate via controlled preference alignment scenarios.

Result: Experiments across six code preference tasks validate the hypotheses and demonstrate that APO: 
- Matches or surpasses existing SFT and S&D strategies consistently 
- Outperforms baseline methods in scenarios without objectively verifiable optimal solutions 
- Achieves state-of-the-art alignment performance through adaptive response amplification/suppression

Conclusion: The paper concludes that APO provides both theoretical foundations and practical guidance forLLM preference alignment in code generation, showing the value of dynamic combination of SFT and DPO for handling diverse code preference scenarios and their specific requirements.

Abstract: Large Language Models (LLMs) have demonstrated remarkable potential in
automating software development tasks. While recent advances leverage
Supervised Fine-Tuning (SFT) and Direct Preference Optimization (DPO) to align
models with human preferences, the optimal training strategy remains unclear
across diverse code preference scenarios. This paper systematically
investigates the roles of SFT and DPO in aligning LLMs with different code
preferences. Through both theoretical analysis and empirical observation, we
hypothesize that SFT excels in scenarios with objectively verifiable optimal
solutions, while applying SFT followed by DPO (S&D) enables models to explore
superior solutions in scenarios without objectively verifiable optimal
solutions. Based on the analysis and experimental evidence, we propose Adaptive
Preference Optimization (APO), a dynamic integration approach that adaptively
amplifies preferred responses, suppresses dispreferred ones, and encourages
exploration of potentially superior solutions during training. Extensive
experiments across six representative code preference tasks validate our
theoretical hypotheses and demonstrate that APO consistently matches or
surpasses the performance of existing SFT and S&D strategies. Our work provides
both theoretical foundations and practical guidance for selecting appropriate
training strategies in different code preference alignment scenarios.

</details>


### [35] [From Prompt to Pipeline: Large Language Models for Scientific Workflow Development in Bioinformatics](https://arxiv.org/abs/2507.20122)
*Khairul Alam,Banani Roy*

Main category: cs.SE

TL;DR: This paper evaluates the ability of LLMs (GPT-4o, Gemini 2.5 Flash, DeepSeek-V3) to generate accurate bioinformatics workflows for Galaxy and Nextflow platforms, finding that prompting strategies and model characteristics impact success, with Gemini excelling in Galaxy and DeepSeek in Nextflow.


<details>
  <summary>Details</summary>
Motivation: Scientific Workflow Systems (SWSs) like Galaxy and Nextflow are critical for scalable bioinformatics analysis, but creating workflows remains challenging for non-programmers. This study aims to determine if LLMs can democratize workflow development and identify effective prompting strategies.

Method: The authors tested three LLMs across diverse bioinformatics tasks (SNP analysis, RNA-seq, etc.) on Galaxy and Nextflow, comparing generated workflows to community-curated baselines using expert assessments. They systematically evaluated prompting strategies like role-based instructions and chain-of-thought reasoning.

Result: Gemini 2.5 Flash outperformed in Galaxy workflow generation with better completeness/correctness. DeepSeek-V3 excelled at Nextflow with detailed output but occasional verbosity. Structured prompts and chain-of-thought approaches improved results across platforms.

Conclusion: LLMs show promise in reducing barriers to bioinformatics workflow development, particularly when optimized through prompt engineering. Platform-specific model selection (Gemini for Galaxy, DeepSeek for Nextflow) and technical focus are key to usability improvements.

Abstract: The increasing complexity of bioinformatics data analysis has made Scientific
Workflow Systems (SWSs) like Galaxy and Nextflow essential for enabling
scalable, reproducible, and automated workflows. However, creating and
understanding these workflows remains challenging, particularly for domain
experts without programming expertise. This study investigates whether modern
Large Language Models (LLMs), GPT-4o, Gemini 2.5 Flash, and DeepSeek-V3, can
support the generation of accurate, complete, and usable bioinformatics
workflows, and examines which prompting strategies most effectively guide this
process. We evaluate these models using diverse tasks such as SNP analysis,
RNA-seq, DNA methylation, and data retrieval, spanning both graphical (Galaxy)
and script-based (Nextflow) platforms. Expert reviewers assess the generated
workflows against community-curated baselines from the Galaxy Training Network
and nf-core repositories. The results show that Gemini 2.5 Flash excels in
generating Galaxy workflows, while DeepSeek-V3 performs strongly in Nextflow.
Prompting strategies significantly impact quality, with role-based and
chain-of-thought prompts improving completeness and correctness. While GPT-4o
benefits from structured inputs, DeepSeek-V3 offers rich technical detail,
albeit with some verbosity. Overall, the findings highlight the potential of
LLMs to lower the barrier for workflow development, improve reproducibility,
and democratize access to computational tools in bioinformatics, especially
when combined with thoughtful prompt engineering.

</details>


### [36] [Relating System Safety and Machine Learnt Model Performance](https://arxiv.org/abs/2507.20135)
*Ganesh Pai*

Main category: cs.SE

TL;DR: This paper proposes a method to derive safety-related performance requirements for machine learning components (MLCs) in aeronautical systems, using an abstraction of required behavior to align model metrics with system safety objectives.


<details>
  <summary>Details</summary>
Motivation: Integrating ML into safety-critical aeronautical applications requires clear linkage between system safety objectives and model performance metrics, which is currently lacking.

Method: 1. Abstract required MLC behavior (e.g., object detection in emergency braking systems) into a simplified model. 2. Derive quantitative safety-related performance requirements, metrics, and targets for both the MLC and its underlying deep neural network based on system-level safety assessments.

Result: Initial framework that translates safety assessment outcomes into specific model performance benchmarks (e.g., false negative rates, response time constraints) for deep neural networks in aircraft emergency systems, ensuring safety compliance.

Conclusion: The method provides a systematic approach to ensure ML safety compliance in aviation, with validity grounded in assumption analyses and verification implication considerations, though constrained by abstraction simplifications.

Abstract: The prediction quality of machine learnt models and the functionality they
ultimately enable (e.g., object detection), is typically evaluated using a
variety of quantitative metrics that are specified in the associated model
performance requirements. When integrating such models into aeronautical
applications, a top-down safety assessment process must influence both the
model performance metrics selected, and their acceptable range of values.
Often, however, the relationship of system safety objectives to model
performance requirements and the associated metrics is unclear. Using an
example of an aircraft emergency braking system containing a machine learnt
component (MLC) responsible for object detection and alerting, this paper first
describes a simple abstraction of the required MLC behavior. Then, based on
that abstraction, an initial method is given to derive the minimum
safety-related performance requirements, the associated metrics, and their
targets for the both MLC and its underlying deep neural network, such that they
meet the quantitative safety objectives obtained from the safety assessment
process. We give rationale as to why the proposed method should be considered
valid, also clarifying the assumptions made, the constraints on applicability,
and the implications for verification.

</details>


### [37] [Strategic Motivators for Ethical AI System Development: An Empirical and Holistic Model](https://arxiv.org/abs/2507.20218)
*Muhammad Azeem Akbar,Arif Ali Khan,Saima Rafi,Damian Kedziora,Sami Hyrynsalmi*

Main category: cs.SE

TL;DR: This study identifies and prioritizes motivators for ethical AI development using Multivocal Literature Review (MLR), Interpretive Structural Modeling (ISM), MICMAC analysis, and Fuzzy TOPSIS. Eight motivator categories (e.g., Human Resource, Coordination) were found to influence ethical AI practices, with strategic alignment and governance integration recommended.


<details>
  <summary>Details</summary>
Motivation: AI's transformative potential demands responsible development to avoid unintended societal and industrial consequences. The study addresses the need to understand key motivators that promote ethical practices in AI systems.

Method: Multivocal Literature Review (MLR) and questionnaire-based survey to gather data; ISM to explore relationships between motivator categories; MICMAC analysis to classify categories by driving/dependence power; Fuzzy TOPSIS to rank motivators by importance.

Result: 20 key motivators grouped into eight categories. ISM showed 'Human Resource' and 'Coordination' strongly influence other factors. MICMAC identified four categories (Human Resource, Coordination, Stakeholders, Strategy & Matrices) as high-driving, low-dependence. Fuzzy TOPSIS ranked motivators like team diversity, AI governance bodies, oversight leaders, and data privacy as most critical.

Conclusion: Organizations should align strategies, policies, governance models, and development frameworks with these prioritized motivators to foster ethical AI adoption. Independent motivator categories require proactive integration to maximize their driving impact.

Abstract: Artificial Intelligence (AI) presents transformative opportunities for
industries and society, but its responsible development is essential to prevent
unintended consequences. Ethically sound AI systems demand strategic planning,
strong governance, and an understanding of the key drivers that promote
responsible practices. This study aims to identify and prioritize the
motivators that drive the ethical development of AI systems. A Multivocal
Literature Review (MLR) and a questionnaire-based survey were conducted to
capture current practices in ethical AI. We applied Interpretive Structure
Modeling (ISM) to explore the relationships between motivator categories,
followed by MICMAC analysis to classify them by their driving and dependence
power. Fuzzy TOPSIS was used to rank these motivators by importance. Twenty key
motivators were identified and grouped into eight categories: Human Resource,
Knowledge Integration, Coordination, Project Administration, Standards,
Technology Factor, Stakeholders, and Strategy & Matrices. ISM results showed
that 'Human Resource' and 'Coordination' heavily influence other factors.
MICMAC analysis placed categories like Human Resource (CA1), Coordination
(CA3), Stakeholders (CA7), and Strategy & Matrices (CA8) in the independent
cluster, indicating high driving but low dependence power. Fuzzy TOPSIS ranked
motivators such as promoting team diversity, establishing AI governance bodies,
appointing oversight leaders, and ensuring data privacy as most critical. To
support ethical AI adoption, organizations should align their strategies with
these motivators and integrate them into their policies, governance models, and
development frameworks.

</details>


### [38] [Beyond Binary Moderation: Identifying Fine-Grained Sexist and Misogynistic Behavior on GitHub with Large Language Models](https://arxiv.org/abs/2507.20358)
*Tanni Dev,Sayma Sultana,Amiangshu Bosu*

Main category: cs.SE

TL;DR: A paper introducing a multi-class LLM-based framework to detect 12 types of sexist/misogynistic comments on GitHub, achieving better performance than baselines but struggling with nuanced context.


<details>
  <summary>Details</summary>
Motivation: Current moderation tools (keyword filters/binary classifiers) fail to detect subtle, context-dependent sexist/misogynistic behavior, leading to exclusion in technical communities.

Method: Instruction-tuned LLM with systematic 20-iteration prompt refinement, tested on 1,440 labeled GitHub comments across 12 categories using precision, recall, F1, and MCC metrics.

Result: GPT-4o with Prompt 19 achieved MCC 0.501 vs. baseline approaches, with low false positives but reliability issues in nuanced contexts.

Conclusion: Carefully designed prompts enhance LLM accuracy in detecting sexism/misogyny, enabling practical moderation solutions for developer platforms.

Abstract: Background: Sexist and misogynistic behavior significantly hinders inclusion
in technical communities like GitHub, causing developers, especially
minorities, to leave due to subtle biases and microaggressions. Current
moderation tools primarily rely on keyword filtering or binary classifiers,
limiting their ability to detect nuanced harm effectively.
  Aims: This study introduces a fine-grained, multi-class classification
framework that leverages instruction-tuned Large Language Models (LLMs) to
identify twelve distinct categories of sexist and misogynistic comments on
GitHub.
  Method: We utilized an instruction-tuned LLM-based framework with systematic
prompt refinement across 20 iterations, evaluated on 1,440 labeled GitHub
comments across twelve sexism/misogyny categories. Model performances were
rigorously compared using precision, recall, F1-score, and the Matthews
Correlation Coefficient (MCC).
  Results: Our optimized approach (GPT-4o with Prompt 19) achieved an MCC of
0.501, significantly outperforming baseline approaches. While this model had
low false positives, it struggled to interpret nuanced, context-dependent
sexism and misogyny reliably.
  Conclusion: Well-designed prompts with clear definitions and structured
outputs significantly improve the accuracy and interpretability of sexism
detection, enabling precise and practical moderation on developer platforms
like GitHub.

</details>


### [39] [CIgrate: Automating CI Service Migration with Large Language Models](https://arxiv.org/abs/2507.20402)
*Md Nazmul Hossain,Taher A. Ghaleb*

Main category: cs.SE

TL;DR: This paper proposes CIgrate, an LLM-based framework to improve the accuracy and generalizability of CI configuration migrations between services, addressing limitations in existing rule-based approaches like CIMig.


<details>
  <summary>Details</summary>
Motivation: Manual CI service migration is error-prone and time-consuming. Existing rule-based tools (e.g., CIMig) achieve low accuracy, limiting their feasibility despite the recurring need in open-source development.

Method: The study introduces CIgrate, leveraging large language models for automated CI migration. It evaluates performance through (a) zero-shot/few-shot prompting and (b) fine-tuning on existing migration datasets. Developer feedback on quality and usability will also be analyzed.

Result: Expected contributions include the first LLM-powered CI migration approach, a comparative evaluation against CIMig, and insights into using LLMs for software configuration evolution.

Conclusion: LLMs demonstrate potential to outperform rule-based techniques in CI migration, offering higher accuracy and generalizability. The results could establish a new foundation for automated configuration adaptation in evolving development environments.

Abstract: Continuous Integration (CI) configurations often need to be migrated between
services (e.g., Travis CI to GitHub Actions) as projects evolve, due to changes
in service capabilities, usage limits, or service deprecation. Previous studies
reported that migration across CI services is a recurring need in open-source
development. However, manual migration can be time-consuming and error-prone.
The state-of-the-art approach, CIMig, addresses this challenge by analyzing
past migration examples to create service-specific rules and produce equivalent
configurations across CI services. However, its relatively low accuracy raises
concerns about the overall feasibility of automated CI migration using
rule-based techniques alone. Meanwhile, Large Language Models (LLMs) have
demonstrated strong capabilities in code generation and transformation tasks,
suggesting potential to improve the automation, usability, and generalizability
of CI configuration migration. This registered report presents a study in which
we aim to assess whether CI migration can be improved using LLMs. To this end,
we propose CIgrate, an LLM-based framework for automatically migrating CI
configurations. We plan to evaluate the performance of CIgrate compared to
CIMig as a baseline, in different setups (a) zero-shot/few-shot prompting of
LLMs for configuration migration and (b) fine-tuning an LLM on a dataset of
already established CI service migrations. We will also seek developer feedback
on the quality and usability of the generated configurations. We formulate
research questions focusing on the accuracy of LLM-generated migrations versus
ground truth and the output of CIMig. The expected contributions include the
first LLM-powered approach for CI service migration, a comparative evaluation
of its effectiveness compared to rule-based approaches, and insight into
leveraging LLMs to support software configuration evolution.

</details>


### [40] [Testing Is Not Boring: Characterizing Challenge in Software Testing Tasks](https://arxiv.org/abs/2507.20407)
*Davi Gama Hardman,Cesar França,Brody Stuart-Verner,Ronnie de Souza Santos*

Main category: cs.SE

TL;DR: The paper challenges the perception of software testing as a low-skill activity, demonstrating through a study that testing requires creativity, adaptability, and problem-solving, with task complexity significantly impacting professional motivation and engagement.


<details>
  <summary>Details</summary>
Motivation: To address the misperception of software testing and to understand how different task characteristics in testing influence professionals' motivational states and job satisfaction.

Method: The authors conducted an exploratory study with software testing professionals to analyze how they perceive and handle challenging tasks within their roles, using qualitative methods to uncover common themes.

Result: Findings indicate that tasks with creative elements and opportunities for learning enhance professional motivation, while insufficient challenges or excessive demands lead to frustration and disengagement.

Conclusion: Balancing task complexity is crucial for maintaining motivation in software testing roles, and the field should be recognized as dynamic and intellectually stimulating rather than routine.

Abstract: As software systems continue to grow in complexity, testing has become a
fundamental part of ensuring the quality and reliability of software products.
Yet, software testing is still often perceived, both in industry and academia,
as a repetitive, low-skill activity. This perception fails to recognize the
creativity, problem-solving, and adaptability required in testing work. Tasks
such as designing complex test cases, automating testing processes, and
handling shifting requirements illustrate the challenges testing professionals
regularly face. To better understand these experiences, we conducted a study
with software testing professionals to explore the nature of challenging tasks
in software testing and how they affect these professionals. Our findings show
that tasks involving creativity, ongoing learning, and time pressure are often
seen as motivating and rewarding. On the other hand, a lack of challenge or
overwhelming demands can lead to frustration and disengagement. These findings
demonstrate the importance of balancing task complexity to sustain motivation
and present software testing as a dynamic and intellectually engaging field.

</details>


### [41] [When Prompts Go Wrong: Evaluating Code Model Robustness to Ambiguous, Contradictory, and Incomplete Task Descriptions](https://arxiv.org/abs/2507.20439)
*Maya Larbi,Amal Akli,Mike Papadakis,Rihab Bouyousfi,Maxime Cordy,Federica Sarro,Yves Le Traon*

Main category: cs.SE

TL;DR: This paper studies how state-of-the-art code generation models handle unclear task descriptions, showing significant performance degradation with flawed inputs and emphasizing the need for robust models in real-world scenarios.


<details>
  <summary>Details</summary>
Motivation: Task descriptions in practical software development often contain ambiguities, incompleteness, or contradictions, yet existing benchmarks evaluate models under idealized conditions that do not reflect these real challenges.

Method: The authors extended HumanEval and MBPP benchmarks by introducing realistic task description flaws via guided mutation strategies, then evaluated LLMs of varying sizes/architectures on functional correctness and failure modes.

Result: Findings reveal that minor description flaws cause substantial performance drops, with models failing to resolve contradictions (leading to logical errors). Larger models show greater resilience but still struggle under imperfect conditions.

Conclusion: Current code generation models lack robustness to natural user task imperfections. The study highlights the need for training strategies to address description clarity issues, realistic evaluation benchmarks, and deployment safeguards in practical development settings.

Abstract: Large Language Models (LLMs) have demonstrated impressive performance in code
generation tasks under idealized conditions, where task descriptions are clear
and precise. However, in practice, task descriptions frequently exhibit
ambiguity, incompleteness, or internal contradictions. In this paper, we
present the first empirical study examining the robustness of state-of-the-art
code generation models when faced with such unclear task descriptions. We
extend the HumanEval and MBPP benchmarks by systematically introducing
realistic task descriptions flaws through guided mutation strategies, producing
a dataset that mirrors the messiness of informal developer instructions. We
evaluate multiple LLMs of varying sizes and architectures, analyzing their
functional correctness and failure modes across task descriptions categories.
Our findings reveal that even minor imperfections in task description phrasing
can cause significant performance degradation, with contradictory task
descriptions resulting in numerous logical errors. Moreover, while larger
models tend to be more resilient than smaller variants, they are not immune to
the challenges posed by unclear requirements. We further analyze semantic error
patterns and identify correlations between description clarity, model behavior,
and error types. Our results underscore the critical need for developing LLMs
that are not only powerful but also robust to the imperfections inherent in
natural user tasks, highlighting important considerations for improving model
training strategies, designing more realistic evaluation benchmarks, and
ensuring reliable deployment in practical software development environments.

</details>


### [42] [Distinguishing Quantum Software Bugs from Hardware Noise: A Statistical Approach](https://arxiv.org/abs/2507.20475)
*Ahmik Virani,Devraj,Anirudh Suresh,Lei Zhang,M V Panduranga Rao*

Main category: cs.SE

TL;DR: A statistical approach to differentiate quantum software bugs from hardware noise in NISQ-era computing, validated with Grover's, Deutsch-Jozsa, and Simon's algorithms.


<details>
  <summary>Details</summary>
Motivation: In the NISQ era, quantum software bugs and hardware noise are difficult to distinguish using classical debugging methods due to quantum computation's stochastic nature.

Method: Proposes a statistical method leveraging probabilistic metrics to analyze quantum program behavior, combined with empirical evaluation on established quantum algorithms.

Result: Experimental validation demonstrated the approach's efficacy in identifying and classifying issues in quantum programs using Grover's, Deutsch-Jozsa, and Simon's algorithms.

Conclusion: Provides quantum developers with a reliable analytical framework to address challenges posed by hardware noise in the NISQ era through statistical debugging techniques.

Abstract: Quantum computing in the Noisy Intermediate-Scale Quantum (NISQ) era presents
significant challenges in differentiating quantum software bugs from hardware
noise. Traditional debugging techniques from classical software engineering
cannot directly resolve this issue due to the inherently stochastic nature of
quantum computation mixed with noises from NISQ computers. To address this gap,
we propose a statistical approach leveraging probabilistic metrics to
differentiate between quantum software bugs and hardware noise. We evaluate our
methodology empirically using well-known quantum algorithms, including Grover's
algorithm, Deutsch-Jozsa algorithm, and Simon's algorithm. Experimental results
demonstrate the efficacy and practical applicability of our approach, providing
quantum software developers with a reliable analytical tool to identify and
classify unexpected behavior in quantum programs.

</details>


### [43] [VDGraph: A Graph-Theoretic Approach to Unlock Insights from SBOM and SCA Data](https://arxiv.org/abs/2507.20502)
*Howell Xia,Jonah Gluck,Sevval Simsek,David Sastre Medina,David Starobinski*

Main category: cs.SE

TL;DR: The paper introduces VDGraph, a knowledge graph methodology integrating SBOM and SCA data to analyze dependencies and vulnerabilities in software projects.


<details>
  <summary>Details</summary>
Motivation: Modern software supply chains are complex, requiring tools like SBOMs and SCA to manage dependencies and vulnerabilities, yet integration between them is limited, creating a need for unified solutions.

Method: VDGraph constructs a graph representation combining SBOM (CycloneDX Maven plugin) and SCA (Google's OSV-Scanner) outputs, addressing conflicts between data sources and enabling query-based analysis of dependency-vulnerability relationships.

Result: Evaluation on 21 Java projects revealed concentrated risk points (severe vulnerabilities accessible via multiple paths) and showed vulnerabilities primarily appear at dependency depth three or higher, where transitive dependencies are more vulnerable.

Conclusion: VDGraph provides a scalable, graph-theoretic approach to enhance visibility into vulnerability propagation in complex dependencies, utilizing open standards with Neo4j for automated analysis of real-world software.

Abstract: The high complexity of modern software supply chains necessitates tools such
as Software Bill of Materials (SBOMs) to manage component dependencies, and
Software Composition Analysis (SCA) tools to identify vulnerabilities. While
there exists limited integration between SBOMs and SCA tools, a unified view of
complex dependency-vulnerability relationships remains elusive. In this paper,
we introduce VDGraph, a novel knowledge graph-based methodology for integrating
vulnerability and dependency data into a holistic view. VDGraph consolidates
SBOM and SCA outputs into a graph representation of software projects'
dependencies and vulnerabilities. We provide a formal description and analysis
of the theoretical properties of VDGraph and present solutions to manage
possible conflicts between the SBOM and SCA data. We further introduce and
evaluate a practical, proof-of-concept implementation of VDGraph using two
popular SBOM and SCA tools, namely CycloneDX Maven plugin and Google's
OSV-Scanner. We apply VDGraph on 21 popular Java projects. Through the
formulation of appropriate queries on the graphs, we uncover the existence of
concentrated risk points (i.e., vulnerable components of high severity
reachable through numerous dependency paths). We further show that
vulnerabilities predominantly emerge at a depth of three dependency levels or
higher, indicating that direct or secondary dependencies exhibit lower
vulnerability density and tend to be more secure. Thus, VDGraph contributes a
graph-theoretic methodology that improves visibility into how vulnerabilities
propagate through complex, transitive dependencies. Moreover, our
implementation, which combines open SBOM and SCA standards with Neo4j, lays a
foundation for scalable and automated analysis across real-world projects.

</details>


### [44] [Repairing vulnerabilities without invisible hands. A differentiated replication study on LLMs](https://arxiv.org/abs/2507.20977)
*Maria Camporese,Fabio Massacci*

Main category: cs.SE

TL;DR: The study tests whether large language models (LLMs) in Automated Vulnerability Repair (AVR) rely on hidden factors like training-data leakage or perfect fault localization by introducing deliberate errors in vulnerability locations and evaluating repair accuracy with a two-LLM pipeline and statistical analysis.


<details>
  <summary>Details</summary>
Motivation: Recent success of LLMs in AVR may be due to hidden factors rather than true understanding. The paper aims to replicate prior studies under controlled conditions to isolate these factors and assess LLM capabilities.

Method: A pipeline repair system that introduces line offset errors in vulnerable code using Vul4J and VJTrans benchmarks. Two LLMs are used: one for generating patches and another for review. Validation includes regression testing, vulnerability-specific checks, manual audits, and Agresti-Coull-Wilson error rate estimation.

Result: The study found that while some LLM-generated patches remain correct despite localization errors, performance degradation correlates with offset size, and manual audits revealed variability in fix quality when original training cues are obscured.

Conclusion: LLMs demonstrate partial capability beyond mere memorization in AVR tasks, but their effectiveness depends on accurate fault localization. Training/data leakage remains a concern, and further research is needed to improve robustness to localization errors.

Abstract: Background: Automated Vulnerability Repair (AVR) is a fast-growing branch of
program repair. Recent studies show that large language models (LLMs)
outperform traditional techniques, extending their success beyond code
generation and fault detection.
  Hypothesis: These gains may be driven by hidden factors -- "invisible hands"
such as training-data leakage or perfect fault localization -- that let an LLM
reproduce human-authored fixes for the same code.
  Objective: We replicate prior AVR studies under controlled conditions by
deliberately adding errors to the reported vulnerability location in the
prompt. If LLMs merely regurgitate memorized fixes, both small and large
localization errors should yield the same number of correct patches, because
any offset should divert the model from the original fix.
  Method: Our pipeline repairs vulnerabilities from the Vul4J and VJTrans
benchmarks after shifting the fault location by n lines from the ground truth.
A first LLM generates a patch, a second LLM reviews it, and we validate the
result with regression and proof-of-vulnerability tests. Finally, we manually
audit a sample of patches and estimate the error rate with the
Agresti-Coull-Wilson method.

</details>


### [45] [GeoJSEval: An Automated Evaluation Framework for Large Language Models on JavaScript-Based Geospatial Computation and Visualization Code Generation](https://arxiv.org/abs/2507.20553)
*Guanyu Chen,Haoyue Jiao,Shuyang Hou,Ziqi Liu,Lutong Xie,Shaowen Wu,Huayi Wu,Xuefeng Guan,Zhipeng Gui*

Main category: cs.SE

TL;DR: The paper introduces GeoJSEval, a multimodal evaluation framework for assessing large language models (LLMs) in JavaScript-based geospatial code generation, highlighting performance disparities across 18 LLMs.


<details>
  <summary>Details</summary>
Motivation: The rapid adoption of LLMs in code generation necessitates systematic evaluation methods for geospatial tasks, where JavaScript ecosystems and library orchestration impose unique challenges on model capabilities.

Method: GeoJSEval features a standardized test suite (GeoJSEval-Bench) with 432 function-level tasks and 2,071 test cases across five JavaScript geospatial libraries, a submission engine, and an evaluation module with metrics like accuracy, efficiency, and boundary testing.

Result: Comprehensive testing of 18 state-of-the-art LLMs revealed significant performance gaps and bottlenecks in spatial semantic understanding, code reliability, and accurate library function invocation.

Conclusion: GeoJSEval establishes a methodological and practical foundation for evaluating and optimizing geospatial code generation models, demonstrating strong real-world applicability and extensibility.

Abstract: With the widespread adoption of large language models (LLMs) in code
generation tasks, geospatial code generation has emerged as a critical frontier
in the integration of artificial intelligence and geoscientific analysis. This
trend underscores the urgent need for systematic evaluation methodologies to
assess LLMs generation capabilities in geospatial contexts. In particular,
geospatial computation and visualization tasks in JavaScript environments rely
heavily on orchestrating diverse frontend libraries and ecosystems, placing
elevated demands on a model's semantic understanding and code synthesis
abilities. To address this challenge, we propose GeoJSEval--the first
multimodal, function-level automatic evaluation framework for LLMs in
JavaScript-based geospatial code generation. GeoJSEval comprises three core
components: a standardized test suite (GeoJSEval-Bench), a code submission
engine, and an evaluation module. It includes 432 function-level tasks and
2,071 structured test cases spanning five widely used JavaScript geospatial
libraries and 25 mainstream geospatial data types. GeoJSEval enables
multidimensional quantitative evaluation across metrics such as accuracy,
output stability, execution efficiency, resource consumption, and error type
distribution, and integrates boundary testing mechanisms to enhance robustness
and coverage. We conduct a comprehensive evaluation of 18 state-of-the-art LLMs
using GeoJSEval, revealing significant performance disparities and bottlenecks
in spatial semantic understanding, code reliability, and function invocation
accuracy. GeoJSEval provides a foundational methodology, evaluation resource,
and practical toolkit for the standardized assessment and optimization of
geospatial code generation models, with strong extensibility and applicability
in real-world scenarios.

</details>


### [46] [Intention-Driven Generation of Project-Specific Test Cases](https://arxiv.org/abs/2507.20619)
*Binhang Qi,Yun Lin,Xinyi Weng,Yuhuan Huang,Chenyan Liu,Hailong Sun,Jin Song Dong*

Main category: cs.SE

TL;DR: IntentionTest improves project-specific test generation by leveraging validation intentions and code reuse, outperforming existing methods in test correctness and effectiveness.


<details>
  <summary>Details</summary>
Motivation: Existing automated test generation techniques that focus solely on coverage maximize code redundancy but fail to incorporate developer validation intentions and project-specific knowledge required for practical test integration.

Method: The framework (1) retrieves project-referable tests using structured validation intention descriptions (formal test plans or informal code comments) (2) transforms test generation into test code editing focused on implementation specific to validation intentions (3) combines test prefix/oracle for executable semantic correctness

Result: When tested against ChatTester across 13 projects and 4,146 test cases, IntentionTest demonstrated 39.03% higher mutation scores and 40.14% better coverage overlap with ground-truth tests, along with 21.30% higher test passing rate

Conclusion: IntentionTest addresses practical test generation by explicitly modeling validation intention through test code reuse and semantic editing, offering better integration potential for real-world projects compared to coverage-driven methods

Abstract: Test cases are valuable assets for maintaining software quality. While
numerous automated techniques have been proposed for generating tests (either
by maximizing code coverage or by translating focal code into test code),
practical tests are seldom driven by coverage alone. In real projects, each
test reflects a developer's validation intention for a specific behaviour and
embodies rich, project-specific knowledge: which specific APIs to call and what
assertions truly matter. Without considering such knowledge, tests can hardly
pass code review and be integrated into the software product.
  In this work, we propose IntentionTest, which generates project-specific
tests with validation intention as a structured description. Our design is
motivated by two insights: (1) a description of validation intention, compared
to coverage and focal code, carries more crucial information about what to
test; and (2) practical tests exhibit high code duplication, indicating that
domain knowledge is highly reusable for writing new tests. Given a focal code
and a description of validation intention (in the form of either an informal
comment or a formal test plan), IntentionTest retrieves a referable test in the
project to guide test generation. Moreover, IntentionTest reduces the test
generation problem into an editing problem on the test code regarding the
validation intention. It generates a test including both test prefix and
oracle, which aims to be executable and semantically correct.
  We evaluate IntentionTest against state-of-the-art baselines on 4,146 test
cases from 13 open-source projects. Specifically, compared to ChatTester,
IntentionTest can (1) generate significantly more semantically correct tests,
improving common mutation scores by 39.03% and coverage overlap with
ground-truth tests by 40.14%; (2) generate 21.30% more successful passing
tests.

</details>


### [47] [LLM-Based Repair of Static Nullability Errors](https://arxiv.org/abs/2507.20674)
*Nima Karimipour,Michael Pradel,Martin Kellogg,Manu Sridharan*

Main category: cs.SE

TL;DR: A system called NullRepair uses large language models (LLMs) in a structured workflow to resolve residual nullability errors in Java projects, leveraging static analysis and project-wide context to preserve program semantics.


<details>
  <summary>Details</summary>
Motivation: Java projects using nullability static analysis tools face challenges in fixing residual errors (true bugs and false positives) after annotation inference, as manual fixes are tedious. LLMs could automate repairs but require contextual understanding to avoid incorrect edits.

Method: NullRepair integrates LLMs with flowchart-guided decision logic based on 200 real-world errors. It uses static analysis to identify symbol usage regions and contextualizes LLM prompts with error-free examples through iterative interactions.

Result: Evaluated on 12 Java projects, NullRepair resolved 72% of residual errors post-annotation inference. Unit tests passed fully in 10 projects and 98%+ in remaining two after applying all proposed edits.

Conclusion: Structured LLM workflows with static analysis and project context can effectively resolve nullability errors while preserving semantics. NullRepair outperforms naive LLM prompting approaches in both repair accuracy and test suite preservation.

Abstract: Modern Java projects increasingly adopt static analysis tools that prevent
null-pointer exceptions by treating nullness as a type property. However,
integrating such tools into large, existing codebases remains a significant
challenge. While annotation inference can eliminate many errors automatically,
a subset of residual errors -- typically a mix of real bugs and false positives
-- often persist and can only be resolved via code changes. Manually addressing
these errors is tedious and error-prone. Large language models (LLMs) offer a
promising path toward automating these repairs, but naively-prompted LLMs often
generate incorrect, contextually-inappropriate edits. Resolving a nullability
error demands a deep understanding of how a symbol is used across the codebase,
often spanning methods, classes, and packages. We present NullRepair, a system
that integrates LLMs into a structured workflow for resolving the errors from a
nullability checker. NullRepair's decision process follows a flowchart derived
from manual analysis of 200 real-world errors. It leverages static analysis to
identify safe and unsafe usage regions of symbols, using error-free usage
examples to contextualize model prompts. Patches are generated through an
iterative interaction with the LLM that incorporates project-wide context and
decision logic. Our evaluation on 12 real-world Java projects shows that
NullRepair resolves an average of 72% of the errors that remain after applying
a state-of-the-art annotation inference technique. Unlike a naively-prompted
LLM, NullRepair also largely preserves program semantics, with all unit tests
passing in 10/12 projects after applying every edit proposed by NullRepair, and
98% or more tests passing in the remaining two projects.

</details>


### [48] [Client--Library Compatibility Testing with API Interaction Snapshots](https://arxiv.org/abs/2507.20814)
*Gustave Monce,Thomas Degueule,Jean-Rémy Falleri,Romain Robbes*

Main category: cs.SE

TL;DR: Gilesi detects behavioral breaking changes (BBCs) in third-party libraries by recording API interactions from client tests as snapshots and comparing them over time to flag compatibility issues.


<details>
  <summary>Details</summary>
Motivation: Library updates often introduce BBCs that alter run-time behavior, which client-side regression tests may miss due to limited library coverage or weak assertions.

Method: The approach automatically instruments library APIs during client test execution to capture API boundary interactions (input/output values, exceptions, etc.) as snapshots, then compares new snapshots to original ones to identify contract changes.

Result: Preliminary case studies on Java client--library pairs with seeded BBCs demonstrate Gilesi reliably detects BBCs that traditional tests miss.

Conclusion: Gilesi's snapshot-based compatibility testing effectively identifies BBCs in evolving libraries, offering a promising solution to improve client--library compatibility.

Abstract: Modern software development heavily relies on third-party libraries to speed
up development and enhance quality. As libraries evolve, they may break the
tacit contract established with their clients by introducing behavioral
breaking changes (BBCs) that alter run-time behavior and silently break client
applications without being detected at compile time. Traditional regression
tests on the client side often fail to detect such BBCs, either due to limited
library coverage or weak assertions that do not sufficiently exercise the
library's expected behavior. To address this issue, we propose a novel approach
to client--library compatibility testing that leverages existing client tests
in a novel way. Instead of relying on developer-written assertions, we propose
recording the actual interactions at the API boundary during the execution of
client tests (protocol, input and output values, exceptions, etc.). These
sequences of API interactions are stored as snapshots which capture the exact
contract expected by a client at a specific point in time. As the library
evolves, we compare the original and new snapshots to identify perturbations in
the contract, flag potential BBCs, and notify clients. We implement this
technique in our prototype tool Gilesi, a Java framework that automatically
instruments library APIs, records snapshots, and compares them. Through a
preliminary case study on several client--library pairs with artificially
seeded BBCs, we show that Gilesi reliably detects BBCs missed by client test
suites.

</details>


### [49] [Search-Based Fuzzing For RESTful APIs That Use MongoDB](https://arxiv.org/abs/2507.20848)
*Hernan Ghianni,Man Zhang,Juan P. Galeotti,Andrea Arcuri*

Main category: cs.SE

TL;DR: The paper proposes techniques to improve search-based test generation for RESTful APIs interacting with NoSQL databases by dynamically analyzing the database state and inserting data from test cases. It is integrated into the EvoMaster tool, showing up to 18% higher code coverage in experiments.


<details>
  <summary>Details</summary>
Motivation: White-box testing of RESTful APIs often neglects database state management, leading to limited code coverage and missed faults. Existing tools struggle to handle complex NoSQL database states, especially for read-only microservices.

Method: The authors extended EvoMaster with automated code instrumentation to track MongoDB states during test generation and introduced a direct NoSQL data insertion mechanism from test cases to set the database to required states without manual sequencing.

Result: Experiments on six RESTful APIs showed up to 18% improvement in code coverage compared to prior white-box methods and outperformed four black-box fuzzers in effectiveness.

Conclusion: The proposed techniques enhance white-box test generation for NoSQL-backed RESTful APIs by eliminating dependencies on manual database setup and enabling better fault detection, verified through empirical comparisons.

Abstract: In RESTful APIs, interactions with a database are a common and crucial
aspect. When generating whitebox tests, it is essential to consider the
database's state (i.e., the data contained in the database) to achieve higher
code coverage and uncover more hidden faults. This article presents novel
techniques to enhance search-based software test generation for RESTful APIs
interacting with NoSQL databases. Specifically, we target the popular MongoDB
database, by dynamically analyzing (via automated code instrumentation) the
state of the database during the test generation process. Additionally, to
achieve better results, our novel approach allows inserting NoSQL data directly
from test cases. This is particularly beneficial when generating the correct
sequence of events to set the NoSQL database in an appropriate state is
challenging or time-consuming. This method is also advantageous for testing
read-only microservices. Our novel techniques are implemented as an extension
of EvoMaster, the only open-source tool for white-box fuzzing RESTful APIs.
Experiments conducted on six RESTful APIs demonstrated significant improvements
in code coverage, with increases of up to 18% compared to existing white-box
approaches. To better highlight the improvements of our novel techniques,
comparisons are also carried out with four state-of-the-art black-box fuzzers.

</details>


### [50] [Enhancing Project-Specific Code Completion by Inferring Internal API Information](https://arxiv.org/abs/2507.20888)
*Le Deng,Xiaoxue Ren,Chao Ni,Ming Liang,David Lo,Zhongxin Liu*

Main category: cs.SE

TL;DR: This paper introduces a method to infer internal API information for code completion without relying on explicit imports, enhancing large language models' performance by leveraging usage examples and semantic descriptions. It presents ProjBench, a benchmark avoiding import leakage, and demonstrates significant improvements over existing approaches in code and identifier exact match.


<details>
  <summary>Details</summary>
Motivation: Current retrieval-augmented generation (RAG) methods for code completion struggle to incorporate internal API data when APIs are not explicitly imported in a file, leading to reduced accuracy.

Method: The proposed approach constructs API usage examples and semantic descriptions to extend API representations, creating a knowledge base to guide code generation. ProjBench is introduced as a benchmark composed of real-world projects with no leaked imports.

Result: Experiments on ProjBench and CrossCodeEval show a 22.72% improvement in code exact match and 18.31% in identifier exact match compared to existing methods. Integration with baselines further boosts code match by 47.80% and identifier match by 35.55%.

Conclusion: The method provides a robust solution for project-specific code completion by effectively embedding internal API semantics into LLMs, even without explicit imports, and achieves substantial performance gains over prior work.

Abstract: Project-specific code completion is a critical task that leverages context
from a project to generate accurate code. State-of-the-art methods use
retrieval-augmented generation (RAG) with large language models (LLMs) and
project information for code completion. However, they often struggle to
incorporate internal API information, which is crucial for accuracy, especially
when APIs are not explicitly imported in the file.
  To address this, we propose a method to infer internal API information
without relying on imports. Our method extends the representation of APIs by
constructing usage examples and semantic descriptions, building a knowledge
base for LLMs to generate relevant completions. We also introduce ProjBench, a
benchmark that avoids leaked imports and consists of large-scale real-world
projects.
  Experiments on ProjBench and CrossCodeEval show that our approach
significantly outperforms existing methods, improving code exact match by
22.72% and identifier exact match by 18.31%. Additionally, integrating our
method with existing baselines boosts code match by 47.80% and identifier match
by 35.55%.

</details>
