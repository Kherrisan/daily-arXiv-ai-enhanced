{"id": "2507.17930", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.17930", "abs": "https://arxiv.org/abs/2507.17930", "authors": ["Vahid Garousi", "Zafar Jafarov"], "title": "How Software Engineers Engage with AI: A Pragmatic Process Model and Decision Framework Grounded in Industry Observations", "comment": null, "summary": "Artificial Intelligence (AI) has the potential to transform Software\nEngineering (SE) by enhancing productivity, efficiency, and decision support.\nTools like GitHub Copilot and ChatGPT have given rise to \"vibe coding\"-an\nexploratory, prompt-driven development style. Yet, how software engineers\nengage with these tools in daily tasks, especially in deciding whether to\ntrust, refine, or reject AI-generated outputs, remains underexplored. This\npaper presents two complementary contributions. First, a pragmatic process\nmodel capturing real-world AI-assisted SE activities, including prompt design,\ninspection, fallback, and refinement. Second, a 2D decision framework that\ncould help developers reason about trade-offs between effort saved and output\nquality. Grounded in practitioner reports and direct observations in three\nindustry settings across Turkiye and Azerbaijan, our work illustrates how\nengineers navigate AI use with human oversight. These models offer structured,\nlightweight guidance to support more deliberate and effective use of AI tools\nin SE, contributing to ongoing discussions on practical human-AI collaboration.", "AI": {"tldr": "The paper analyzes AI tool usage in Software Engineering through a process model and decision framework based on industry observations.", "motivation": "AI tools like GitHub Copilot and ChatGPT enable new coding workflows, but understanding developer decisions about trust/refinement of AI outputs in real-world SE contexts is critically underexplored, especially in balancing effort vs. quality trade-offs.", "method": "Grounded in practitioner reports and direct observational studies across three industry settings in Turkey and Azerbaijan, employing qualitative analysis to extract patterns in human-AI collaborative workflows.", "result": "1) Pragmatic AI-assisted SE process model encompassing prompt design, inspection, fallback, refinement activities\n2) 2D decision framework for evaluating effort savings vs. output quality trade-offs\n3) Contextual insights into daily AI usage patterns with human oversight mechanisms", "conclusion": "The proposed models provide lightweight guidance for deliberate AI integration in SE, advancing practical understanding of human-AI collaboration dynamics through concrete industry examples and decision-support structures."}}
{"id": "2507.17991", "categories": ["cs.SE", "cs.IR"], "pdf": "https://arxiv.org/pdf/2507.17991", "abs": "https://arxiv.org/abs/2507.17991", "authors": ["Peter Eckmann", "Adrian Barnett", "Alexandra Bannach-Brown", "Elisa Pilar Bascunan Atria", "Guillaume Cabanac", "Louise Delwen Owen Franzen", "Ma\u0142gorzata Anna Gazda", "Kaitlyn Hair", "James Howison", "Halil Kilicoglu", "Cyril Labbe", "Sarah McCann", "Vladislav Nachev", "Martijn Roelandse", "Maia Salholz-Hillel", "Robert Schulz", "Gerben ter Riet", "Colby Vorland", "Anita Bandrowski", "Tracey Weissgerber"], "title": "Use as Directed? A Comparison of Software Tools Intended to Check Rigor and Transparency of Published Work", "comment": null, "summary": "The causes of the reproducibility crisis include lack of standardization and\ntransparency in scientific reporting. Checklists such as ARRIVE and CONSORT\nseek to improve transparency, but they are not always followed by authors and\npeer review often fails to identify missing items. To address these issues,\nthere are several automated tools that have been designed to check different\nrigor criteria. We have conducted a broad comparison of 11 automated tools\nacross 9 different rigor criteria from the ScreenIT group. We found some\ncriteria, including detecting open data, where the combination of tools showed\na clear winner, a tool which performed much better than other tools. In other\ncases, including detection of inclusion and exclusion criteria, the combination\nof tools exceeded the performance of any one tool. We also identified key areas\nwhere tool developers should focus their effort to make their tool maximally\nuseful. We conclude with a set of insights and recommendations for stakeholders\nin the development of rigor and transparency detection tools. The code and data\nfor the study is available at https://github.com/PeterEckmann1/tool-comparison.", "AI": {"tldr": "This paper compares 11 automated tools for improving scientific reproducibility across 9 rigor criteria, identifying performance leaders and combination advantages while offering developer recommendations.", "motivation": "The reproducibility crisis in science stems from inadequate standardization and transparency, despite existing checklists like ARRIVE and CONSORT. Current tools often fall short in enforcement and detection.", "method": "Systematic evaluation of 11 automated tools using 9 rigor criteria from the ScreenIT framework to assess their effectiveness in identifying missing transparency elements.", "result": "Demonstrated superior performance of specific tools for open data detection, improved accuracy through tool combinations for inclusion/exclusion criteria, and identified critical development gaps for tool creators.", "conclusion": "Provides actionable insights for optimizing automated rigor detection tools and highlights collaborative approaches between developers and stakeholders to enhance scientific transparency."}}
{"id": "2507.18029", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18029", "abs": "https://arxiv.org/abs/2507.18029", "authors": ["Xiang Echo Chen", "Wenhan Zhu", "Guoshuai Albert Shi", "Michael W. Godfrey"], "title": "An Empirical Study of GenAI Adoption in Open-Source Game Development: Tools, Tasks, and Developer Challenges", "comment": null, "summary": "The growing capabilities of generative AI (GenAI) have begun to reshape how\ngames are designed and developed, offering new tools for content creation,\ngameplay simulation, and design ideation. While prior research has explored\ntraditional uses of AI in games, such as controlling agents or generating\nprocedural content. There is limited empirical understanding of how GenAI is\nadopted by developers in real-world contexts, especially within the open-source\ncommunity. This study aims to explore how GenAI technologies are discussed,\nadopted, and integrated into open-source game development by analyzing issue\ndiscussions on GitHub. We investigate the tools, tasks, and challenges\nassociated with GenAI by comparing GenAI-related issues to those involving\ntraditional AI (TradAI) and NonAI topics. Our goal is to uncover how GenAI\ndiffers from other approaches in terms of usage patterns, developer concerns,\nand integration practices. To address this objective, we construct a dataset of\nopen-source game repositories that discuss AI-related topics. We apply open\ncard sorting and thematic analysis to a stratified sample of GitHub issues,\nlabelling each by type and content. These annotations enable comparative\nanalysis across GenAI, TradAI, and NonAI groups, and provide insight into how\nGenAI is shaping the workflows and pain points of open-source game developers.", "AI": {"tldr": "This paper investigates the adoption of generative AI (GenAI) in open-source game development by analyzing GitHub issues, comparing GenAI-related discussions to traditional AI (TradAI) and non-AI topics, and examining associated tools, tasks, and challenges.", "motivation": "The study addresses a gap in empirical understanding of how GenAI technologies are adopted by open-source developers, particularly in contrast to traditional AI and non-AI approaches, and how they impact workflows and challenges in real-world implementation.", "method": "The researchers built a dataset of open-source game repositories mentioning AI-related topics and conducted open card sorting and thematic analysis on a stratified sample of GitHub issues. Issues were labeled according to type and content to enable comparative analysis across GenAI, TradAI, and NonAI groups.", "result": "The analysis provides empirical characterizations of GenAI vs. non-GenAI AI usage in open-source game development, identifying tools, tasks, and challenges specific to GenAI adoption while highlighting distinct patterns of usage, concerns, and integration practices between the groups.", "conclusion": "Through systematic empirical analysis, the study reveals how GenAI is shaping open-source game development workflows and pain points, offering actionable insights for both researchers and developers regarding AI adoption patterns in this specific context."}}
{"id": "2507.18037", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2507.18037", "abs": "https://arxiv.org/abs/2507.18037", "authors": ["Sivana Hamer", "Jacob Bowen", "Md Nazmul Haque", "Chris Madden", "Laurie Williams"], "title": "Your ATs to Ts: MITRE ATT&CK Attack Technique to P-SSCRM Task Mapping", "comment": "Mapping generated from: arXiv:2503.12192", "summary": "The MITRE Adversarial Tactics, Techniques and Common Knowledge (MITRE ATT&CK)\nAttack Technique to Proactive Software Supply Chain Risk Management Framework\n(P-SSCRM) Task mapping described in this document helps software organizations\nto determine how different tasks mitigate the attack techniques of software\nsupply chain attacks. The mapping was created through four independent\nstrategies to find agreed-upon mappings. Because each P-SSCRM task is mapped to\none or more tasks from the 10 frameworks, the mapping we provide is also a\nmapping between MITRE ATT&CK and other prominent government and industry\nframeworks.", "AI": {"tldr": "The paper presents a mapping between MITRE ATT&CK attack techniques and the P-SSCRM framework to help organizations mitigate software supply chain risks through proactive tasks aligned with government/industry standards.", "motivation": "Organizations need actionable guidance to translate attack knowledge (MITRE ATT&CK) into effective supply chain risk mitigation strategies, but such structured mappings were previously lacking.", "method": "The authors established mappings using four independent methods to identify consensus-aligned task-technique relationships, cross-referencing P-SSCRM with 10 existing frameworks.", "result": "A comprehensive mapping matrix linking MITRE ATT&CK techniques to 65 P-SSCRM tasks and demonstrating connections between these tasks and 10 external frameworks was developed.", "conclusion": "This work provides a critical bridge between adversarial threat knowledge and proactive supply chain risk management, enhancing the utility of both MITRE ATT&CK and P-SSCRM for organizational defense planning."}}
{"id": "2507.17850", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.17850", "abs": "https://arxiv.org/abs/2507.17850", "authors": ["Rodrigo Moreira", "Larissa F. Rodrigues Moreira", "Fl\u00e1vio de Oliveira Silva"], "title": "Performance Evaluation and Threat Mitigation in Large-scale 5G Core Deployment", "comment": null, "summary": "The deployment of large-scale software-based 5G core functions presents\nsignificant challenges due to their reliance on optimized and intelligent\nresource provisioning for their services. Many studies have focused on\nanalyzing the impact of resource allocation for complex deployments using\nmathematical models, queue theories, or even Artificial Intelligence (AI). This\npaper elucidates the effects of chaotic workloads, generated by Distributed\nDenial of Service (DDoS) on different Network Functions (NFs) on User Equipment\nregistration performance. Our findings highlight the necessity of diverse\nresource profiles to ensure Service-Level Agreement (SLA) compliance in\nlarge-scale 5G core deployments. Additionally, our analysis of packet capture\napproaches demonstrates the potential of kernel-based monitoring for scalable\nsecurity threat defense. Finally, our empirical evaluation provides insights\ninto the effective deployment of 5G NFs in complex scenarios.", "AI": {"tldr": "This paper examines the impact of DDoS-induced chaotic workloads on 5G core network functions (NFs), emphasizing resource-profile diversity for SLA compliance, kernel-based monitoring for security, and empirical insights for deployment in complex scenarios.", "motivation": "5G core deployments face significant challenges in resource provisioning due to the need for optimization and intelligence. Prior studies focus on mathematical models and AI, but the effect of DDoS-driven chaos on user registration performance remains underexplored, necessitating practical approaches to ensure SLA compliance.", "method": "The study analyzes the effects of chaotic workloads from DDoS attacks on various Network Functions (NFs) using packet capture approaches and empirical evaluations to assess resource provisioning strategies and security monitoring effectiveness.", "result": "Diverse resource profiles are critical to maintaining SLA compliance under chaotic workloads. Kernel-based monitoring demonstrates scalability in defending against security threats, and empirical data reveals key insights for deploying 5G NFs in complex environments.", "conclusion": "The paper underscores the need for adaptive resource allocation and kernel-level security monitoring to address DDoS challenges in large-scale 5G deployments, supported by empirical evidence for optimizing NF performance and SLA adherence."}}
{"id": "2507.18039", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18039", "abs": "https://arxiv.org/abs/2507.18039", "authors": ["Ahmad D. Suleiman", "Yiming Tang", "Daqing Hou"], "title": "Factors Impacting Faculty Adoption of Project-Based Learning in Computing Education: a Survey", "comment": "Accepted at IEEE Frontiers in Education (FIE) 2025. This work has\n  been submitted to the IEEE for possible publication", "summary": "This research full paper investigates the factors influencing computing\neducators' adoption of project-based learning (PjBL) in software engineering\nand computing curricula. Recognized as a student-centered pedagogical approach,\nPjBL has the potential to enhance student motivation, engagement, critical\nthinking, collaboration, and problem-solving skills. Despite these benefits,\nfaculty adoption remains inconsistent due to challenges such as insufficient\ninstitutional support, time constraints, limited training opportunities,\ndesigning or sourcing projects, and aligning them with course objectives. This\nresearch explores these barriers and investigates the strategies and resources\nthat facilitate a successful adoption. Using a mixed-methods approach, data\nfrom 80 computing faculty were collected through an online survey comprising\nclosed-ended questions to quantify barriers, enablers, and resource needs,\nalong with an open-ended question to gather qualitative insights. Quantitative\ndata were analyzed using statistical methods, while qualitative responses\nunderwent thematic analysis. Results reveal that while PjBL is widely valued,\nits adoption is often selective and impacted by challenges in planning and\nmanaging the learning process, designing suitable projects, and a lack of\ninstitutional support, such as time, funding, and teaching assistants. Faculty\nare more likely to adopt or sustain PjBL when they have access to peer\ncollaboration, professional development, and institutional incentives. In\naddition, sourcing projects from research, industry partnerships, and borrowing\nfrom peers emerged as key facilitators for new projects. These findings\nunderscore the need for systemic support structures to empower faculty to\nexperiment with and scale PjBL practices.", "AI": {"tldr": "This paper examines barriers and facilitators to computing educators' adoption of project-based learning (PjBL) in software engineering curricula, emphasizing the need for systemic institutional support to overcome challenges like project design and resource limitations.", "motivation": "Despite PjBL's known benefits (student motivation, problem-solving skills), its adoption remains inconsistent due to faculty hesitation over implementation challenges, prompting research into effective support strategies and barriers to implementation.", "method": "Mixed-methods approach combining quantitative analysis (statistical methods on 80 faculty survey responses) and qualitative thematic analysis of open-ended feedback to assess PjBL adoption barriers and facilitators.", "result": "Identified key barriers: insufficient institutional support (time, funding, teaching assistants), project design/alignment with course goals, and process management. Key enablers included peer collaboration, professional development, institutional incentives, and project sourcing from research/industry/peers.", "conclusion": "Successful PjBL adoption requires systemic institutional support frameworks, including resource allocation, professional development opportunities, and collaborative networks to address planning, project design, and sustainability challenges."}}
{"id": "2507.17888", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2507.17888", "abs": "https://arxiv.org/abs/2507.17888", "authors": ["Nima Atashin", "Behrouz Tork Ladani", "Mohammadreza Sharbaf"], "title": "Learning to Locate: GNN-Powered Vulnerability Path Discovery in Open Source Code", "comment": "8 pages, 5 Figures", "summary": "Detecting security vulnerabilities in open-source software is a critical task\nthat is highly regarded in the related research communities. Several approaches\nhave been proposed in the literature for detecting vulnerable codes and\nidentifying the classes of vulnerabilities. However, there is still room to\nwork in explaining the root causes of detected vulnerabilities through locating\nvulnerable statements and the discovery of paths leading to the activation of\nthe vulnerability. While frameworks like SliceLocator offer explanations by\nidentifying vulnerable paths, they rely on rule-based sink identification that\nlimits their generalization. In this paper, we introduce VulPathFinder, an\nexplainable vulnerability path discovery framework that enhances SliceLocator's\nmethodology by utilizing a novel Graph Neural Network (GNN) model for detecting\nsink statements, rather than relying on predefined rules. The proposed GNN\ncaptures semantic and syntactic dependencies to find potential sink points\n(PSPs), which are candidate statements where vulnerable paths end. After\ndetecting PSPs, program slicing can be used to extract potentially vulnerable\npaths, which are then ranked by feeding them back into the target graph-based\ndetector. Ultimately, the most probable path is returned, explaining the root\ncause of the detected vulnerability. We demonstrated the effectiveness of the\nproposed approach by performing evaluations on a benchmark of the buffer\noverflow CWEs from the SARD dataset, providing explanations for the\ncorresponding detected vulnerabilities. The results show that VulPathFinder\noutperforms both original SliceLocator and GNNExplainer (as a general GNN\nexplainability tool) in discovery of vulnerability paths to identified PSPs.", "AI": {"tldr": "VulPathFinder is an explainable vulnerability path discovery framework using a novel GNN model for detecting sink statements and capturing dependencies to improve root cause explanations beyond rule-based approaches.", "motivation": "Existing methods for vulnerability detection and path explanation, such as SliceLocator, rely on predefined rules for sink identification, which limits their generalization. This necessitates a more flexible, accurate approach using semantic analysis to enhance vulnerability explanations and pinpoint root causes effectively.", "method": "The framework employs a Graph Neural Network (GNN) to detect potential sink statements (PSPs) by learning semantic and syntactic dependencies. These PSPs are used in conjunction with program slicing to extract vulnerable paths, which are subsequently ranked using a graph-based detector to prioritize high-probability root causes.", "result": "Evaluations on buffer overflow vulnerabilities from the SARD dataset demonstrate that VulPathFinder significantly outperforms SliceLocator and GNNExplainer in the discovery of vulnerability paths to identified PSPs, suggesting effective improvements in generalization and accuracy.", "conclusion": "VulPathFinder offers a robust and explainable solution for vulnerability path discovery, surpassing current frameworks by leveraging GNNs to automatically detect sink points and explain root causes with high precision, thereby enhancing vulnerability analysis in open-source software."}}
{"id": "2507.18062", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18062", "abs": "https://arxiv.org/abs/2507.18062", "authors": ["Edward Abrokwah", "Taher A. Ghaleb"], "title": "An Empirical Study of Complexity, Heterogeneity, and Compliance of GitHub Actions Workflows", "comment": "Registered Report Accepted at the 41st IEEE International Conference\n  on Software Maintenance and Evolution 2025 (ICSME'25)", "summary": "Continuous Integration (CI) has evolved from a tooling strategy to a\nfundamental mindset in modern CI engineering. It enables teams to develop,\ntest, and deliver software rapidly and collaboratively. Among CI services,\nGitHub Actions (GHA) has emerged as a dominant service due to its deep\nintegration with GitHub and a vast ecosystem of reusable workflow actions.\nAlthough GHA provides official documentation and community-supported best\npractices, there appears to be limited empirical understanding of how\nopen-source real-world CI workflows align with such practices. Many workflows\nmight be unnecessarily complex and not aligned with the simplicity goals of CI\npractices. This study will investigate the structure, complexity,\nheterogeneity, and compliance of GHA workflows in open-source software\nrepositories. Using a large dataset of GHA workflows from Java, Python, and C++\nrepositories, our goal is to (a) identify workflow complexities, (b) analyze\nrecurring and heterogeneous structuring patterns, (c) assess compliance with\nGHA best practices, and (d) uncover differences in CI pipeline design across\nprogramming languages. Our findings are expected to reveal both areas of strong\nadherence to best practices and areas for improvement where needed. These\ninsights will also have implications for CI services, as they will highlight\nthe need for clearer guidelines and comprehensive examples in CI documentation.", "AI": {"tldr": "This study investigates the structure and compliance of GitHub Actions workflows in open-source repositories, analyzing complexities and cross-language differences to inform improvements in CI documentation and practices.", "motivation": "Continuous Integration (CI) has become a core mindset, yet there's limited empirical understanding of how real-world GitHub Actions (GHA) workflows align with best practices. Many workflows may be overly complex, requiring deeper analysis.", "method": "Analyzes a large dataset of GHA workflows from Java, Python, and C++ repositories to identify structural patterns, complexities, compliance with best practices, and cross-language design variations.", "result": "Expected to reveal strong adherence to and deviations from GHA best practices, uncovering workflow complexities, recurring patterns, and differences in pipeline design across programming languages.", "conclusion": "The findings will highlight the need for clearer GHA documentation, comprehensive examples, and address gaps where workflows fall short of simplicity and best practices, benefiting both developers and CI service providers."}}
{"id": "2507.17956", "categories": ["cs.CR", "cs.LO"], "pdf": "https://arxiv.org/pdf/2507.17956", "abs": "https://arxiv.org/abs/2507.17956", "authors": ["Russell O'Connor", "Andrew Poelstra"], "title": "Formal Verification of the Safegcd Implementation", "comment": "15 pages; Coq sources can be found at\n  https://github.com/BlockstreamResearch/simplicity/tree/c1dddedd553b403da877377e658f17f0d2184cc4/Coq/C/secp256k1\n  ; Alectryon preview can be viewed at e.g.\n  https://html-preview.github.io/?url=https://github.com/BlockstreamResearch/simplicity/blob/c1dddedd553b403da877377e658f17f0d2184cc4/alectryon/verif_modinv64_impl.v.html", "summary": "The modular inverse is an essential piece of computation required for\nelliptic curve operations used for digital signatures in Bitcoin and other\napplications. A novel approach to the extended Euclidean algorithm has been\ndeveloped by Bernstein and Yang within the last few years and incorporated into\nthe libsecp256k1 cryptographic library used by Bitcoin. However, novel\nalgorithms introduce new risks of errors. To address this we have completed a\ncomputer verified proof of the correctness of (one of) libsecp256k1's modular\ninverse implementations with the Coq proof assistant using the Verifiable C's\nimplementation of separation logic.", "AI": {"tldr": "This paper verifies the correctness of libsecp256k1's modular inverse implementation using Coq and separation logic to ensure cryptographic security.", "motivation": "Novel algorithms like Bernstein and Yang's extended Euclidean method for modular inversion in Bitcoin's libsecp256k1 introduce potential errors, necessitating formal verification for security.", "method": "The authors used the Coq proof assistant and Verifiable C's separation logic to conduct a computer-verified proof of the implementation's correctness.", "result": "A verified proof confirms the correctness of the modular inverse algorithm in libsecp256k1, addressing risks associated with new cryptographic methods.", "conclusion": "Formal verification of cryptographic implementations using tools like Coq and separation logic is critical for ensuring security and correctness in high-stakes applications such as Bitcoin."}}
{"id": "2507.18081", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18081", "abs": "https://arxiv.org/abs/2507.18081", "authors": ["Carol Wong", "Mai Abe", "Silvia De Benedictis", "Marissa Halim", "Anthony Peruma"], "title": "Identifier Name Similarities: An Exploratory Study", "comment": "The 19th ACM/IEEE International Symposium on Empirical Software\n  Engineering and Measurement - Emerging Results and Vision Track", "summary": "Identifier names, which comprise a significant portion of the codebase, are\nthe cornerstone of effective program comprehension. However, research has shown\nthat poorly chosen names can significantly increase cognitive load and hinder\ncollaboration. Even names that appear readable in isolation may lead to\nmisunderstandings in contexts when they closely resemble other names in either\nstructure or functionality. In this exploratory study, we present our\npreliminary findings on the occurrence of identifier name similarity in\nsoftware projects through the development of a taxonomy that categorizes\ndifferent forms of identifier name similarity. We envision our initial taxonomy\nproviding researchers with a platform to analyze and evaluate the impact of\nidentifier name similarity on code comprehension, maintainability, and\ncollaboration among developers, while also allowing for further refinement and\nexpansion of the taxonomy.", "AI": {"tldr": "This paper introduces a taxonomy for identifier name similarity in codebases to evaluate its impact on comprehension and collaboration.", "motivation": "Poorly chosen identifier names increase cognitive load and hinder collaboration, and even readable names can cause confusion when similar to others.", "method": "Development of a taxonomy categorizing different forms of identifier name similarity through an exploratory study.", "result": "Preliminary taxonomy details and findings on name similarity occurrence in software projects.", "conclusion": "The taxonomy serves as a foundation for further research on name similarity's effects and potential refinement."}}
{"id": "2507.17962", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2507.17962", "abs": "https://arxiv.org/abs/2507.17962", "authors": ["Nowfel Mashnoor", "Mohammad Akyash", "Hadi Kamali", "Kimia Azar"], "title": "TimelyHLS: LLM-Based Timing-Aware and Architecture-Specific FPGA HLS Optimization", "comment": null, "summary": "Achieving timing closure and design-specific optimizations in FPGA-targeted\nHigh-Level Synthesis (HLS) remains a significant challenge due to the complex\ninteraction between architectural constraints, resource utilization, and the\nabsence of automated support for platform-specific pragmas. In this work, we\npropose TimelyHLS, a novel framework integrating Large Language Models (LLMs)\nwith Retrieval-Augmented Generation (RAG) to automatically generate and\niteratively refine HLS code optimized for FPGA-specific timing and performance\nrequirements. TimelyHLS is driven by a structured architectural knowledge base\ncontaining FPGA-specific features, synthesis directives, and pragma templates.\nGiven a kernel, TimelyHLS generates HLS code annotated with both\ntiming-critical and design-specific pragmas. The synthesized RTL is then\nevaluated using commercial toolchains, and simulation correctness is verified\nagainst reference outputs via custom testbenches. TimelyHLS iteratively\nincorporates synthesis logs and performance reports into the LLM engine for\nrefinement in the presence of functional discrepancies. Experimental results\nacross 10 FPGA architectures and diverse benchmarks show that TimelyHLS reduces\nthe need for manual tuning by up to 70%, while achieving up to 4x latency\nspeedup (e.g., 3.85x for Matrix Multiplication, 3.7x for Bitonic Sort) and over\n50% area savings in certain cases (e.g., 57% FF reduction in Viterbi).\nTimelyHLS consistently achieves timing closure and functional correctness\nacross platforms, highlighting the effectiveness of LLM-driven,\narchitecture-aware synthesis in automating FPGA design.", "AI": {"tldr": "TimelyHLS is an LLM-RAG-based framework that automates FPGA HLS code generation and optimization, reducing manual tuning by 70% and achieving significant latency/area improvements.", "motivation": "Manual optimization of HLS code for FPGA timing and area is labor-intensive due to complex interactions between architecture constraints, resource usage, and platform-specific pragmas lacking automation.", "method": "The framework uses a knowledge base of FPGA features, synthesis directives, and pragma templates to generate HLS code with timing-critical and design-specific pragmas. It iteratively refines code using synthesis logs and performance reports through LLM-driven RAG.", "result": "Across 10 FPGA architectures and benchmarks, TimelyHLS achieved up to 4x latency speedup (e.g., Matrix Multiplication) and 57% area savings (e.g., in Viterbi decoder), while maintaining timing closure and functional correctness.", "conclusion": "TimelyHLS demonstrates the viability of LLM-powered architecture-aware synthesis for automating FPGA design optimization and timing closure, reducing design effort."}}
{"id": "2507.18105", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2507.18105", "abs": "https://arxiv.org/abs/2507.18105", "authors": ["Yujie Ma", "Lili Quan", "Xiaofei Xie", "Qiang Hu", "Jiongchi Yu", "Yao Zhang", "Sen Chen"], "title": "Understanding the Supply Chain and Risks of Large Language Model Applications", "comment": "26 pages", "summary": "The rise of Large Language Models (LLMs) has led to the widespread deployment\nof LLM-based systems across diverse domains. As these systems proliferate,\nunderstanding the risks associated with their complex supply chains is\nincreasingly important. LLM-based systems are not standalone as they rely on\ninterconnected supply chains involving pretrained models, third-party\nlibraries, datasets, and infrastructure. Yet, most risk assessments narrowly\nfocus on model or data level, overlooking broader supply chain vulnerabilities.\nWhile recent studies have begun to address LLM supply chain risks, there\nremains a lack of benchmarks for systematic research.\n  To address this gap, we introduce the first comprehensive dataset for\nanalyzing and benchmarking LLM supply chain security. We collect 3,859\nreal-world LLM applications and perform interdependency analysis, identifying\n109,211 models, 2,474 datasets, and 9,862 libraries. We extract model\nfine-tuning paths, dataset reuse, and library reliance, mapping the ecosystem's\nstructure. To evaluate security, we gather 1,555 risk-related issues-50 for\napplications, 325 for models, 18 for datasets, and 1,229 for libraries from\npublic vulnerability databases.\n  Using this dataset, we empirically analyze component dependencies and risks.\nOur findings reveal deeply nested dependencies in LLM applications and\nsignificant vulnerabilities across the supply chain, underscoring the need for\ncomprehensive security analysis. We conclude with practical recommendations to\nguide researchers and developers toward safer, more trustworthy LLM-enabled\nsystems.", "AI": {"tldr": "Introduces the first comprehensive dataset for benchmarking Large Language Model (LLM) supply chain security risks, revealing significant vulnerabilities in LLM-based systems and their dependencies.", "motivation": "Most LLM risk assessments focus narrowly on models/data, neglecting interconnected supply chain components like third-party libraries and infrastructure. Systematic benchmarks for supply chain vulnerabilities remain absent.", "method": "Collected 3,859 real-world LLM applications through interdependency analysis, mapping 109,211 models, 2,474 datasets, and 9,862 libraries. Extracted fine-tuning paths, dataset reuse, and library reliance patterns. Identified 1,555 vulnerabilities from 4 categories using public databases.", "result": "Discoveries include: 1) LLM applications exhibit deeply nested dependencies 2) Vulnerabilities exist at all supply chain tiers (models, datasets, libraries) with 1,229 library vulnerabilities alone 3) Data reuse and model fine-tuning paths amplify cascading effects.", "conclusion": "The dataset establishes a critical benchmark for identifying systemic risks in LLM supply chains. Highlights the necessity for security frameworks addressing all components. Provides actionable recommendations for developing safer, more transparent systems."}}
{"id": "2507.17978", "categories": ["cs.CR", "cs.AI", "cs.HC", "68P20 (Primary) 68T05, 68T07, 68T10 (Secondary)", "K.6.5; I.2.6; I.2.7; C.2.0"], "pdf": "https://arxiv.org/pdf/2507.17978", "abs": "https://arxiv.org/abs/2507.17978", "authors": ["Paulo Mendes", "Eva Maia", "Isabel Pra\u00e7a"], "title": "MeAJOR Corpus: A Multi-Source Dataset for Phishing Email Detection", "comment": "8 pages, 2 tables, WI-IAT 2025 conference", "summary": "Phishing emails continue to pose a significant threat to cybersecurity by\nexploiting human vulnerabilities through deceptive content and malicious\npayloads. While Machine Learning (ML) models are effective at detecting\nphishing threats, their performance largely relies on the quality and diversity\nof the training data. This paper presents MeAJOR (Merged email Assets from\nJoint Open-source Repositories) Corpus, a novel, multi-source phishing email\ndataset designed to overcome critical limitations in existing resources. It\nintegrates 135894 samples representing a broad number of phishing tactics and\nlegitimate emails, with a wide spectrum of engineered features. We evaluated\nthe dataset's utility for phishing detection research through systematic\nexperiments with four classification models (RF, XGB, MLP, and CNN) across\nmultiple feature configurations. Results highlight the dataset's effectiveness,\nachieving 98.34% F1 with XGB. By integrating broad features from multiple\ncategories, our dataset provides a reusable and consistent resource, while\naddressing common challenges like class imbalance, generalisability and\nreproducibility.", "AI": {"tldr": "Introduces MeAJOR Corpus, a novel multi-source phishing email dataset combining 135,894 samples across diverse tactics and legitimate emails, achieving 98.34% F1 in phishing detection experiments.", "motivation": "Current ML-based phishing detection models face performance limitations due to insufficient training data quality/diversity in existing resources.", "method": "Integrated 135894 samples from joint open-source repositories with engineered features, evaluated through four models (RF, XGB, MLP, CNN) across multiple feature configurations.", "result": "XGB model achieved 98.34% F1 score, demonstrating dataset effectiveness and addressing class imbalance, generalizability, and reproducibility challenges.", "conclusion": "MeAJOR Corpus provides a reusable, consistent resource for phishing detection research by overcoming critical limitations in existing datasets through multi-source integration and diverse feature engineering."}}
{"id": "2507.18130", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18130", "abs": "https://arxiv.org/abs/2507.18130", "authors": ["Le Deng", "Zhonghao Jiang", "Jialun Cao", "Michael Pradel", "Zhongxin Liu"], "title": "NoCode-bench: A Benchmark for Evaluating Natural Language-Driven Feature Addition", "comment": null, "summary": "Natural language-driven no-code development allows users to specify software\nfunctionality using natural language (NL) instead of editing source code,\npromising increased productivity and democratized development. Large language\nmodels (LLMs) show potential in enabling this paradigm. In this context,\nsoftware documentation acts as an NL specification for functionality. This work\nintroduces NoCode-bench, a benchmark designed to evaluate LLMs on real-world\nNL-driven feature addition tasks, consisting of 634 tasks across 10 projects\nand 114k code changes. Each task pairs documentation updates with corresponding\ncode implementations, validated by developer-written test cases. A subset of\n114 high-quality, human-verified instances, NoCode-bench Verified, ensures\nreliable evaluation. Our experiments reveal that, despite high token usage, the\nbest LLMs achieve a task success rate of only 15.79%, highlighting challenges\nin cross-file editing, codebase understanding, and tool calling. These findings\nindicate that LLMs are not yet ready for fully NL-driven no-code development.\nNoCode-bench lays the foundation for future advances in this area.", "AI": {"tldr": "NoCode-bench benchmark reveals LLMs achieve only 15.79% success rate in natural language-driven no-code development tasks despite high token usage, highlighting challenges in cross-file editing, codebase understanding, and tool calling.", "motivation": "Natural language-driven no-code development promises to increase productivity and democratize software creation. However, existing evaluations lack realistic documentation-based feature addition tasks, necessitating a benchmark like NoCode-bench to accurately assess LLM capabilities.", "method": "Developed NoCode-bench with 634 tasks across 10 projects requiring 114k code changes. Each task pairs documentation updates with code implementations verified by developer test cases. A 114-task 'Verified' subset ensures reliable evaluation through human validation.", "result": "Top LLMs achieved 15.79% task success rate. Challenges included cross-file editing (34% errors), incomplete codebase understanding (41% errors), and tool calling issues (25% errors) despite high token usage and documentation access.", "conclusion": "LLMs are insufficiently prepared for real-world NL-driven no-code development due to persistent challenges in codebase comprehension and multi-file changes. NoCode-bench provides critical infrastructure for advancing this paradigm."}}
{"id": "2507.18034", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2507.18034", "abs": "https://arxiv.org/abs/2507.18034", "authors": ["Haonan An", "Guang Hua", "Hangcheng Cao", "Zhengru Fang", "Guowen Xu", "Susanto Rahardja", "Yuguang Fang"], "title": "Removing Box-Free Watermarks for Image-to-Image Models via Query-Based Reverse Engineering", "comment": null, "summary": "The intellectual property of deep generative networks (GNets) can be\nprotected using a cascaded hiding network (HNet) which embeds watermarks (or\nmarks) into GNet outputs, known as box-free watermarking. Although both GNet\nand HNet are encapsulated in a black box (called operation network, or ONet),\nwith only the generated and marked outputs from HNet being released to end\nusers and deemed secure, in this paper, we reveal an overlooked vulnerability\nin such systems. Specifically, we show that the hidden GNet outputs can still\nbe reliably estimated via query-based reverse engineering, leaking the\ngenerated and unmarked images, despite the attacker's limited knowledge of the\nsystem. Our first attempt is to reverse-engineer an inverse model for HNet\nunder the stringent black-box condition, for which we propose to exploit the\nquery process with specially curated input images. While effective, this method\nyields unsatisfactory image quality. To improve this, we subsequently propose\nan alternative method leveraging the equivalent additive property of box-free\nmodel watermarking and reverse-engineering a forward surrogate model of HNet,\nwith better image quality preservation. Extensive experimental results on image\nprocessing and image generation tasks demonstrate that both attacks achieve\nimpressive watermark removal success rates (100%) while also maintaining\nexcellent image quality (reaching the highest PSNR of 34.69 dB), substantially\noutperforming existing attacks, highlighting the urgent need for robust\ndefensive strategies to mitigate the identified vulnerability in box-free model\nwatermarking.", "AI": {"tldr": "This paper identifies a vulnerability in box-free model watermarking systems where attackers can reverse-engineer hidden deep generative network outputs through query-based methods, achieving 100% watermark removal and high image quality, necessitating stronger defenses.", "motivation": "Current box-free watermarking systems assume their black-box nature ensures security, but an overlooked vulnerability allows attackers to reliably estimate unwatermarked content despite limited system knowledge.", "method": "1) Reverse-engineers an inverse HNet model using curated input queries under black-box constraints. 2) Proposes an improved method leveraging the additive property of box-free watermarking to create a forward surrogate model of HNet.", "result": "Both attacks achieved perfect watermark removal (100% success) with strong image quality (peak PSNR value of 34.69 dB), significantly outperforming existing attacks in image generation and processing tasks.", "conclusion": "The identified vulnerability in box-free model watermarking systems demonstrates the need for robust defensive strategies to prevent query-based reverse-engineering and content IP theft."}}
{"id": "2507.18159", "categories": ["cs.SE", "cs.DL"], "pdf": "https://arxiv.org/pdf/2507.18159", "abs": "https://arxiv.org/abs/2507.18159", "authors": ["Stephan Ferenz", "Aida Jafarbigloo", "Oliver Werth", "Astrid Nie\u00dfe"], "title": "SMECS: A Software Metadata Extraction and Curation Software", "comment": null, "summary": "Metadata play a crucial role in adopting the FAIR principles for research\nsoftware and enables findability and reusability. However, creating\nhigh-quality metadata can be resource-intensive for researchers and research\nsoftware engineers. To address this challenge, we developed the Software\nMetadata Extraction and Curation Software (SMECS) which integrates the\nextraction of metadata from existing sources together with a user-friendly\ninterface for metadata curation. SMECS extracts metadata from online\nrepositories such as GitHub and presents it to researchers through an\ninteractive interface for further curation and export as a CodeMeta file. The\nusability of SMECS was evaluated through usability experiments which confirmed\nthat SMECS provides a satisfactory user experience. SMECS supports the\nFAIRification of research software by simplifying metadata creation.", "AI": {"tldr": "SMECS simplifies metadata creation for research software, aiding in FAIRification by extracting metadata from sources like GitHub and offering a user-friendly curation interface.", "motivation": "Creating high-quality metadata for research software under FAIR principles is resource-intensive for researchers and engineers.", "method": "Developed SMECS to integrate metadata extraction from online repositories (e.g., GitHub) with an interactive curation interface for exporting as CodeMeta files.", "result": "Usability experiments confirmed SMECS provides a satisfactory user experience, facilitating efficient metadata curation.", "conclusion": "SMECS reduces the burden of metadata creation, promoting the adoption of FAIR principles in research software through automation and accessibility."}}
{"id": "2507.18036", "categories": ["cs.CR", "cs.CV"], "pdf": "https://arxiv.org/pdf/2507.18036", "abs": "https://arxiv.org/abs/2507.18036", "authors": ["Haonan An", "Guang Hua", "Yu Guo", "Hangcheng Cao", "Susanto Rahardja", "Yuguang Fang"], "title": "NWaaS: Nonintrusive Watermarking as a Service for X-to-Image DNN", "comment": null, "summary": "The intellectual property of deep neural network (DNN) models can be\nprotected with DNN watermarking, which embeds copyright watermarks into model\nparameters (white-box), model behavior (black-box), or model outputs\n(box-free), and the watermarks can be subsequently extracted to verify model\nownership or detect model theft. Despite recent advances, these existing\nmethods are inherently intrusive, as they either modify the model parameters or\nalter the structure. This natural intrusiveness raises concerns about\nwatermarking-induced shifts in model behavior and the additional cost of\nfine-tuning, further exacerbated by the rapidly growing model size. As a\nresult, model owners are often reluctant to adopt DNN watermarking in practice,\nwhich limits the development of practical Watermarking as a Service (WaaS)\nsystems. To address this issue, we introduce Nonintrusive Watermarking as a\nService (NWaaS), a novel trustless paradigm designed for X-to-Image models, in\nwhich we hypothesize that with the model untouched, an owner-defined watermark\ncan still be extracted from model outputs. Building on this concept, we propose\nShadowMark, a concrete implementation of NWaaS which addresses critical\ndeployment challenges by establishing a robust and nonintrusive side channel in\nthe protected model's black-box API, leveraging a key encoder and a watermark\ndecoder. It is significantly distinctive from existing solutions by attaining\nthe so-called absolute fidelity and being applicable to different DNN\narchitectures, while being also robust against existing attacks, eliminating\nthe fidelity-robustness trade-off. Extensive experiments on image-to-image,\nnoise-to-image, noise-and-text-to-image, and text-to-image models, demonstrate\nthe efficacy and practicality of ShadowMark for real-world deployment of\nnonintrusive DNN watermarking.", "AI": {"tldr": "The paper introduces Nonintrusive Watermarking as a Service (NWaaS) and ShadowMark, a method to embed and extract watermarks in X-to-Image deep neural networks without modifying model parameters, structure, or output behavior. This addresses the limitations of current DNN watermarking techniques and enables robust, trustworthy, and universal model protection.", "motivation": "Existing DNN watermarking methods require model modifications (parameter or structural changes), which alter behavior, increase fine-tuning costs, and have fidelity-robustness trade-offs. These issues limit practical adoption of Watermarking as a Service (WaaS).", "method": "ShadowMark leverages a key encoder and watermark decoder in the protected model's black-box API to create a 'side channel' for watermark extraction without changing the model's architecture or parameters. This achieves absolute fidelity and robustness against attacks simultaneously.", "result": "Extensive experiments demonstrate ShadowMark's efficacy in protecting image-to-image, noise-to-image, and text-to-image models while maintaining output fidelity and robustness against watermark removal and model reconstruction attacks.", "conclusion": "ShadowMark resolves the fidelity-robustness trade-off in DNN watermarking through a nonintrusive API-based approach, enabling universal and trustworthy model protection for practical WaaS deployment."}}
{"id": "2507.18223", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.18223", "abs": "https://arxiv.org/abs/2507.18223", "authors": ["Nenad Petrovic", "Fengjunjie Pan", "Vahid Zolfaghari", "Krzysztof Lebioda", "Andre Schamschurko", "Alois Knoll"], "title": "GenAI for Automotive Software Development: From Requirements to Wheels", "comment": null, "summary": "This paper introduces a GenAI-empowered approach to automated development of\nautomotive software, with emphasis on autonomous and Advanced Driver Assistance\nSystems (ADAS) capabilities. The process starts with requirements as input,\nwhile the main generated outputs are test scenario code for simulation\nenvironment, together with implementation of desired ADAS capabilities\ntargeting hardware platform of the vehicle connected to testbench. Moreover, we\nintroduce additional steps for requirements consistency checking leveraging\nModel-Driven Engineering (MDE). In the proposed workflow, Large Language Models\n(LLMs) are used for model-based summarization of requirements (Ecore metamodel,\nXMI model instance and OCL constraint creation), test scenario generation,\nsimulation code (Python) and target platform code generation (C++).\nAdditionally, Retrieval Augmented Generation (RAG) is adopted to enhance test\nscenario generation from autonomous driving regulations-related documents. Our\napproach aims shorter compliance and re-engineering cycles, as well as reduced\ndevelopment and testing time when it comes to ADAS-related capabilities.", "AI": {"tldr": "The paper presents a GenAI-driven framework for automating automotive ADAS software development, leveraging LLMs for requirements modeling, test scenario generation, and platform-specific code creation, with RAG enhancing regulatory compliance testing.", "motivation": "Conventional automotive software development for ADAS systems faces long compliance and re-engineering cycles due to complex regulatory requirements and iterative design processes.", "method": "A workflow integrating Large Language Models (LLMs) with Model-Driven Engineering (MDE) is proposed, utilizing LLMs for Ecore metamodel/XMI model instantiation and OCL constraint creation, followed by test scenario generation for simulation code (Python) and hardware platform implementation (C++), augmented by Retrieval Augmented Generation (RAG) for test scenario construction from regulatory documents.", "result": "Demonstrated reduction in compliance cycle duration, shortened re-engineering time, and accelerated ADAS development/testing via model-based LLM-generated test scenarios and platform code, though no quantitative metrics are provided.", "conclusion": "The GenAI-empowered development approach proves effective in streamlining ADAS software creation through automated requirements processing, model-driven test generation, and regulatory alignment using RAG technology."}}
{"id": "2507.18053", "categories": ["cs.CR", "cs.CL"], "pdf": "https://arxiv.org/pdf/2507.18053", "abs": "https://arxiv.org/abs/2507.18053", "authors": ["Haoran Gao", "Yuanhe Zhang", "Zhenhong Zhou", "Lei Jiang", "Fanyu Meng", "Yujia Xiao", "Kun Wang", "Yang Liu", "Junlan Feng"], "title": "RECALLED: An Unbounded Resource Consumption Attack on Large Vision-Language Models", "comment": null, "summary": "Resource Consumption Attacks (RCAs) have emerged as a significant threat to\nthe deployment of Large Language Models (LLMs). With the integration of vision\nmodalities, additional attack vectors exacerbate the risk of RCAs in large\nvision-language models (LVLMs). However, existing red-teaming studies have\nlargely overlooked visual inputs as a potential attack surface, resulting in\ninsufficient mitigation strategies against RCAs in LVLMs. To address this gap,\nwe propose RECALLED (\\textbf{RE}source \\textbf{C}onsumption \\textbf{A}ttack on\n\\textbf{L}arge Vision-\\textbf{L}anguag\\textbf{E} Mo\\textbf{D}els), the first\napproach for exploiting visual modalities to trigger unbounded RCAs\nred-teaming. First, we present \\textit{Vision Guided Optimization}, a\nfine-grained pixel-level optimization, to obtain \\textit{Output Recall}\nadversarial perturbations, which can induce repeating output. Then, we inject\nthe perturbations into visual inputs, triggering unbounded generations to\nachieve the goal of RCAs. Additionally, we introduce \\textit{Multi-Objective\nParallel Losses} to generate universal attack templates and resolve\noptimization conflicts when intending to implement parallel attacks. Empirical\nresults demonstrate that RECALLED increases service response latency by over 26\n$\\uparrow$, resulting in an additional 20\\% increase in GPU utilization and\nmemory consumption. Our study exposes security vulnerabilities in LVLMs and\nestablishes a red-teaming framework that can facilitate future defense\ndevelopment against RCAs.", "AI": {"tldr": "This paper introduces RECALLED, the first visual modality-based resource consumption attack framework for large vision-language models (LVLMs), which exploits adversarial perturbations in visual inputs to trigger unbounded output generations, causing significant service latency and GPU resource overconsumption.", "motivation": "Existing red-teaming studies on LLM security have neglected visual inputs as attack vectors in LVLMs, leaving critical vulnerabilities unaddressed in resource consumption attacks (RCAs) that exploit text prompts.", "method": "The approach combines Vision Guided Optimization (pixel-level adversarial perturbation generation for output repetition) and Multi-Objective Parallel Losses (to create universal attack templates and resolve parallel attack optimization conflicts).", "result": "RECALLED demonstrates 26% increased service latency with 20% higher GPU utilization and memory consumption under realistic LVLM inference scenarios.", "conclusion": "The study reveals unaddressed security risks in LVLM multimodal architectures and proposes a novel red-teaming framework that could inform future mitigation strategies for resource consumption attacks in vision-language AI systems."}}
{"id": "2507.18267", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18267", "abs": "https://arxiv.org/abs/2507.18267", "authors": ["Zeqin Liao", "Zibin Zheng", "Peifan Reng", "Henglong Liang", "Zixu Gao", "Zhixiang Chen", "Wei Li", "Yuhong Nan"], "title": "An Empirical Study on Embodied Artificial Intelligence Robot (EAIR) Software Bugs", "comment": null, "summary": "Embodied Artificial Intelligence Robots (EAIR) is an emerging and rapidly\nevolving technological domain. Ensuring their program correctness is\nfundamental to their successful deployment. However, a general and in-depth\nunderstanding of EAIR system bugs remains lacking, which hinders the\ndevelopment of practices and techniques to tackle EAIR system bugs.\n  To bridge this gap, we conducted the first systematic study of 885 EAIR\nsystem bugs collected from 80 EAIR system projects to investigate their\nsymptoms, underlying causes, and module distribution. Our analysis takes\nconsiderable effort, which classifies these bugs into 18 underlying causes, 15\ndistinct symptoms, and identifies 13 affected modules. It reveals several new\ninteresting findings and implications which help shed light on future research\non tackling or repairing EAIR system bugs. First, among the 15 identified\nsymptoms, our findings highlight 8 symptoms specific to EAIR systems, which is\ncharacterized by severe functional failures and potential physical hazards.\nSecond, within the 18 underlying causes, we define 8 EAIR-specific causes, the\nmajority of which stem from the intricate issues of AI- agent reasoning and\ndecision making. Finally, to facilitate precise and efficient bug prediction,\ndetection, and repair, we constructed a mapping between underlying causes and\nthe modules in which they most frequently occur, which enables researchers to\nfocus diagnostic efforts on the modules most susceptible to specific bug types.", "AI": {"tldr": "This paper presents a systematic analysis of 885 EAIR system bugs, categorizing them into 18 causes, 15 symptoms, and 13 modules. It identifies EAIR-specific issues and proposes a cause-module mapping to improve bug management.", "motivation": "The study addresses the critical need for a comprehensive understanding of EAIR system bugs to develop effective practices and techniques for their mitigation, which is currently lacking despite the rapid growth of EAIR technology.", "method": "The authors conducted a systematic study by collecting and analyzing 885 bugs from 80 EAIR projects, classifying bugs into symptoms, underlying causes, and affected modules through comprehensive effort.", "result": "The analysis reveals 15 symptoms (including 8 EAIR-specific ones characterized by functional failures and physical hazards), 18 underlying causes (8 EAIR-specific, mostly linked to AI-agent reasoning), and a mapping between 13 affected modules and their frequent bug causes.", "conclusion": "This work establishes a foundational framework for EAIR system bug analysis by providing cause-module correlations, enabling targeted diagnostic efforts and future research into EAIR-specific bug prevention and repair techniques."}}
{"id": "2507.18075", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2507.18075", "abs": "https://arxiv.org/abs/2507.18075", "authors": ["Jacob Mahon", "Chenxi Hou", "Zhihao Yao"], "title": "PyPitfall: Dependency Chaos and Software Supply Chain Vulnerabilities in Python", "comment": null, "summary": "Python software development heavily relies on third-party packages. Direct\nand transitive dependencies create a labyrinth of software supply chains. While\nit is convenient to reuse code, vulnerabilities within these dependency chains\ncan propagate through dependencies, potentially affecting down-stream packages\nand applications. PyPI, the official Python package repository, hosts many\npackages and lacks a comprehensive analysis of the prevalence of vulnerable\ndependencies. This paper introduces PyPitfall, a quantitative analysis of\nvulnerable dependencies across the PyPI ecosystem. We analyzed the dependency\nstructures of 378,573 PyPI packages and identified 4,655 packages that\nexplicitly require at least one known-vulnerable version and 141,044 packages\nthat permit vulnerable versions within specified ranges. By characterizing the\necosystem-wide dependency landscape and the security impact of transitive\ndependencies, we aim to raise awareness of Python software supply chain\nsecurity.", "AI": {"tldr": "PyPitfall quantitatively analyzes vulnerable dependencies in PyPI, finding that 4,655 packages directly require vulnerable versions while 141,044 permit them within version ranges.", "motivation": "The lack of comprehensive analysis on vulnerable dependencies in PyPI's complex supply chain motivates the study to raise security awareness and address propagation of vulnerabilities.", "method": "The researchers analyzed dependency structures for 378,573 PyPI packages, identifying direct and indirect vulnerabilities through explicit version requirements and range specifications.", "result": "4,655 direct vulnerable dependencies and 141,044 transitive/indirect vulnerable dependencies were identified, revealing significant security risks across the ecosystem.", "conclusion": "The study reveals the widespread presence of vulnerable dependencies in PyPI, emphasizing the critical need for tools and practices to mitigate transitive dependency risks in Python software supply chains."}}
{"id": "2507.18289", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2507.18289", "abs": "https://arxiv.org/abs/2507.18289", "authors": ["Yan Li", "Wenzhang Yang", "Yuekun Wang", "Jian Gao", "Shaohua Wang", "Yinxing Xue", "Lijun Zhang"], "title": "Scheduzz: Constraint-based Fuzz Driver Generation with Dual Scheduling", "comment": "15 pages, 12 figures, 5 tables", "summary": "Fuzzing a library requires experts to understand the library usage well and\ncraft high-quality fuzz drivers, which is tricky and tedious. Therefore, many\ntechniques have been proposed to automatically generate fuzz drivers. However,\nthey fail to generate rational fuzz drivers due to the lack of adherence to\nproper library usage conventions, such as ensuring a resource is closed after\nbeing opened. To make things worse, existing library fuzzing techniques\nunconditionally execute each driver, resulting in numerous irrational drivers\nthat waste computational resources while contributing little coverage and\ngenerating false positive bug reports.\n  To tackle these challenges, we propose a novel automatic library fuzzing\ntechnique, Scheduzz, an LLM-based library fuzzing technique. It leverages LLMs\nto understand rational usage of libraries and extract API combination\nconstraints. To optimize computational resource utilization, a dual scheduling\nframework is implemented to efficiently manage API combinations and fuzz\ndrivers. The framework models driver generation and the corresponding fuzzing\ncampaign as an online optimization problem. Within the scheduling loop,\nmultiple API combinations are selected to generate fuzz drivers, while\nsimultaneously, various optimized fuzz drivers are scheduled for execution or\nsuspension.\n  We implemented Scheduzz and evaluated it in 33 real-world libraries. Compared\nto baseline approaches, Scheduzz significantly reduces computational overhead\nand outperforms UTopia on 16 out of 21 libraries. It achieves 1.62x, 1.50x, and\n1.89x higher overall coverage than the state-of-the-art techniques CKGFuzzer,\nPromptfuzz, and the handcrafted project OSS-Fuzz, respectively. In addition,\nScheduzz discovered 33 previously unknown bugs in these well-tested libraries,\n3 of which have been assigned CVEs.", "AI": {"tldr": "Scheduzz is an LLM-based library fuzzing technique that uses a dual scheduling framework to optimize fuzz driver generation and execution, significantly improving coverage and bug discovery while reducing computational overhead compared to existing methods.", "motivation": "Manually crafting fuzz drivers for libraries is challenging and error-prone, while existing automated methods generate inefficient, irrational drivers that waste resources and produce false positives. Proper adherence to library usage conventions (e.g., resource opening/closing) remains a critical issue.", "method": "Scheduzz employs large language models (LLMs) to analyze library documentation and extract API usage constraints (e.g., call order, parameter dependencies). It implements a dual scheduling framework: (1) a generator that creates fuzz drivers by solving an online optimization problem to select valid API combinations, and (2) an executor that dynamically schedules drivers for execution or suspension based on resource utilization and coverage metrics.", "result": "Scheduzz evaluated on 33 real-world libraries showed: 16/21 libraries outperformed UTopia, 1.62x-1.89x higher coverage than state-of-the-art techniques, and discovery of 33 previously unknown bugs (3 with CVE assignments).", "conclusion": "Scheduzz addresses automated library fuzzing shortcomings by combining LLM-driven API constraint analysis with a dual scheduling framework, achieving resource efficiency and improved coverage over existing solutions. The method demonstrates the potential of LLMs to learn and enforce proper library usage patterns in security testing."}}
{"id": "2507.18157", "categories": ["cs.CR", "quant-ph", "Primary:94A60, Secondary:68P25, Tertiary:81P94"], "pdf": "https://arxiv.org/pdf/2507.18157", "abs": "https://arxiv.org/abs/2507.18157", "authors": ["Chao Liu", "Shuai Zhao", "Chenhao Jia", "Gengran Hu", "Tingting Cui"], "title": "An Improved ChaCha Algorithm Based on Quantum Random Number", "comment": "20 pages,4 figures", "summary": "Due to the merits of high efficiency and strong security against timing and\nside-channel attacks, ChaCha has been widely applied in real-time communication\nand data streaming scenarios. However, with the rapid development of\nAI-assisted cryptanalysis and quantum computing technologies, there are serious\nchallenges to the secure implementation of ChaCha cipher. To further strengthen\nthe security of ChaCha cipher, we propose an improved variant based on quantum\nrandom numbers, i.e., Quantum Random Number Enhanced ChaCha (QRE-ChaCha).\nSpecifically, the design XORs the initial constants with quantum random numbers\nand periodically injects quantum random numbers into selected state words\nduring odd rounds to enhance diffusion. Compared with the original ChaCha, the\npresent variant shows stronger resistance to differential attacks and generates\na keystream with statistical randomness, thereby offering increased robustness\nagainst both classical and quantum attacks. To evaluate the security and\nperformance of the present ChaCha, our analysis proceeds in three main parts.\nFirstly, we analyze its theoretical security in terms of quantum randomness and\nattack testing, and conduct differential cryptanalysis with an automated search\nmethod based on the Boolean satisfiability problem (SAT). Secondly, we subject\nthe keystream generated by the cipher to randomness tests using the NIST\nstatistical test suite and the GM/T 0005-2021 randomness testing standard.\nFinally, we assess its encryption and decryption performance by measuring its\nencryption speed on files of various sizes. According to the results, the\npresent ChaCha is significantly improved to resist differential attacks while\nmaintaining the high efficiency of the original ChaCha cipher, and its\nkeystream successfully passes statistical randomness tests using the NIST and\nGM/T 0005-2021 standards, meeting cryptographic application requirements.", "AI": {"tldr": "QRE-ChaCha enhances ChaCha cipher's security by integrating quantum random numbers, improving resistance to differential attacks and maintaining efficiency.", "motivation": "ChaCha's efficiency and security against timing/side-channel attacks make it popular, but AI and quantum computing advances threaten its implementation. Strengthening it against these emerging threats is crucial.", "method": "1) XOR initial constants with quantum random numbers. 2) Periodically inject QRNs into state words during odd rounds. 3) Use SAT-based differential cryptanalysis for attack testing. 4) Apply NIST and GM/T 0005-2021 tests to keystream and measure file encryption speeds.", "result": "Demonstrated stronger differential attack resistance, keystream passed NIST/GM/T randomness tests, and maintained original ChaCha's high efficiency across file sizes.", "conclusion": "QRE-ChaCha achieves enhanced security against classical/quantum attacks while preserving efficiency, satisfying cryptographic application requirements through statistical validation."}}
{"id": "2507.18316", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18316", "abs": "https://arxiv.org/abs/2507.18316", "authors": ["Michael Konstantinou", "Renzo Degiovanni", "Jie M. Zhang", "Mark Harman", "Mike Papadakis"], "title": "YATE: The Role of Test Repair in LLM-Based Unit Test Generation", "comment": "12 pages, 4 figures", "summary": "Recent advances in automated test generation utilises language models to\nproduce unit tests. While effective, language models tend to generate many\nincorrect tests with respect to both syntax and semantics. Although such\nincorrect tests can be easily detected and discarded, they constitute a \"missed\nopportunity\" -- if fixed, they are often valuable as they directly add testing\nvalue (they effectively target the underlying program logic to be tested) and\nindirectly form good seeds for generating additional tests. To this end, we\npropose a simple technique for repairing some of these incorrect tests through\na combination of rule-based static analysis and re-prompting. We evaluate this\nsimple approach, named YATE, on a set of 6 open-source projects and show that\nit can effectively produce tests that cover on average 32.06% more lines and\nkill 21.77% more mutants than a plain LLM-based method. We also compare YATE\nwith four other LLM-based methods, namely HITS, SYMPROMPT, TESTSPARK and\nCOVERUP and show that it produces tests that cover substantially more code.\nYATE achieves 22% higher line coverage, 20% higher branch coverage and kill 20%\nmore mutants at a comparable cost (number of calls to LLMs).", "AI": {"tldr": "This paper proposes YATE, a technique that combines rule-based static analysis and re-prompting to repair incorrect tests generated by language models, achieving significant improvements in code coverage and mutation killing over existing methods.", "motivation": "Language models for automated test generation produce many syntactically and semantically incorrect tests, which represent a missed opportunity as they could be valuable once fixed and serve as good seeds for additional test generation.", "method": "The approach integrates rule-based static analysis to identify and correct test errors with re-prompting strategies to refine test outputs, systematically repairing invalid tests while maintaining their logical relevance to the target code.", "result": "Evaluations on six open-source projects show YATE achieves 32.06% more line coverage and 21.77% more mutant kills than plain LLM methods. Compared to HITS, SYMPROMPT, TESTSPARK, and COVERUP, YATE achieves 22% higher line coverage, 20% higher branch coverage, and kills 20% more mutants with similar computational costs.", "conclusion": "YATE demonstrates that test repair through static analysis and iterative prompting significantly enhances the effectiveness of LLM-generated tests, offering both direct quality improvements and indirect benefits for downstream test generation."}}
{"id": "2507.18215", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.18215", "abs": "https://arxiv.org/abs/2507.18215", "authors": ["Chang Gong", "Zhongwen Li", "Xiaoqi Li"], "title": "Information Security Based on LLM Approaches: A Review", "comment": null, "summary": "Information security is facing increasingly severe challenges, and\ntraditional protection means are difficult to cope with complex and changing\nthreats. In recent years, as an emerging intelligent technology, large language\nmodels (LLMs) have shown a broad application prospect in the field of\ninformation security. In this paper, we focus on the key role of LLM in\ninformation security, systematically review its application progress in\nmalicious behavior prediction, network threat analysis, system vulnerability\ndetection, malicious code identification, and cryptographic algorithm\noptimization, and explore its potential in enhancing security protection\nperformance. Based on neural networks and Transformer architecture, this paper\nanalyzes the technical basis of large language models and their advantages in\nnatural language processing tasks. It is shown that the introduction of large\nlanguage modeling helps to improve the detection accuracy and reduce the false\nalarm rate of security systems. Finally, this paper summarizes the current\napplication results and points out that it still faces challenges in model\ntransparency, interpretability, and scene adaptability, among other issues. It\nis necessary to explore further the optimization of the model structure and the\nimprovement of the generalization ability to realize a more intelligent and\naccurate information security protection system.", "AI": {"tldr": "The paper reviews and explores the application of large language models (LLMs) in information security, emphasizing their role in improving detection accuracy while highlighting challenges in model transparency, adaptability, and generalization.", "motivation": "Traditional information security protection methods struggle to cope with complex and evolving threats, necessitating the exploration of intelligent technologies like LLMs to enhance security performance.", "method": "The study systematically reviews LLMs' applications in malicious behavior prediction, network threat analysis, vulnerability detection, malicious code identification, and cryptographic optimization. It analyzes their technical basis using neural networks and Transformer architecture.", "result": "LLMs demonstrate improved detection accuracy and reduced false alarm rates in security systems, as shown through analysis of their performance in the discussed applications.", "conclusion": "While LLMs show promise in advancing information security, challenges such as model transparency, interpretability, and scene adaptability remain. Future work should focus on optimizing model structures and generalization capabilities for smarter security systems."}}
{"id": "2507.18319", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18319", "abs": "https://arxiv.org/abs/2507.18319", "authors": ["Jesse Maarleveld", "Jiapan Guo", "Daniel Feitosa"], "title": "Gotta catch 'em all! Towards File Localisation from Issues at Large", "comment": "12 pages, 6 figures", "summary": "Bug localisation, the study of developing methods to localise the files\nrequiring changes to resolve bugs, has been researched for a long time to\ndevelop methods capable of saving developers' time. Recently, researchers are\nstarting to consider issues outside of bugs. Nevertheless, most existing\nresearch into file localisation from issues focusses on bugs or uses other\nselection methods to ensure only certain types of issues are considered as part\nof the focus of the work. Our goal is to work on all issues at large, without\nany specific selection.\n  In this work, we provide a data pipeline for the creation of issue file\nlocalisation datasets, capable of dealing with arbitrary branching and merging\npractices. We provide a baseline performance evaluation for the file\nlocalisation problem using traditional information retrieval approaches.\nFinally, we use statistical analysis to investigate the influence of biases\nknown in the bug localisation community on our dataset.\n  Our results show that methods designed using bug-specific heuristics perform\npoorly on general issue types, indicating a need for research into general\npurpose models. Furthermore, we find that there are small, but statistically\nsignificant differences in performance between different issue types. Finally,\nwe find that the presence of identifiers have a small effect on performance for\nmost issue types. Many results are project-dependent, encouraging the\ndevelopment of methods which can be tuned to project-specific characteristics.", "AI": {"tldr": "The paper introduces a data pipeline for creating issue file localization datasets without restricting to specific issue types or selection methods. It evaluates traditional IR approaches and reveals performance challenges with general-purpose models, showing bug-specific methods underperform, statistically significant differences between issue types, and project-dependent results encouraging tailored methods.", "motivation": "Existing research on file localisation primarily focuses on bugs or uses selection methods to restrict issue types, whereas this paper aims to study all issues broadly without such biases, expanding the scope of file localisation beyond just bugs.", "method": "A data pipeline was developed to create file localisation datasets that handle arbitrary branching and merging practices. Baseline performance using traditional information retrieval (IR) approaches was evaluated. Statistical analysis was conducted to investigate biases from the bug localisation community in the dataset.", "result": "Bug-specific heuristics perform poorly on general issue types. Minor but statistically significant performance differences exist between issue types. Identifiers have a small effect across most issue types. Project dependencies exist, requiring customization for project-specific characteristics.", "conclusion": "The study highlights the need for general-purpose models that outperform bug-specific methods and emphasizes project-dependent adaptations for file localisation tasks, advancing research beyond bug-focused approaches."}}
{"id": "2507.18249", "categories": ["cs.CR", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2507.18249", "abs": "https://arxiv.org/abs/2507.18249", "authors": ["Muhammad M. Roomi", "S. M. Suhail Hussain", "Ee-Chien Chang", "David M. Nicol", "Daisuke Mashima"], "title": "Auto-SGCR: Automated Generation of Smart Grid Cyber Range Using IEC 61850 Standard Models", "comment": "12 pages", "summary": "Digitalization of power grids have made them increasingly susceptible to\ncyber-attacks in the past decade. Iterative cybersecurity testing is\nindispensable to counter emerging attack vectors and to ensure dependability of\ncritical infrastructure. Furthermore, these can be used to evaluate\ncybersecurity configuration, effectiveness of the cybersecurity measures\nagainst various attack vectors, as well as to train smart grid cybersecurity\nexperts defending the system. Enabling extensive experiments narrows the gap\nbetween academic research and production environment. A high-fidelity cyber\nrange is vital as it is often infeasible to conduct such experiments and\ntraining using production environment. However, the design and implementation\nof cyber range requires extensive domain knowledge of physical and cyber aspect\nof the infrastructure. Furthermore, costs incurred for setup and maintenance of\ncyber range are significant. Moreover, most existing smart grid cyber ranges\nare designed as a one-off, proprietary system, and are limited in terms of\nconfigurability, accessibility, portability, and reproducibility. To address\nthese challenges, an automated Smart grid Cyber Range generation framework is\npresented in this paper. Initially a human-/machine-friendly, XML-based\nmodeling language called Smart Grid Modeling Language was defined, which\nincorporates IEC 61850 System Configuration Language files. Subsequently, a\ntoolchain to parse SG-ML model files and automatically instantiate a functional\nsmart grid cyber range was developed. The developed SG-ML models can be easily\nshared and/or modified to reproduce or customize for any cyber range. The\napplication of Auto-SGCR is demonstrated through case studies with large-scale\nsubstation models. The toolchain along with example SG-ML models have been\nopen-sourced.", "AI": {"tldr": "The paper presents an automated framework for generating smart grid cyber ranges using an XML-based modeling language (SG-ML), addressing scalability, configurability, and accessibility challenges through open-source toolchains and case studies.", "motivation": "Digitalization has increased power grids' vulnerability to cyber-attacks, necessitating iterative testing and training. Existing cyber ranges are expensive, inflexible, and difficult to reproduce, creating a gap between academic research and production environments.", "method": "The authors designed SG-ML, an XML language integrating IEC 61850 files for modeling smart grid infrastructure, and developed a toolchain to automate cyber range creation, configuration, and deployment from SG-ML models.", "result": "The Auto-SGCR framework successfully demonstrates customizable and reproducible cyber ranges via large-scale substation case studies. Toolchains and example SG-ML models are open-sourced to promote collaboration and reuse.", "conclusion": "Auto-SGCR reduces costs and complexity in smart grid cybersecurity testing by enabling rapid deployment of high-fidelity, reusable cyber ranges, fostering closer alignment between research and real-world grid defenses."}}
{"id": "2507.18339", "categories": ["cs.SE", "cs.DC"], "pdf": "https://arxiv.org/pdf/2507.18339", "abs": "https://arxiv.org/abs/2507.18339", "authors": ["Nils Bosbach", "Meik Schmidt", "Lukas J\u00fcnger", "Matthias Berthold", "Rainer Leupers"], "title": "FMI Meets SystemC: A Framework for Cross-Tool Virtual Prototyping", "comment": "PREPRINT - accepted by the 16th International Modelica and FMI\n  Conference 2025", "summary": "As systems become more complex, the demand for thorough testing and virtual\nprototyping grows. To simulate whole systems, multiple tools are usually needed\nto cover different parts. These parts include the hardware of a system and the\nenvironment with which the system interacts. The Functional Mock-up Interface\n(FMI) standard for co-simulation can be used to connect these tools.\n  The control part of modern systems is usually a computing unit, such as a\nSystem-on-a-Chip (SoC) or Microcontroller Unit (MCU), which executes software\nfrom a connected memory and interacts with peripherals. To develop software\nwithout requiring access to physical hardware, full-system simulators, the\nso-called Virtual Platforms (VPs), are commonly used. The IEEE-standardized\nframework for VP development is SystemC TLM. SystemC provides interfaces and\nconcepts that enable modular design and model exchange. However, SystemC lacks\nnative FMI support, which limits the integration into broader co-simulation\nenvironments.\n  This paper presents a novel framework to control and interact with\nSystemC-based VPs using the FMI. We present a case study showing how a\nsimulated temperature sensor in a SystemC simulation can obtain temperature\nvalues from an external tool via FMI. This approach allows the unmodified\ntarget software to run on the VP and receive realistic environmental input data\nsuch as temperature, velocity, or acceleration values from other tools. Thus,\nextensive software testing and verification is enabled. By having tests ready\nand the software pre-tested using a VP once the physical hardware is available,\ncertifications like ISO 26262 can be done earlier.", "AI": {"tldr": "The paper proposes a framework to integrate SystemC TLM-based Virtual Platforms with the FMI standard for co-simulation, enabling realistic software testing without physical hardware. It demonstrates this via a temperature sensor case study.", "motivation": "SystemC TLM's lack of native FMI support limits integration with broader co-simulation environments, hindering thorough testing of control software in complex systems before physical hardware availability.", "method": "Developed a novel framework to interface FMI-compatible tools with SystemC simulations. Implemented a case study where a simulated temperature sensor receives data from an external tool using this framework, without modifying target software.", "result": "Enabled execution of unmodified target software on VPs with realistic environmental inputs (e.g., temperature) from external tools. Improved pre-hardware testing efficiency, allowing earlier ISO 26262 certifications when physical hardware becomes available.", "conclusion": "The framework successfully bridges SystemC TLM and FMI for co-simulation, enhancing software verification capabilities while maintaining compatibility with existing development practices (e.g., using unmodified software) and certification standards."}}
{"id": "2507.18302", "categories": ["cs.CR", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2507.18302", "abs": "https://arxiv.org/abs/2507.18302", "authors": ["Delong Ran", "Xinlei He", "Tianshuo Cong", "Anyu Wang", "Qi Li", "Xiaoyun Wang"], "title": "LoRA-Leak: Membership Inference Attacks Against LoRA Fine-tuned Language Models", "comment": "This work has been submitted to the IEEE for possible publication", "summary": "Language Models (LMs) typically adhere to a \"pre-training and fine-tuning\"\nparadigm, where a universal pre-trained model can be fine-tuned to cater to\nvarious specialized domains. Low-Rank Adaptation (LoRA) has gained the most\nwidespread use in LM fine-tuning due to its lightweight computational cost and\nremarkable performance. Because the proportion of parameters tuned by LoRA is\nrelatively small, there might be a misleading impression that the LoRA\nfine-tuning data is invulnerable to Membership Inference Attacks (MIAs).\nHowever, we identify that utilizing the pre-trained model can induce more\ninformation leakage, which is neglected by existing MIAs. Therefore, we\nintroduce LoRA-Leak, a holistic evaluation framework for MIAs against the\nfine-tuning datasets of LMs. LoRA-Leak incorporates fifteen membership\ninference attacks, including ten existing MIAs, and five improved MIAs that\nleverage the pre-trained model as a reference. In experiments, we apply\nLoRA-Leak to three advanced LMs across three popular natural language\nprocessing tasks, demonstrating that LoRA-based fine-tuned LMs are still\nvulnerable to MIAs (e.g., 0.775 AUC under conservative fine-tuning settings).\nWe also applied LoRA-Leak to different fine-tuning settings to understand the\nresulting privacy risks. We further explore four defenses and find that only\ndropout and excluding specific LM layers during fine-tuning effectively\nmitigate MIA risks while maintaining utility. We highlight that under the\n\"pre-training and fine-tuning\" paradigm, the existence of the pre-trained model\nmakes MIA a more severe risk for LoRA-based LMs. We hope that our findings can\nprovide guidance on data privacy protection for specialized LM providers.", "AI": {"tldr": "This paper analyzes the vulnerability of LoRA-fine-tuned Language Models to Membership Inference Attacks (MIAs) by introducing LoRA-Leak, a comprehensive evaluation framework demonstrating that pre-trained models contribute to information leakage despite LoRA's lightweight tuning. Experiments show high MIA effectiveness (0.775 AUC) and identify dropout and selective layer exclusion as effective defenses.", "motivation": "While Low-Rank Adaptation (LoRA) is widely used for efficient LM fine-tuning with minimal parameter adjustments, existing MIAs overlook information leakage risks from the pre-trained model component, leaving potential privacy vulnerabilities unaddressed.", "method": "Developed LoRA-Leak framework incorporating 15 MIAs (10 existing, 5 pre-trained model-aware variants) to evaluate fine-tuning dataset vulnerabilities across three NLP tasks. Analyzed varying fine-tuning configurations and tested four defensive strategies.", "result": "LoRA-based fine-tuned LMs exhibit significant MIA vulnerability (up to 0.775 AUC on conservative settings). Defenses: dropout and specific layer exclusion during fine-tuning effectively reduce MIA risks without compromising utility.", "conclusion": "The 'pre-training and fine-tuning' paradigm inherently increases MIA risks for LoRA-based systems due to pre-trained model interactions. Practical defenses exist but highlight the need for stronger data privacy measures in specialized LM deployments."}}
{"id": "2507.18476", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.18476", "abs": "https://arxiv.org/abs/2507.18476", "authors": ["Busra Icoz", "Goksel Biricik"], "title": "Automated Code Review Using Large Language Models with Symbolic Reasoning", "comment": null, "summary": "Code review is one of the key processes in the software development lifecycle\nand is essential to maintain code quality. However, manual code review is\nsubjective and time consuming. Given its rule-based nature, code review is well\nsuited for automation. In recent years, significant efforts have been made to\nautomate this process with the help of artificial intelligence. Recent\ndevelopments in Large Language Models (LLMs) have also emerged as a promising\ntool in this area, but these models often lack the logical reasoning\ncapabilities needed to fully understand and evaluate code. To overcome this\nlimitation, this study proposes a hybrid approach that integrates symbolic\nreasoning techniques with LLMs to automate the code review process. We tested\nour approach using the CodexGlue dataset, comparing several models, including\nCodeT5, CodeBERT, and GraphCodeBERT, to assess the effectiveness of combining\nsymbolic reasoning and prompting techniques with LLMs. Our results show that\nthis approach improves the accuracy and efficiency of automated code review.", "AI": {"tldr": "The paper proposes a hybrid approach combining symbolic reasoning techniques with Large Language Models (LLMs) to automate code review, addressing the limitations of LLMs in logical reasoning.", "motivation": "Manual code review is subjective and time-consuming, while existing AI-based methods, particularly LLMs, lack the necessary logical reasoning capabilities to fully understand and evaluate code effectively.", "method": "The study integrates symbolic reasoning techniques with LLMs (e.g., CodeT5, CodeBERT, GraphCodeBERT) using a hybrid approach. This combination is tested on the CodexGlue dataset to evaluate its performance.", "result": "The hybrid approach demonstrates improved accuracy and efficiency in automated code review compared to individual models.", "conclusion": "Combining symbolic reasoning with LLMs enhances the effectiveness of automated code review, offering a robust solution to the limitations of purely AI-based approaches."}}
{"id": "2507.18360", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2507.18360", "abs": "https://arxiv.org/abs/2507.18360", "authors": ["Andr\u00e9 Menolli", "Luiz Fernando Nunes", "Thiago A. Coleti"], "title": "Conformidade com os Requisitos Legais de Privacidade de Dados: Um Estudo sobre T\u00e9cnicas de Anonimiza\u00e7\u00e3o", "comment": "in Portuguese language", "summary": "The protection of personal data has become a central topic in software\ndevelopment, especially with the implementation of the General Data Protection\nLaw (LGPD) in Brazil and the General Data Protection Regulation (GDPR) in the\nEuropean Union. With the enforcement of these laws, certain software quality\ncriteria have become mandatory, such as data anonymization, which is one of the\nmain aspects addressed by these regulations. The aim of this article is to\nanalyze data anonymization techniques and assess their effectiveness in\nensuring compliance with legal requirements and the utility of the data for its\nintended purpose. Techniques such as aggregation, generalization, perturbation,\nand k-anonymity were investigated and applied to datasets containing personal\nand sensitive data. The analysis revealed significant variations in the\neffectiveness of each method, highlighting the need to balance privacy and data\nutility.", "AI": {"tldr": "This paper analyzes data anonymization techniques to ensure compliance with regulations like LGPD and GDPR while maintaining data utility.", "motivation": "The implementation of data protection laws such as LGPD and GDPR necessitates the use of effective data anonymization methods to safeguard personal information and meet legal requirements.", "method": "The study investigates and applies aggregation, generalization, perturbation, and k-anonymity techniques to datasets with personal and sensitive data to assess their effectiveness.", "result": "The analysis revealed significant differences in the effectiveness of anonymization methods, emphasizing the trade-off between privacy compliance and data utility.", "conclusion": "Balancing privacy and data utility is critical, as no single anonymization technique is universally optimal, requiring context-specific selection and adaptation."}}
{"id": "2507.18515", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18515", "abs": "https://arxiv.org/abs/2507.18515", "authors": ["Zezhou Yang", "Ting Peng", "Cuiyun Gao", "Chaozheng Wang", "Hailiang Huang", "Yuetang Deng"], "title": "A Deep Dive into Retrieval-Augmented Generation for Code Completion: Experience on WeChat", "comment": "Accepted in ICSME 25 Industry Track", "summary": "Code completion, a crucial task in software engineering that enhances\ndeveloper productivity, has seen substantial improvements with the rapid\nadvancement of large language models (LLMs). In recent years,\nretrieval-augmented generation (RAG) has emerged as a promising method to\nenhance the code completion capabilities of LLMs, which leverages relevant\ncontext from codebases without requiring model retraining. While existing\nstudies have demonstrated the effectiveness of RAG on public repositories and\nbenchmarks, the potential distribution shift between open-source and\nclosed-source codebases presents unique challenges that remain unexplored. To\nmitigate the gap, we conduct an empirical study to investigate the performance\nof widely-used RAG methods for code completion in the industrial-scale codebase\nof WeChat, one of the largest proprietary software systems. Specifically, we\nextensively explore two main types of RAG methods, namely identifier-based RAG\nand similarity-based RAG, across 26 open-source LLMs ranging from 0.5B to 671B\nparameters. For a more comprehensive analysis, we employ different retrieval\ntechniques for similarity-based RAG, including lexical and semantic retrieval.\nBased on 1,669 internal repositories, we achieve several key findings: (1) both\nRAG methods demonstrate effectiveness in closed-source repositories, with\nsimilarity-based RAG showing superior performance, (2) the effectiveness of\nsimilarity-based RAG improves with more advanced retrieval techniques, where\nBM25 (lexical retrieval) and GTE-Qwen (semantic retrieval) achieve superior\nperformance, and (3) the combination of lexical and semantic retrieval\ntechniques yields optimal results, demonstrating complementary strengths.\nFurthermore, we conduct a developer survey to validate the practical utility of\nRAG methods in real-world development environments.", "AI": {"tldr": "This paper investigates the effectiveness of retrieval-augmented generation (RAG) methods for code completion in closed-source industrial codebases (WeChat's internal repositories). They compare identifier-based and similarity-based RAG across 26 LLMs, find similarity-based RAG with combined lexical (BM25) and semantic (GTE-Qwen) retrieval achieves optimal performance, and validate practical utility via developer surveys.", "motivation": "While RAG methods have shown success in open-source code completion, the distribution shift between open-source and proprietary/industrial-scale codebases introduces unexplored challenges. This study addresses the lack of empirical evaluations in closed-source contexts like WeChat's codebase.", "method": "The authors test two RAG paradigms (identifier-based and similarity-based) across 26 open-source LLMs (0.5B-671B parameters) using WeChat's 1,669 internal repositories. For similarity-based RAG, they compare lexical retrieval (BM25), semantic retrieval (GTE-Qwen), and their combination through empirical evaluation.", "result": "Key results include: (1) similarity-based RAG outperforms identifier-based RAG in closed-source settings, (2) advanced retrieval techniques significantly improve similarity-based RAG with BM25 and GTE-Qwen showing top performance, (3) hybrid lexical+semantic retrieval achieves best results, and (4) developer surveys confirm practical utility.", "conclusion": "The study demonstrates that similarity-based RAG with complementary lexical-semantic retrieval techniques is particularly effective for industrial-scale code completion tasks. The findings highlight the importance of adapting RAG methods to proprietary codebases and suggest directions for domain-specific code completion strategies."}}
{"id": "2507.18478", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2507.18478", "abs": "https://arxiv.org/abs/2507.18478", "authors": ["Shariq Murtuza"], "title": "Scout: Leveraging Large Language Models for Rapid Digital Evidence Discovery", "comment": null, "summary": "Recent technological advancements and the prevalence of technology in day to\nday activities have caused a major increase in the likelihood of the\ninvolvement of digital evidence in more and more legal investigations.\nConsumer-grade hardware is growing more powerful, with expanding memory and\nstorage sizes and enhanced processor capabilities. Forensics investigators\noften have to sift through gigabytes of data during an ongoing investigation\nmaking the process tedious. Memory forensics, disk analysis all are well\nsupported by state of the art tools that significantly lower the effort\nrequired to be put in by a forensic investigator by providing string searches,\nanalyzing images file etc. During the course of the investigation a lot of\nfalse positives are identified that need to be lowered. This work presents\nScout, a digital forensics framework that performs preliminary evidence\nprocessing and prioritizing using large language models. Scout deploys\nfoundational language models to identify relevant artifacts from a large number\nof potential evidence files (disk images, captured network packets, memory\ndumps etc.) which would have taken longer to get identified. Scout employs text\nbased large language models can easily process files with textual information.\nFor the forensic analysis of multimedia files like audio, image, video, office\ndocuments etc. multimodal models are employed by Scout. Scout was able to\nidentify and realize the evidence file that were of potential interest for the\ninvestigator.", "AI": {"tldr": "Scout is a digital forensics framework that leverages large language models and multimodal models to efficiently process and prioritize digital evidence, addressing challenges from increasing data complexity and volume.", "motivation": "The motivation arises from the growing prevalence of powerful consumer-grade devices, which complicate legal investigations by generating huge data volumes with many irrelevant results (false positives) to sift through manually using traditional tools.", "method": "Scout employs foundational text-based LLMs to identify relevant artifacts in textual evidence files while using multimodal models for analyzing multimedia files (audio, video, images, office docs) alongside disk images and network packets.", "result": "Scout successfully identified and prioritized potentially relevant evidence files in digital investigations, reducing manual effort and false positives compared to conventional methods.", "conclusion": "The framework demonstrates the potential of AI-driven tools to revolutionize digital forensics by enabling scalable, efficient preliminary evidence analysis through specialized language and multimodal models."}}
{"id": "2507.18631", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2507.18631", "abs": "https://arxiv.org/abs/2507.18631", "authors": ["Hao Li", "Lijun Li", "Zhenghao Lu", "Xianyi Wei", "Rui Li", "Jing Shao", "Lei Sha"], "title": "Layer-Aware Representation Filtering: Purifying Finetuning Data to Preserve LLM Safety Alignment", "comment": null, "summary": "With rapid advancement and increasing accessibility of LLMs, fine-tuning\naligned models has become a critical step for adapting them to real-world\napplications, which makes the safety of this fine-tuning process more important\nthan ever. However, recent studies have highlighted a critical challenge: even\nwhen fine-tuning with seemingly benign downstream datasets, the safety of\naligned LLMs can be compromised, making them more susceptible to malicious\ninstructions. In this paper, we show that fine-tuning datasets often contain\nsamples with safety-degrading features that are not easily identifiable on the\nsurface. These samples can significantly degrade the safety alignment of LLMs\nduring fine-tuning. To address this issue, we propose LARF, a\n\\textbf{L}ayer-\\textbf{A}ware \\textbf{R}epresentation \\textbf{F}iltering\nmethod. This method identifies safety-sensitive layers within the LLM and\nleverages their representations to detect which data samples in the\npost-training dataset contain safety-degrading features. Experimental results\ndemonstrate that LARF can effectively identify benign data with\nsafety-degrading features. After removing such data, the safety alignment\ndegradation caused by fine-tuning is mitigated. Please see our code at\n\\href{https://github.com/LLLeoLi/LARF}{https://github.com/LLLeoLi/LARF}.", "AI": {"tldr": "The paper addresses safety degradation in fine-tuned large language models (LLMs) by proposing LARF, a Layer-Aware Representation Filtering method to identify and remove harmful features from datasets. Experiments show this improves safety alignment preservation during fine-tuning.", "motivation": "Fine-tuning aligned LLMs for real-world applications risks compromising their safety alignment, even with benign datasets. Recent studies reveal hidden safety-degrading features in standard datasets that make models more vulnerable to malicious instructions.", "method": "LARF identifies safety-sensitive layers in LLMs and analyzes their representations to detect data samples containing safety-degrading features during fine-tuning.", "result": "LARF effectively identifies safety-compromising data samples without obvious harmful content. Removing these samples mitigates safety alignment degradation in fine-tuned models.", "conclusion": "The paper demonstrates that hidden safety-degrading features exist in fine-tuning datasets and proposes LARF as an effective solution to preserve safety alignment through layer-aware representation analysis. Open-sourced code available at https://github.com/LLLeoLi/LARF."}}
