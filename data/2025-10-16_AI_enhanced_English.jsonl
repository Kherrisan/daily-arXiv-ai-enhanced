{"id": "2510.12802", "categories": ["cs.CR", "94A60", "F.2.2; E.3; K.3.2; D.4.6"], "pdf": "https://arxiv.org/pdf/2510.12802", "abs": "https://arxiv.org/abs/2510.12802", "authors": ["Alexander Towell"], "title": "The Beautiful Deception: How 256 Bits Pretend to be Infinity", "comment": null, "summary": "How do you store infinity in 256 bits? This paper explores the fundamental\ndeception at the heart of computational cryptography: using finite information\nto simulate infinite randomness. We prove why true random oracles are\nimpossible, then show how lazy evaluation creates a beautiful lie -- a finite\nautomaton that successfully pretends to be infinite. We reveal that\n``randomness'' in cryptography is actually computational hardness in disguise,\ndemonstrating through Python implementations how 256 bits of entropy can\ngenerate sequences indistinguishable from infinite randomness to any\ncomputationally bounded observer.How do you store infinity in 256 bits? This\npaper explores the fundamental deception at the heart of computational\ncryptography: using finite information to simulate infinite randomness. We\nprove why true random oracles are impossible, then show how lazy evaluation\ncreates a beautiful lie -- a finite automaton that successfully pretends to be\ninfinite. We reveal that ``randomness'' in cryptography is actually\ncomputational hardness in disguise, demonstrating through Python\nimplementations how 256 bits of entropy can generate sequences\nindistinguishable from infinite randomness to any computationally bounded\nobserver.", "AI": {"tldr": "This paper reveals how cryptographic systems 'store infinity in 256 bits' by using computational hardness and lazy evaluation to simulate infinite randomness. Despite proving true random oracles are impossible, it shows finite automata (like 256-bit entropy) can create sequences that appear infinite to computationally limited observers, explaining why practical cryptography works.", "motivation": "The motivation lies in addressing the core challenge of computational cryptography: achieving practical security without access to true infinite randomness. The paper aims to highlight the inherent 'deception' in cryptographic systems\u2014relying on finite information to simulate unbounded randomness\u2014while justifying how this 'beautiful lie' works effectively. The study bridges the gap between theoretical impossibility and real-world cryptographic needs, emphasizing how computational limitations enable this simulation.", "method": "The paper combines mathematical proofs with computational demonstrations. It first rigorously proves the impossibility of true random oracles (theoretical idealized cryptographic tools). Then, it introduces lazy evaluation techniques, enabling finite automata to 'pretend' to be infinite by generating data on-demand rather than storing it entirely. Practical Python implementations are included to demonstrate how 256-bit entropy can produce pseudorandom sequences that pass indistinguishability tests for computationally bounded adversaries, effectively creating the illusion of infinite randomness.", "result": "The paper's key result is demonstrating that sequences generated from 256-bit entropy through lazy evaluation and computational hardness are indistinguishable from truly random sequences for computationally bounded observers. This validates the practical feasibility of current cryptographic methods in simulating 'infinite' randomness, despite the absence of true random oracles. The Python implementations empirically confirm this claim.", "conclusion": "The conclusion is that finite systems, through techniques like lazy evaluation and computational hardness, can simulate infinite randomness effectively, enabling practical cryptographic security despite the impossibility of true random oracles. The paper asserts that cryptographic 'randomness' relies on computational constraints rather than genuine infinite entropy. The TLDR summary for this paper would be that by using 256 bits, the paper demonstrates how cryptographic methods leverage finite entropy to mimic infinite randomness, ensuring that sequences appear random to computationally bounded observers, thereby achieving the 'beautiful lie' of computational indistinguishability. The motivation centers on exposing the theoretical gap between real-world cryptographic practices and the ideal of true randomness, while the method employs mathematical proofs and lazy evaluation to construct finite automata that simulate infinite behavior. The result is the validation that 256-bit entropy can generate sequences indistinguishable from infinite randomness within computational limits. The paper ultimately underscores computational complexity as the cornerstone of cryptographic 'randomness'."}}
{"id": "2510.12811", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.12811", "abs": "https://arxiv.org/abs/2510.12811", "authors": ["ElMouatez Billah Karbab", "Mourad Debbabi"], "title": "Applying Graph Analysis for Unsupervised Fast Malware Fingerprinting", "comment": null, "summary": "Malware proliferation is increasing at a tremendous rate, with hundreds of\nthousands of new samples identified daily. Manual investigation of such a vast\namount of malware is an unrealistic, time-consuming, and overwhelming task. To\ncope with this volume, there is a clear need to develop specialized techniques\nand efficient tools for preliminary filtering that can group malware based on\nsemantic similarity. In this paper, we propose TrapNet, a novel, scalable, and\nunsupervised framework for malware fingerprinting and grouping. TrapNet employs\ngraph community detection techniques for malware fingerprinting and family\nattribution based on static analysis, as follows: (1) TrapNet detects packed\nbinaries and unpacks them using known generic packer tools. (2) From each\nmalware sample, it generates a digest that captures the underlying semantics.\nSince the digest must be dense, efficient, and suitable for similarity\nchecking, we designed FloatHash (FH), a novel numerical fuzzy hashing technique\nthat produces a short real-valued vector summarizing the underlying assembly\nitems and their order. FH is based on applying Principal Component Analysis\n(PCA) to ordered assembly items (e.g., opcodes, function calls) extracted from\nthe malware's assembly code. (3) Representing malware with short numerical\nvectors enables high-performance, large-scale similarity computation, which\nallows TrapNet to build a malware similarity network. (4) Finally, TrapNet\nemploys state-of-the-art community detection algorithms to identify dense\ncommunities, which represent groups of malware with similar semantics. Our\nextensive evaluation of TrapNet demonstrates its effectiveness in terms of the\ncoverage and purity of the detected communities, while also highlighting its\nruntime efficiency, which outperforms other state-of-the-art solutions.", "AI": {"tldr": "TrapNet is an unsupervised malware grouping framework using graph community detection and a novel PCA-based fuzzy hashing technique (FloatHash) to analyze malware similarity via static analysis.", "motivation": "The overwhelming volume of daily malware samples necessitates automated, scalable solutions for preliminary triage and grouping based on semantic similarity.", "method": "1) Detect/pack/unpack malware 2) Generate semantics-preserving digests via ordered assembly item analysis 3) Create similarity networks using FloatHash vectors 4]Apply community detection algorithms for malware clustering.", "result": "Achieves high coverage/purity in malware community detection with runtime efficiency surpassing existing state-of-the-art methods.", "conclusion": "TrapNet demonstrates effective malware clustering through statistical analysis and graph community detection, outperforming alternatives in scalability and accuracy."}}
{"id": "2510.12812", "categories": ["cs.CR", "cs.CY"], "pdf": "https://arxiv.org/pdf/2510.12812", "abs": "https://arxiv.org/abs/2510.12812", "authors": ["Aleksandar Petrov", "Pierre Fernandez", "Tom\u00e1\u0161 Sou\u010dek", "Hady Elsahar"], "title": "We Can Hide More Bits: The Unused Watermarking Capacity in Theory and in Practice", "comment": null, "summary": "Despite rapid progress in deep learning-based image watermarking, the\ncapacity of current robust methods remains limited to the scale of only a few\nhundred bits. Such plateauing progress raises the question: How far are we from\nthe fundamental limits of image watermarking? To this end, we present an\nanalysis that establishes upper bounds on the message-carrying capacity of\nimages under PSNR and linear robustness constraints. Our results indicate\ntheoretical capacities are orders of magnitude larger than what current models\nachieve. Our experiments show this gap between theoretical and empirical\nperformance persists, even in minimal, easily analysable setups. This suggests\na fundamental problem. As proof that larger capacities are indeed possible, we\ntrain ChunkySeal, a scaled-up version of VideoSeal, which increases capacity 4\ntimes to 1024 bits, all while preserving image quality and robustness. These\nfindings demonstrate modern methods have not yet saturated watermarking\ncapacity, and that significant opportunities for architectural innovation and\ntraining strategies remain.", "AI": {"tldr": "This paper establishes theoretical upper bounds for image watermarking capacity under PSNR and robustness constraints, revealing a significant gap between current models and potential limits. It demonstrates a 4\u00d7 capacity increase to 1024 bits using ChunkySeal, proving existing methods haven't reached fundamental limits.", "motivation": "Current robust watermarking methods lag far behind theoretical capacity limits despite deep learning advancements, raising concerns about architectural saturation. The paper seeks to quantify this gap and validate whether higher capacities are fundamentally possible.", "method": "1. Analytical derivation of image-carrying capacity upper bounds using PSNR/linear robustness constraints; 2. Empirical validation through minimal setups; 3. Model scaling experiments with ChunkySeal (1024-bit implementation).", "result": "a) Theoretical capacity exceeds current capabilities by orders of magnitude; b. Performance gaps persist in simplified experiments; c. ChunkySeal achieves 4\u00d7 higher capacity (1024 bits), maintaining quality/robustness, demonstrating architectural shortcomings rather than theoretical barriers.", "conclusion": "Watermarking capacity saturation remains unachieved, with substantial room for architectural innovation and training methodology improvements. The persistence of theoretical-practical gaps indicates key challenges remain in model design and optimization strategies."}}
{"id": "2510.12821", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.12821", "abs": "https://arxiv.org/abs/2510.12821", "authors": ["Jaeseong Lee", "Junghee Lee"], "title": "ARTeX: Anonymity Real-world-assets Token eXchange", "comment": null, "summary": "This paper addresses one of the most noteworthy issues in the recent virtual\nasset market, the privacy concerns related to token transactions of Real-World\nAssets tokens, known as RWA tokens. Following the advent of Bitcoin, the\nvirtual asset market has experienced explosive growth, spawning movements to\nlink real-world assets with virtual assets. However, due to the transparency\nprinciple of blockchain technology, the anonymity of traders cannot be\nguaranteed. In the existing blockchain environment, there have been instances\nof protecting the privacy of fungible tokens (FTs) using mixer services.\nMoreover, numerous studies have been conducted to secure the privacy of\nnon-fungible tokens (NFTs). However, due to the unique characteristics of RWA\ntokens and the limitations of each study, it has been challenging to achieve\nthe goal of anonymity protection effectively. This paper proposes a new token\ntrading platform, the ARTeX, designed to resolve these issues. This platform\nnot only addresses the shortcomings of existing methods but also ensures the\nanonymity of traders while enhancing safeguards against illegal activities.", "AI": {"tldr": "This paper proposes ARTeX, a novel token trading platform to address privacy challenges in Real-World Asset (RWA token transactions by resolving anonymity issues while preventing illegal activities.", "motivation": "Blockchain transparency compromises trader anonymity, especially for RWA tokens where existing privacy solutions for fungible tokens (FTs/NFTs fail due to unique characteristics and methodological limitations.", "method": "Introduces ARTeX platform that addresses existing method shortcomings through anonymity protection mechanisms and enhanced safeguards against illicit activities.", "result": "Achieves effective anonymity protection for RWA token transactions while maintaining security against illegal operations through the proposed platform design.", "conclusion": "ARTeX offers a viable solution for balancing privacy and regulatory compliance in RWA token trading, addressing critical gaps in current blockchain privacy solutions."}}
{"id": "2510.12803", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.PL"], "pdf": "https://arxiv.org/pdf/2510.12803", "abs": "https://arxiv.org/abs/2510.12803", "authors": ["Shang Zhou", "Zihan Zheng", "Kaiyuan Liu", "Zeyu Shen", "Zerui Cheng", "Zexing Chen", "Hansen He", "Jianzhu Yao", "Huanzhi Mao", "Qiuyang Mang", "Tianfu Fu", "Beichen Li", "Dongruixuan Li", "Wenhao Chai", "Zhuang Liu", "Aleksandra Korolova", "Peter Henderson", "Natasha Jaques", "Pramod Viswanath", "Saining Xie", "Jingbo Shang"], "title": "AutoCode: LLMs as Problem Setters for Competitive Programming", "comment": "Project page: https://livecodebenchpro.com/projects/autocode/overview", "summary": "Writing competitive programming problems is exacting. Authors must: set\nconstraints, input distributions, and edge cases that rule out shortcuts;\ntarget specific algorithms (e.g., max-flow, dynamic programming, data\nstructures); and calibrate complexity beyond the reach of most competitors. We\nargue that this makes for an ideal test of general large language model\ncapabilities and study whether they can do this reliably. We introduce\nAutoCode, which uses multiple rounds of validation to yield competition-grade\nproblem statements and test cases. On held-out problems, AutoCode test suites\napproach 99% consistency with official judgments, a significant improvement\nover current state-of-the-art methods like HardTests, which achieve less than\n81%. Furthermore, starting with a random seed problem, AutoCode can create\nnovel variants with reference and brute-force solutions. By cross-verifying\nthese generated solutions against test cases, we can further filter out\nmalformed problems. Our system ensures high correctness, as verified by human\nexperts. AutoCode successfully produces novel problems judged by\nGrandmaster-level (top 0.3%) competitive programmers to be of contest quality.", "AI": {"tldr": "AutoCode generates high-quality competitive programming problems with 99\\% consistency to official judgments, surpassing prior methods and verified by grandmaster-level experts.", "motivation": "Manually crafting competitive programming problems requires precise constraints and algorithm targeting. This work tests if LLMs can automate this complex task to produce truly challenging, contest-grade problems.", "method": "AutoCode uses multi-round validation to create problem statements/test cases, generates novel variants via random seed problems, and cross-verifies solutions against test cases to filter malformed problems.", "result": "Achieved 99\\% consistency with official judgments (vs. <81\\\\% for HardTests), produced contest-quality novel problems validated by human experts at Grandmaster level, and maintained both correctness and algorithm-specific targeting.", "conclusion": "AutoCode demonstrates LLMs can reliably generate competition-grade programming problems through systematic validation, achieving state-of-the-art performance and expert-verified quality comparable to elite human problem authors."}}
{"id": "2510.12828", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.12828", "abs": "https://arxiv.org/abs/2510.12828", "authors": ["Shingo Kodama", "Haya Diwan", "Lucas Rosenblatt", "R. Teal Witter", "Niv Cohen"], "title": "SimKey: A Semantically Aware Key Module for Watermarking Language Models", "comment": null, "summary": "The rapid spread of text generated by large language models (LLMs) makes it\nincreasingly difficult to distinguish authentic human writing from machine\noutput. Watermarking offers a promising solution: model owners can embed an\nimperceptible signal into generated text, marking its origin. Most leading\napproaches seed an LLM's next-token sampling with a pseudo-random key that can\nlater be recovered to identify the text as machine-generated, while only\nminimally altering the model's output distribution. However, these methods\nsuffer from two related issues: (i) watermarks are brittle to simple\nsurface-level edits such as paraphrasing or reordering; and (ii) adversaries\ncan append unrelated, potentially harmful text that inherits the watermark,\nrisking reputational damage to model owners. To address these issues, we\nintroduce SimKey, a semantic key module that strengthens watermark robustness\nby tying key generation to the meaning of prior context. SimKey uses\nlocality-sensitive hashing over semantic embeddings to ensure that paraphrased\ntext yields the same watermark key, while unrelated or semantically shifted\ntext produces a different one. Integrated with state-of-the-art watermarking\nschemes, SimKey improves watermark robustness to paraphrasing and translation\nwhile preventing harmful content from false attribution, establishing\nsemantic-aware keying as a practical and extensible watermarking direction.", "AI": {"tldr": "SimKey enhances LLM watermarking by encoding semantically consistent keys, making watermarks resistant to paraphrasing while preventing adversarial misuse through meaning-based key generation.", "motivation": "Current LLM watermarking methods are vulnerable to surface-level text edits like paraphrasing and adversarial attacks that falsely attribute unrelated harmful content. These weaknesses create reputational risks for model owners and limit practical deployment effectiveness.", "method": "SimKey utilizes locality-sensitive hashing over semantic embeddings to generate watermark keys tied to the meaning of prior context. This allows paraphrased content to retain the same watermark while semantically unrelated text receives different keys, integrated with existing watermarking schemes.", "result": "Experimental results show SimKey significantly improves watermark robustness to paraphrasing and translation tasks while effectively preventing false attribution attacks. The approach establishes semantic-aware keying as a practical advancement in text watermarking research.", "conclusion": "SimKey introduces a semantic-aware watermarking approach, enhancing robustness against paraphrasing and preventing false attribution of harmful content by generating keys based on contextual meaning rather than surface-level text features."}}
{"id": "2510.12948", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.12948", "abs": "https://arxiv.org/abs/2510.12948", "authors": ["Minh Nguyen"], "title": "SpareCodeSearch: Searching for Code Context When You Have No Spare GPU", "comment": "4 pages, 3 figures, 4 tables. Accepted to Context Collection Workshop\n  co-located with ASE'25", "summary": "Retrieval-Augmented Generation (RAG) frameworks aim to enhance Code Language\nModels (CLMs) by including another module for retrieving relevant context to\nconstruct the input prompt. However, these retrieval modules commonly use\nsemantic search, requiring substantial computational resources for training and\nhosting these embedded models, making them infeasible to integrate into\nlightweight applications such as in-IDE AI-based code completion. In this\nsolution paper, we prove that using keyword-search is sufficient to retrieve\nrelevant and useful code context inside large codebases, without the need for\nextensive GPU resources. The usefulness of code contexts found by our solution\nis demonstrated through their completion results on the Code Context\nCompetition's benchmark, reaching 0.748 and 0.725 chRF scores on Kotlin and\nPython tracks, respectively.", "AI": {"tldr": "This paper proposes a keyword-search based Retrieval-Augmented Generation (RAG) framework for Code Language Models (CLMs), demonstrating sufficient effectiveness without semantic search's resource demands, achieving 0.748 and 0.725 chRF scores on Kotlin and Python benchmarks.", "motivation": "Semantic search in RAG frameworks requires high computational resources, making them unsuitable for lightweight applications like in-IDE code completion. This paper addresses the need for a resource-efficient retrieval method.", "method": "The authors replace semantic search with a keyword-based approach to retrieve code contexts, enabling lightweight deployment without compromising retrieval quality for CLM input prompts.", "result": "The method achieved 0.748 chRF score on the Kotlin track and 0.725 on the Python track of the Code Context Competition benchmark, proving its effectiveness for code completion tasks.", "conclusion": "Keyword search can efficiently retrieve relevant code contexts for CLMs while reducing computational requirements, making RAG applicable to resource-constrained environments like IDEs."}}
{"id": "2510.12908", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.12908", "abs": "https://arxiv.org/abs/2510.12908", "authors": ["Rouzbeh Behnia", "Jeremiah Birrell", "Arman Riasi", "Reza Ebrahimi", "Kaushik Dutta", "Thang Hoang"], "title": "Local Differential Privacy for Federated Learning with Fixed Memory Usage and Per-Client Privacy", "comment": null, "summary": "Federated learning (FL) enables organizations to collaboratively train models\nwithout sharing their datasets. Despite this advantage, recent studies show\nthat both client updates and the global model can leak private information,\nlimiting adoption in sensitive domains such as healthcare. Local differential\nprivacy (LDP) offers strong protection by letting each participant privatize\nupdates before transmission. However, existing LDP methods were designed for\ncentralized training and introduce challenges in FL, including high resource\ndemands that can cause client dropouts and the lack of reliable privacy\nguarantees under asynchronous participation. These issues undermine model\ngeneralizability, fairness, and compliance with regulations such as HIPAA and\nGDPR. To address them, we propose L-RDP, a DP method designed for LDP that\nensures constant, lower memory usage to reduce dropouts and provides rigorous\nper-client privacy guarantees by accounting for intermittent participation.", "AI": {"tldr": "L-RDP enables secure federated learning by using low-memory operations and delivering provable privacy guarantees for intermittent participants, solving resource constraints and privacy compliance issues in sensitive domains like healthcare.", "motivation": "Existing FL systems face privacy risks from leaked client updates and global models. Current LDP methods for FL are resource-intensive (causing client dropouts) and\u7f3a\u4e4f reliable privacy guarantees under asynchronous participation, undermining model fairness and regulatory compliance in sensitive domains.", "method": "L-RDP is a Local Differential Privacy (LDP) method designed for FL. It employs constant memory usage to mitigate client dropouts and offers rigorous privacy guarantees by accounting for intermittent client participation through an asynchronous participation model.", "result": "L-RDP reduces memory demands to prevent client dropouts and provides provable per-client privacy guarantees even with intermittent participation. This enables FL to maintain model generalizability, fairness, and compliance with privacy regulations in healthcare and other sensitive contexts.", "conclusion": "The proposed L-RDP method addresses key challenges in federated learning (FL) by ensuring constant memory usage to reduce client dropouts and providing rigorous per-client privacy guarantees, making FL more viable for sensitive domains like healthcare while complying with regulations like HIPAA and GDPR."}}
{"id": "2510.13078", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.13078", "abs": "https://arxiv.org/abs/2510.13078", "authors": ["Tri Minh-Triet Pham", "Diego Elias Costa", "Weiyi Shang", "Jinqiu Yang"], "title": "ADPerf: Investigating and Testing Performance in Autonomous Driving Systems", "comment": "13 pages, accepted by ASE 2025", "summary": "Obstacle detection is crucial to the operation of autonomous driving systems,\nwhich rely on multiple sensors, such as cameras and LiDARs, combined with code\nlogic and deep learning models to detect obstacles for time-sensitive\ndecisions. Consequently, obstacle detection latency is critical to the safety\nand effectiveness of autonomous driving systems. However, the latency of the\nobstacle detection module and its resilience to various changes in the LiDAR\npoint cloud data are not yet fully understood. In this work, we present the\nfirst comprehensive investigation on measuring and modeling the performance of\nthe obstacle detection modules in two industry-grade autonomous driving\nsystems, i.e., Apollo and Autoware. Learning from this investigation, we\nintroduce ADPerf, a tool that aims to generate realistic point cloud data test\ncases that can expose increased detection latency. Increasing latency decreases\nthe availability of the detected obstacles and stresses the capabilities of\nsubsequent modules in autonomous driving systems, i.e., the modules may be\nnegatively impacted by the increased latency in obstacle detection.\n  We applied ADPerf to stress-test the performance of widely used 3D obstacle\ndetection modules in autonomous driving systems, as well as the propagation of\nsuch tests on trajectory prediction modules. Our evaluation highlights the need\nto conduct performance testing of obstacle detection components, especially 3D\nobstacle detection, as they can be a major bottleneck to increased latency of\nthe autonomous driving system. Such an adverse outcome will also further\npropagate to other modules, reducing the overall reliability of autonomous\ndriving systems.", "AI": {"tldr": "This paper introduces ADPerf, a tool to generate realistic LiDAR point cloud test cases that expose latency issues in 3D obstacle detection modules of autonomous driving systems (Apollo and Autoware), highlighting their impact on system reliability and downstream modules.", "motivation": "Obstacle detection latency and resilience to LiDAR data changes in autonomous vehicles are under-researched despite critical safety implications. Prior studies lack systematic analysis of latency propagation across industry-grade systems.", "method": "1) Comprehensive performance evaluation of obstacle detection modules in Apollo and Autoware\n2. Development of ADPerf to synthesize latency-exposing point cloud scenarios\n3. Stress-testing 3D detection modules and analyzing latency propagation through trajectory prediction components.", "result": "Experimental validation demonstrates ADPerf effectively exposes latency bottlenecks in 3D detection, with latency propagation significantly impacting downstream modules. Results quantify how increased detection latency reduces obstacle availability for critical decision-making processes.", "conclusion": "3D obstacle detection is a critical latency bottleneck in autonomous systems requiring rigorous performance testing. Latency cascades across modules, undermining overall system reliability, necessitating improved design considerations for time-critical autonomous driving workflows."}}
{"id": "2510.13058", "categories": ["cs.CR", "cs.CY"], "pdf": "https://arxiv.org/pdf/2510.13058", "abs": "https://arxiv.org/abs/2510.13058", "authors": ["Tooba Aamir", "Marthie Grobler", "Giovanni Russello"], "title": "From misinformation to climate crisis: Navigating vulnerabilities in the cyber-physical-social systems", "comment": null, "summary": "Within the cyber-physical-social-climate nexus, all systems are deeply\ninterdependent: cyber infrastructure facilitates communication, data\nprocessing, and automation across physical systems (such as power grids and\nnetworks), while social infrastructure provides the human capital and societal\nnorms necessary for the system's functionality. Any disruption within any of\nthese components, whether due to human error or system mismanagement, can\npropagate throughout the network, amplifying vulnerabilities and creating a\nsignificantly scaled impact. This chapter explores the critical role of human\nvulnerabilities within the cyber-physical-social-climate nexus, focusing on the\ninterdependencies across cyber, physical, and social systems and how these\ninterdependencies can scale in a climate context. While cyber and physical\nvulnerabilities are readily apparent, social vulnerabilities (such as\nmisinformation, resistance to policy change, and lack of public awareness)\noften go unaddressed despite their profound impact on resilience and climate\nadaptation. Social infrastructure, including human capital, societal norms, and\npolicy frameworks, shapes community responses and underpins adaptive capacity,\nyet it is also a significant point of failure when overlooked. This chapter\nexamines how human cognitive biases, risk misperception, and decision-making\nsilos within interconnected systems can lead to resource misallocation and\nweakened policy effectiveness. These factors are analyzed to demonstrate how\ninadequate responses across cyber-physical-social layers can cascade,\namplifying climate-related risks. By addressing these human factors and\naligning decision-making frameworks, we aim to strengthen resilience and foster\ncohesive adaptation strategies that account for the intricate interrelations of\ncyber-physical-social-climate systems.", "AI": {"tldr": "This paper argues that human-induced social vulnerabilities are critical but overlooked drivers of systemic risk in cyber-physical-social-climate systems. It shows how cognitive biases, misperceptions, and fragmented decision-making propagate failures across these systems, advocating for integrated resilience strategies that prioritize social dimensions.", "motivation": "Social vulnerabilities (e.g., misinformation, resistance to policy change) are frequently overlooked despite significantly shaping resilience and climate adaptation. Ignoring these human factors risks cascading failures in interdependent systems.", "method": "Analyzes interdependencies across cyber, physical, and social systems through cognitive biases, risk misperception, and decision-making silos. Demonstrates how these factors cascade across systems, amplifying climate risks.", "result": "Uncovers how unaddressed social vulnerabilities lead to resource misallocation, weakened policy effectiveness, and amplified climate-related risks. Highlights the need for holistic approaches to system resilience.", "conclusion": "The chapter stresses the importance of integrating human factors like social vulnerabilities and cognitive biases into decision-making frameworks to enhance resilience in the cyber-physical-social-climate nexus. Addressing these factors is critical for coherent climate adaptation strategies."}}
{"id": "2510.13106", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.13106", "abs": "https://arxiv.org/abs/2510.13106", "authors": ["Ruoyu Sun", "Da Song", "Jiayang Song", "Yuheng Huang", "Lei Ma"], "title": "TRUSTVIS: A Multi-Dimensional Trustworthiness Evaluation Framework for Large Language Models", "comment": "4 pages, 2 figures, To appear in ASE 2025 Demo Track", "summary": "As Large Language Models (LLMs) continue to revolutionize Natural Language\nProcessing (NLP) applications, critical concerns about their trustworthiness\npersist, particularly in safety and robustness. To address these challenges, we\nintroduce TRUSTVIS, an automated evaluation framework that provides a\ncomprehensive assessment of LLM trustworthiness. A key feature of our framework\nis its interactive user interface, designed to offer intuitive visualizations\nof trustworthiness metrics. By integrating well-known perturbation methods like\nAutoDAN and employing majority voting across various evaluation methods,\nTRUSTVIS not only provides reliable results but also makes complex evaluation\nprocesses accessible to users. Preliminary case studies on models like\nVicuna-7b, Llama2-7b, and GPT-3.5 demonstrate the effectiveness of our\nframework in identifying safety and robustness vulnerabilities, while the\ninteractive interface allows users to explore results in detail, empowering\ntargeted model improvements. Video Link: https://youtu.be/k1TrBqNVg8g", "AI": {"tldr": "TRUSTVIS is an interactive framework for evaluating LLM trustworthiness, combining robust methods and user-friendly visualizations to detect vulnerabilities and guide model improvements.", "motivation": "The motivation addresses critical concerns about Large Language Models' (LLMs) safety and robustness, seeking to provide a reliable and accessible evaluation framework to identify vulnerabilities.", "method": "The framework integrates perturbation methods like AutoDAN and employs majority voting across evaluation methods, supported by an interactive visualization interface.", "result": "Preliminary case studies on models like Vicuna-7b, Llama2-7b, and GPT-3.5 demonstrate TRUSTVIS's effectiveness in identifying safety/robustness issues and its utility for detailed result exploration.", "conclusion": "The paper concludes that TRUSTVIS effectively enhances the accessibility and reliability of assessing LLM trustworthiness, enabling targeted improvements through its interactive interface."}}
{"id": "2510.13102", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.13102", "abs": "https://arxiv.org/abs/2510.13102", "authors": ["Victor Olaiya", "Adwait Nadkarni"], "title": "From base cases to backdoors: An Empirical Study of Unnatural Crypto-API Misuse", "comment": null, "summary": "Tools focused on cryptographic API misuse often detect the most basic\nexpressions of the vulnerable use, and are unable to detect non-trivial\nvariants. The question of whether tools should be designed to detect such\nvariants can only be answered if we know how developers use and misuse\ncryptographic APIs in the wild, and in particular, what the unnatural usage of\nsuch APIs looks like. This paper presents the first large-scale study that\ncharacterizes unnatural crypto-API usage through a qualitative analysis of\n5,704 representative API invocations. We develop an intuitive complexity metric\nto stratify 140,431 crypto-API invocations obtained from 20,508 Android\napplications, allowing us to sample 5,704 invocations that are representative\nof all strata, with each stratum consisting of invocations with similar\ncomplexity/naturalness. We qualitatively analyze the 5,704 sampled invocations\nusing manual reverse engineering, through an in-depth investigation that\ninvolves the development of minimal examples and exploration of native code.\nOur study results in two detailed taxonomies of unnatural crypto-API misuse,\nalong with 17 key findings that show the presence of highly unusual misuse,\nevasive code, and the inability of popular tools to reason about even mildly\nunconventional usage. Our findings lead to four key takeaways that inform\nfuture work focused on detecting unnatural crypto-API misuse.", "AI": {"tldr": "This paper analyzes 5,704 crypto-API invocations to characterize unnatural misuse, revealing tool limitations and providing actionable insights for improving detection of unconventional security vulnerabilities.", "motivation": "Existing tools fail to detect non-trivial variants of cryptographic API misuse. Understanding real-world usage patterns and 'unnatural' misuse is critical to guiding tool design for robust detection.", "method": "The authors conducted a large-scale qualitative analysis of 5,704 crypto-API invocations from 20,508 Android apps. They used a complexity metric to stratify data, manual reverse engineering, minimal example development, and native code exploration.", "result": "Two detailed taxonomies of unnatural misuse, 17 key findings (e.g., highly unusual misuse, evasive code), and evidence that popular tools struggle with even mildly unconventional API usage.", "conclusion": "The study highlights four key takeaways for improving tools to detect unnatural cryptographic API misuse, emphasizing the need for methods that can address unconventional usage patterns and evasive code."}}
{"id": "2510.13128", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.13128", "abs": "https://arxiv.org/abs/2510.13128", "authors": ["Yujie Liu", "Mingxuan Zhu", "Shengyu Cheng", "Dan Hao"], "title": "Isolating Compiler Bugs through Compilation Steps Analysis", "comment": null, "summary": "Compilers are essential to software systems, and their bugs can propagate to\ndependent software. Ensuring compiler correctness is critical. However,\nisolating compiler bugs remains challenging due to the internal complexity of\ncompiler execution. Existing techniques primarily mutate compilation inputs to\ngenerate passing and failing tests, but often lack causal analysis of internal\nsteps, limiting their effectiveness.\n  To address this limitation, we propose CompSCAN, a novel compiler bug\nisolation technique that applies analysis over the sequence of compilation\nsteps. CompSCAN follows a three-stage process: (1) extracting the array of\ncompilation steps that leads to the original failure, (2) identifying\nbug-causing steps and collecting corresponding compiler code elements, and (3)\ncalculating suspicious scores for each code element and outputting a suspicious\nranking list as the bug isolation result.\n  We evaluate CompSCAN on 185 real-world LLVM and GCC bugs. Results show that\nCompSCAN outperforms state-of-the-art techniques in both effectiveness and\nefficiency. CompSCAN successfully isolates 50, 85, 100, and 123 bugs within the\nTop-1/3/5/10 ranks, respectively. Compared with ETEM and ODFL, two\nstate-of-the-art compiler bug isolation techniques, CompSCAN achieves relative\nimprovements of 44.51% / 50.18% / 36.24% / 24.49% over ETEM, and 31.58% /\n49.12% / 44.93% / 21.78% over ODFL on those metrics. Moreover, CompSCAN runs\nfaster on average per bug than both baselines.", "AI": {"tldr": "The paper introduces CompSCAN, a novel compiler bug isolation technique that analyzes compilation steps sequences to achieve higher effectiveness and efficiency compared to existing methods, validated on 185 real-world LLVM/GCC bugs.", "motivation": "Compiler bugs propagate widely but current isolation techniques lack causal analysis of internal compilation steps, limiting their effectiveness despite mutations of compilation inputs.", "method": "CompSCAN's three-stage process: (1). Extracting failure-inducing compilation steps sequence; (2). Identifying bug-causing steps and collecting compiler code elements; (3). Calculating suspicious scores for code elements and generating rank-ordered bug isolation results.", "result": "CompSCAN outperforms state-of-the-art techniques (ETEM/ODFL) with 50/85/100/123 bugs isolated in Top-1/3/5/10 ranks respectively, achieving 44.51%-50.18%/31.58%-49.12 relative improvements while running faster per bug.", "conclusion": "CompSCAN demonstrates superior effectiveness and efficiency in compiler bug isolation through step-wise sequence analysis, overcoming limitations of input-mutation-based approaches."}}
{"id": "2510.13111", "categories": ["cs.CR", "cs.AR"], "pdf": "https://arxiv.org/pdf/2510.13111", "abs": "https://arxiv.org/abs/2510.13111", "authors": ["Nuntipat Narkthong", "Yukui Luo", "Xiaolin Xu"], "title": "ShuffleV: A Microarchitectural Defense Strategy against Electromagnetic Side-Channel Attacks in Microprocessors", "comment": "Accepted by the 28th International Symposium on Research in Attacks,\n  Intrusions and Defenses (RAID 2025)", "summary": "The run-time electromagnetic (EM) emanation of microprocessors presents a\nside-channel that leaks the confidentiality of the applications running on\nthem. Many recent works have demonstrated successful attacks leveraging such\nside-channels to extract the confidentiality of diverse applications, such as\nthe key of cryptographic algorithms and the hyperparameter of neural network\nmodels. This paper proposes ShuffleV, a microarchitecture defense strategy\nagainst EM Side-Channel Attacks (SCAs). ShuffleV adopts the moving target\ndefense (MTD) philosophy, by integrating hardware units to randomly shuffle the\nexecution order of program instructions and optionally insert dummy\ninstructions, to nullify the statistical observation by attackers across\nrepetitive runs. We build ShuffleV on the open-source RISC-V core and provide\nsix design options, to suit different application scenarios. To enable rapid\nevaluation, we develop a ShuffleV simulator that can help users to (1) simulate\nthe performance overhead for each design option and (2) generate an execution\ntrace to validate the randomness of execution on their workload. We implement\nShuffleV on a Xilinx PYNQ-Z2 FPGA and validate its performance with two\nrepresentative victim applications against EM SCAs, AES encryption, and neural\nnetwork inference. The experimental results demonstrate that ShuffleV can\nprovide automatic protection for these applications, without any user\nintervention or software modification.", "AI": {"tldr": "ShuffleV is a microarchitecture defense against electromagnetic side-channel attacks by randomizing instruction execution via moving target defense, validated experimentally on RISC-V and FPGA.", "motivation": "Electromagnetic (EM) side-channel attacks exploit microprocessor leakage to extract sensitive data (e.g., cryptographic keys, neural network hyperparameters). Existing defenses lack automatic, hardware-integrated solutions.", "method": "ShuffleV implements moving target defense (MTD): hardware units shuffle instruction execution order and insert dummy instructions randomly. It provides six RISC-V-based design options and an FPGA simulator to evaluate performance overhead and trace randomness.", "result": "ShuffleV successfully defends AES encryption and neural network inference against EM SCAs on Xilinx PYNQ-Z2 FPGA, achieving automatic protection with no software modifications or user intervention. Performance overheads are quantifiable via the provided simulator.", "conclusion": "ShuffleV demonstrates effective countermeasures for EM side-channel vulnerabilities through hardware-driven instruction randomization, adaptable to diverse applications with minimal user effort."}}
{"id": "2510.13176", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.13176", "abs": "https://arxiv.org/abs/2510.13176", "authors": ["Haolin Pan", "Chao Zha", "Jinyuan Dong", "Mingjie Xing", "Yanjun Wu"], "title": "GRACE: Globally-Seeded Representation-Aware Cluster-Specific Evolution for Compiler Auto-Tuning", "comment": null, "summary": "Compiler pass selection and phase ordering present a significant challenge in\nachieving optimal program performance, particularly for objectives like code\nsize reduction. Standard compiler heuristics offer general applicability but\noften yield suboptimal, program-specific results due to their one-size-fits-all\nnature. While iterative compilation can find tailored solutions, its\nprohibitive search cost limits practical use. Machine learning approaches\npromise faster inference but frequently struggle with generalization to unseen\nprograms. This paper introduces GRACE, a novel framework for compiler\nauto-tuning, demonstrated for LLVM IR instruction count optimization. GRACE\neffectively curtails the search space by leveraging pass synergies and a\nweighted scoring method to generate initial high-quality candidate sequences\nand a pass pool. It then employs contrastive learning, using pass\nsequence-based data augmentation, to create program embeddings that facilitate\nsimilarity-aware clustering. Evolutionary search within these clusters yields a\ncoreset of $k$ specialized pass sequences designed for robust generalization to\nunseen programs. At test time, GRACE efficiently selects the best coreset\nsequence and refines it using lightweight techniques. Experimental results on\nseven diverse datasets show that GRACE reduces LLVM IR instruction count by an\naverage of 10.09% on LLVM 10.0.0 and 10.19% on LLVM 18.1.6 compared to opt -Oz,\nwhile incurring an average tuning time of less than 1s per program,\ndemonstrating its state-of-the-art performance and practical effectiveness.", "AI": {"tldr": "Introduces GRACE, a ML-based framework for compiler optimization that achieves significant code size reductions (10-10.2% over opt -Oz) with under 1s/program tuning time through pass sequence clustering and coreset evolution.", "motivation": "Standard compiler heuristics are suboptimal for program-specific optimizations like code size reduction. Iterative compilation is too slow for practical use, while ML approaches lack generalization to unseen programs. There is a need for a framework that balances search efficiency, optimization quality, and generalization.", "method": "GRACE leverages pass synergies and a weighted scoring method to generate high-quality initial pass sequences. It uses contrastive learning with pass sequence-based data augmentation to create similarity-aware clusters and applies evolutionary search within clusters to produce a coreset of specialized sequences. Test-time optimization involves selecting and refining the best coreset sequence.", "result": "GRACE reduces LLVM IR instruction counts by 10.09% on LLVM 10.0.0 and 10.19% on LLVM 18.1.6 compared to opt -Oz across 7 diverse datasets. It achieves these results with an average tuning time of less than 1 second per program.", "conclusion": "GRACE is a state-of-the-art framework for compiler auto-tuning that combines efficient search space reduction, contrastive learning, and evolutionary clustering to achieve robust code size optimization with minimal tuning time (under 1s/program)."}}
{"id": "2510.13136", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.13136", "abs": "https://arxiv.org/abs/2510.13136", "authors": ["Tan Le", "Van Le", "Sachin Shetty"], "title": "Privacy-Aware Framework of Robust Malware Detection in Indoor Robots: Hybrid Quantum Computing and Deep Neural Networks", "comment": null, "summary": "Indoor robotic systems within Cyber-Physical Systems (CPS) are increasingly\nexposed to Denial of Service (DoS) attacks that compromise localization,\ncontrol and telemetry integrity. We propose a privacy-aware malware detection\nframework for indoor robotic systems, which leverages hybrid quantum computing\nand deep neural networks to counter DoS threats in CPS, while preserving\nprivacy information. By integrating quantum-enhanced feature encoding with\ndropout-optimized deep learning, our architecture achieves up to 95.2%\ndetection accuracy under privacy-constrained conditions. The system operates\nwithout handcrafted thresholds or persistent beacon data, enabling scalable\ndeployment in adversarial environments. Benchmarking reveals robust\ngeneralization, interpretability and resilience against training instability\nthrough modular circuit design. This work advances trustworthy AI for secure,\nautonomous CPS operations.", "AI": {"tldr": "This paper introduces a quantum-boosted AI framework for securing CPS robots against DoS attacks with 95.2% accuracy, privacy protection, and scalable deployment capabilities.", "motivation": "Indoor robotic systems in CPS face DoS attacks that compromise critical functions like localization and control. Existing solutions lack privacy and scalability, necessitating a novel attack detection approach for adversarial environments.", "method": "The framework uses hybrid quantum computing with deep neural networks, integrating quantum-enhanced feature encoding and dropout-optimized deep learning to counter DoS attacks without requiring handcrafted thresholds or persistent beacon data.", "result": "The system achieves 95.2% detection accuracy under privacy constraints while demonstrating robust generalization, interpretability, and resilience through modular circuit design.", "conclusion": "This work advances trustworthy AI for secure, autonomous CPS operations by developing a privacy-aware malware detection framework that combines quantum computing and deep learning."}}
{"id": "2510.13184", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.13184", "abs": "https://arxiv.org/abs/2510.13184", "authors": ["Haolin Pan", "Jinyuan Dong", "Mingjie Xing", "Yanjun Wu"], "title": "Synergy-Guided Compiler Auto-Tuning of Nested LLVM Pass Pipelines", "comment": null, "summary": "Compiler optimization relies on sequences of passes to improve program\nperformance. Selecting and ordering these passes automatically, known as\ncompiler auto-tuning, is challenging due to the large and complex search space.\nExisting approaches generally assume a linear sequence of passes, a model\ncompatible with legacy compilers but fundamentally misaligned with the\nhierarchical design of the LLVM New Pass Manager. This misalignment prevents\nthem from guaranteeing the generation of syntactically valid optimization\npipelines. In this work, we present a new auto-tuning framework built from the\nground up for the New Pass Manager. We introduce a formal grammar to define the\nspace of valid nested pipelines and a forest-based data structure for their\nnative representation. Upon this foundation, we develop a structure-aware\nGenetic Algorithm whose operators manipulate these forests directly, ensuring\nthat all candidate solutions are valid by construction. The framework first\nmines synergistic pass relationships to guide the search. An optional\nrefinement stage further explores subtle performance variations arising from\ndifferent valid structural arrangements.\n  We evaluate our approach on seven benchmark datasets using LLVM 18.1.6. The\ndiscovered pipelines achieve an average of 13.62% additional instruction count\nreduction compared to the standard opt -Oz optimization level, showing that our\nframework is capable of navigating this complex, constrained search space to\nidentify valid and effective pass pipelines.", "AI": {"tldr": "The paper introduces an LLVM New Pass Manager-aligned auto-tuning framework that uses formal grammars and structure-aware genetic algorithms to generate valid optimization pipelines, achieving 13.62%% better instruction count reduction than standard optimizations.", "motivation": "Legacy linear-pass auto-tuning methods are incompatible with LLVM's hierarchical New Pass Manager, leading to invalid pipelines and suboptimal optimizations.", "method": "Developed 1) formal grammar for valid nested pipelines, 2 fuel-based representation, 3 structure-aware genetic algorithm with pass relationship mining and refinement stages.", "result": "13.62%%*/18.1.6 evaluation shows superior instruction count reduction over LLVM's -O3 optimization, demonstrating effective navigation of complex constrained search space.", "conclusion": "Framework establishes native hierarchical pipeline optimization for LLVM, outperforming legacy approaches while guaranteeing syntactic validity."}}
{"id": "2510.13257", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.13257", "abs": "https://arxiv.org/abs/2510.13257", "authors": ["Jiarui Li", "Yuhan Chai", "Lei Du", "Chenyun Duan", "Hao Yan", "Zhaoquan Gu"], "title": "GRIDAI: Generating and Repairing Intrusion Detection Rules via Collaboration among Multiple LLM-based Agents", "comment": null, "summary": "Rule-based network intrusion detection systems play a crucial role in the\nreal-time detection of Web attacks. However, most existing works primarily\nfocus on automatically generating detection rules for new attacks, often\noverlooking the relationships between new attacks and existing rules, which\nleads to significant redundancy within the ever-expanding ruleset. To address\nthis issue, we propose GRIDAI, a novel end-to-end framework for the automated\nGeneration and Repair of Intrusion Detection rules through collaboration among\nmultiple LLM-based agents. Unlike traditional methods, GRIDAI first assesses\nthe nature of incoming attack samples. If the sample represents a new attack\ntype, it is used to generate a new rule. Otherwise, the sample is identified as\na variant of an attack already covered by an existing rule and used to repair\nthe rule by updating the corresponding signature, thereby enhancing its\ngeneralization capability. Additionally, to mitigate syntactic and semantic\nerrors in rules caused by LLM hallucinations, we incorporate a tool-based\nreal-time validation mechanism and a representative attack sample maintained\nfor each rule, enabling fully automated rule generation and repair.\nComprehensive experiments were conducted on a public dataset containing seven\ntypes of attacks and a private dataset with 43 attack types. The results\ndemonstrate that GRIDAI accurately identifies the relationships between new\nattack samples and existing rules, efficiently generates and repairs rules to\nhandle new attacks and variants, and effectively mitigates the impact of LLM\nhallucinations.", "AI": {"tldr": "This paper introduces GRIDAI, a framework using LLM agents to automate intrusion detection rule generation and repair, reducing redundancy by identifying relationships between new attacks and existing rules while mitigating LLM hallucination errors through real-time validation.", "motivation": "Existing rule-based intrusion detection systems lack mechanisms to manage redundancy from new attacks and rule variants, leading to inefficient rule expansion and oversight of attack relationships.", "method": "GRIDAI employs collaborative LLM agents to (1) distinguish new attacks from variants of existing rules, (2 ) generate new rules for novel attacks, (3) repair existing rules with enhanced generalization for variants, and (4 ) incorporate real-time validation tools and representative attack samples to correct LLM hallucinations during rule creation.", "result": "Experiments on datasets with 50 attack types demonstrated GRIDAI's ability to accurately identify attack relationships, generate/repair rules with high efficiency, and reduce LLM-generated errors through its validation mechanisms.", "conclusion": "GRIDAI provides an effective end-to-end solution for automated intrusion detection rule management, addressing redundancy and hallucination issues while improving rule generalization across attack variants."}}
{"id": "2510.13423", "categories": ["cs.SE", "cs.MS"], "pdf": "https://arxiv.org/pdf/2510.13423", "abs": "https://arxiv.org/abs/2510.13423", "authors": ["Matthew Sottile", "Mohit Tekriwal", "John Sarracino"], "title": "Towards Richer Challenge Problems for Scientific Computing Correctness", "comment": "In Proceedings VSS 2025, arXiv:2510.12314", "summary": "Correctness in scientific computing (SC) is gaining increasing attention in\nthe formal methods (FM) and programming languages (PL) community. Existing\nPL/FM verification techniques struggle with the complexities of realistic SC\napplications. Part of the problem is a lack of a common understanding between\nthe SC and PL/FM communities of machine-verifiable correctness challenges and\ndimensions of correctness in SC applications.\n  To address this gap, we call for specialized challenge problems to inform the\ndevelopment and evaluation of FM/PL verification techniques for correctness in\nSC. These specialized challenges are intended to augment existing problems\nstudied by FM/PL researchers for general programs to ensure the needs of SC\napplications can be met. We propose several dimensions of correctness relevant\nto scientific computing, and discuss some guidelines and criteria for designing\nchallenge problems to evaluate correctness in scientific computing.", "AI": {"tldr": "This paper advocates for specialized challenge problems to enhance formal methods/programming languages verification in scientific computing by addressing domain-specific correctness dimensions and bridging gaps in community understanding.", "motivation": "Current FM/PL verification techniques struggle with the complexities of scientific computing (SC) applications, partly due to a lack of shared understanding of SC's correctness requirements between the SC and PL/FM communities. This gap limits progress in ensuring machine-verifiable correctness for SC systems.", "method": "The authors propose designing specialized challenge problems to address correctness in scientific computing, complementing existing FM/PL benchmarks. They outline dimensions of correctness and criteria for creating challenges, such as mathematical precision, numerical stability, and domain-specific constraints.", "result": "The paper proposes several dimensions of correctness relevant to SC and provides guidelines for designing challenge problems to evaluate verification techniques in this domain. These contributions aim to standardize and improve methods for addressing SC's unique correctness challenges.", "conclusion": "The paper concludes that developing specialized challenge problems, tailored to the unique dimensions of correctness in scientific computing, is essential for advancing FM/PL verification techniques and ensuring their effectiveness in real-world SC applications through cross-community collaboration."}}
{"id": "2510.13318", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.13318", "abs": "https://arxiv.org/abs/2510.13318", "authors": ["Jucai Yang", "Liang Li", "Yiwei Gu", "Haiqin Wu"], "title": "Fast Authenticated and Interoperable Multimedia Healthcare Data over Hybrid-Storage Blockchains", "comment": null, "summary": "The integration of blockchain technology into healthcare presents a paradigm\nshift for secure data management, enabling decentralized and tamper-proof\nstorage and sharing of sensitive Electronic Health Records (EHRs). However,\nexisting blockchain-based healthcare systems, while providing robust access\ncontrol, commonly overlook the high latency in user-side re-computation of\nhashes for integrity verification of large multimedia data, impairing their\npracticality, especially in time-sensitive clinical scenarios. In this paper,\nwe propose FAITH, an innovative scheme for \\underline{F}ast\n\\underline{A}uthenticated and \\underline{I}nteroperable mul\\underline{T}imedia\n\\underline{H}ealthcare data storage and sharing over hybrid-storage\nblockchains. Rather than user-side hash re-computations, FAITH lets an\noff-chain storage provider generate verifiable proofs using recursive\nZero-Knowledge Proofs (ZKPs), while the user only needs to perform lightweight\nverification. For flexible access authorization, we leverage Proxy\nRe-Encryption (PRE) and enable the provider to conduct ciphertext\nre-encryption, in which the re-encryption correctness can be verified via ZKPs\nagainst the malicious provider. All metadata and proofs are recorded on-chain\nfor public verification. We provide a comprehensive analysis of FAITH's\nsecurity regarding data privacy and integrity. We implemented a prototype of\nFAITH, and extensive experiments demonstrated its practicality for\ntime-critical healthcare applications, dramatically reducing user-side\nverification latency by up to $98\\%$, bringing it from $4$ s down to around\n$70$ ms for a $5$ GB encrypted file.", "AI": {"tldr": "FAITH addresses blockchain latency in healthcare by using off-chain ZKPs and Proxy Re-Encryption, reducing user-side verification latency for large EHRs by 98%.", "motivation": "Existing blockchain-based healthcare systems suffer from high latency in user-side hash re-computation for large multimedia data, limiting their practicality in time-sensitive clinical scenarios.", "method": "FAITH employs off-chain storage providers to generate verifiable proofs via recursive Zero-Knowledge Proofs (ZKPs) and uses Proxy Re-Encryption (PRE) for re-encryption verification. Metadata and proofs are stored on-chain for public verification.", "result": "Experiments show FAITH reduces user-side verification latency by 98%, from 4 seconds to ~70 ms for a 5 GB encrypted file, while maintaining data privacy and integrity.", "conclusion": "FAITH enables practical, secure, and interoperable healthcare data sharing over hybrid-storage blockchains through efficient ZKPs and PRE, making it suitable for time-critical applications."}}
{"id": "2510.13424", "categories": ["cs.SE", "D.2.5; G.1.3"], "pdf": "https://arxiv.org/pdf/2510.13424", "abs": "https://arxiv.org/abs/2510.13424", "authors": ["Alexander C. Wilton"], "title": "Verifying a Sparse Matrix Algorithm Using Symbolic Execution", "comment": "In Proceedings VSS 2025, arXiv:2510.12314", "summary": "Scientific software is, by its very nature, complex. It is mathematical and\nhighly optimized which makes it prone to subtle bugs not as easily detected by\ntraditional testing. We outline how symbolic execution can be used to write\ntests similar to traditional unit tests while providing stronger verification\nguarantees and apply this methodology to a sparse matrix algorithm.", "AI": {"tldr": "Symbolic execution enhances testing of math-heavy scientific software by identifying bugs missed by traditional methods, validated via sparse matrix algorithms.", "motivation": "Scientific software is inherently complex and optimized mathematically, making it susceptible to hard-to-detect bugs that traditional testing methods may fail to uncover.", "method": "Symbolic execution is employed to create tests analogous to traditional unit tests. This approach is applied specifically to a sparse matrix algorithm, allowing for thorough verification by exploring multiple execution paths.", "result": "The methodology successfully demonstrates stronger verification guarantees for sparse matrix algorithms, highlighting symbolic execution's ability to reveal edge-case vulnerabilities not captured by conventional testing.", "conclusion": "Symbolic execution offers a robust methodology for testing complex scientific software, providing verification guarantees that traditional testing methods lack, particularly effective in identifying subtle bugs in mathematical algorithms like sparse matrix computations."}}
{"id": "2510.13322", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.13322", "abs": "https://arxiv.org/abs/2510.13322", "authors": ["Baogang Song", "Dongdong Zhao", "Jianwen Xiang", "Qiben Xu", "Zizhuo Yu"], "title": "Injection, Attack and Erasure: Revocable Backdoor Attacks via Machine Unlearning", "comment": null, "summary": "Backdoor attacks pose a persistent security risk to deep neural networks\n(DNNs) due to their stealth and durability. While recent research has explored\nleveraging model unlearning mechanisms to enhance backdoor concealment,\nexisting attack strategies still leave persistent traces that may be detected\nthrough static analysis. In this work, we introduce the first paradigm of\nrevocable backdoor attacks, where the backdoor can be proactively and\nthoroughly removed after the attack objective is achieved. We formulate the\ntrigger optimization in revocable backdoor attacks as a bilevel optimization\nproblem: by simulating both backdoor injection and unlearning processes, the\ntrigger generator is optimized to achieve a high attack success rate (ASR)\nwhile ensuring that the backdoor can be easily erased through unlearning. To\nmitigate the optimization conflict between injection and removal objectives, we\nemploy a deterministic partition of poisoning and unlearning samples to reduce\nsampling-induced variance, and further apply the Projected Conflicting Gradient\n(PCGrad) technique to resolve the remaining gradient conflicts. Experiments on\nCIFAR-10 and ImageNet demonstrate that our method maintains ASR comparable to\nstate-of-the-art backdoor attacks, while enabling effective removal of backdoor\nbehavior after unlearning. This work opens a new direction for backdoor attack\nresearch and presents new challenges for the security of machine learning\nsystems.", "AI": {"tldr": "This paper proposes revocable backdoor attacks that optimize triggers for both attack effectiveness and unlearnability, enabling stealthy attacks with post-objective removal capabilities, as demonstrated on benchmark datasets.", "motivation": "Existing backdoor attacks leave detectable traces that persist after unlearning. The authors aim to develop attacks that can be proactively and thoroughly removed after achieving their objectives, addressing traceability issues.", "method": "The approach frames trigger optimization as a bilevel problem, combining backdoor injection and unlearning simulations. It uses deterministic sample partitioning and PCGrad to resolve optimization conflicts between attack success and unlearnability objectives.", "result": "Experiments on CIFAR-10 and ImageNet show the method achieves state-of-the-art attack success rates (ASR) while enabling effective backdoor removal via unlearning, outperforming previous attacks in revocability.", "conclusion": "This work introduces revocable backdoor attacks, offering a new research direction that challenges the security of ML systems by enabling backdoor removal post-attack, while maintaining comparable attack performance to existing methods."}}
{"id": "2510.13561", "categories": ["cs.SE", "cs.AI", "68N30"], "pdf": "https://arxiv.org/pdf/2510.13561", "abs": "https://arxiv.org/abs/2510.13561", "authors": ["Peng Di", "Faqiang Chen", "Xiao Bai", "Hongjun Yang", "Qingfeng Li", "Ganglin Wei", "Jian Mou", "Feng Shi", "Keting Chen", "Peng Tang", "Zhitao Shen", "Zheng Li", "Wenhui Shi", "Junwei Guo", "Hang Yu"], "title": "OpenDerisk: An Industrial Framework for AI-Driven SRE, with Design, Implementation, and Case Studies", "comment": "23 pages", "summary": "The escalating complexity of modern software imposes an unsustainable\noperational burden on Site Reliability Engineering (SRE) teams, demanding\nAI-driven automation that can emulate expert diagnostic reasoning. Existing\nsolutions, from traditional AI methods to general-purpose multi-agent systems,\nfall short: they either lack deep causal reasoning or are not tailored for the\nspecialized, investigative workflows unique to SRE. To address this gap, we\npresent OpenDerisk, a specialized, open-source multi-agent framework\narchitected for SRE. OpenDerisk integrates a diagnostic-native collaboration\nmodel, a pluggable reasoning engine, a knowledge engine, and a standardized\nprotocol (MCP) to enable specialist agents to collectively solve complex,\nmulti-domain problems. Our comprehensive evaluation demonstrates that\nOpenDerisk significantly outperforms state-of-the-art baselines in both\naccuracy and efficiency. This effectiveness is validated by its large-scale\nproduction deployment at Ant Group, where it serves over 3,000 daily users\nacross diverse scenarios, confirming its industrial-grade scalability and\npractical impact. OpenDerisk is open source and available at\nhttps://github.com/derisk-ai/OpenDerisk/", "AI": {"tldr": "OpenDerisk is a specialized multi-agent framework solving SRE challenges through causal reasoning and domain-specific collaboration. It outperforms existing solutions and scales to production environments at Ant Group, now open-sourced.", "motivation": "Modern software complexity overwhelms SRE teams, and existing AI solutions lack causal reasoning or are improperly tailored to SRE's investigative workflows. This creates a need for specialized automation that emulates expert diagnostic reasoning.", "method": "The authors developed OpenDerisk, an open-source multi-agent framework comprising a diagnostic-native collaboration model, pluggable reasoning engine, knowledge engine, and the MCP protocol to coordinate specialist agents for multi-domain SRE tasks.", "result": "OpenDerisk outperforms state-of-the-art baselines in accuracy and efficiency, and is successfully deployed at Ant Group with 3,000+ daily active users across diverse scenarios, demonstrating industrial scalability.", "conclusion": "OpenDerisk effectively addresses SRE challenges through a specialized multi-agent framework that excels in complex diagnostics, validated by industrial deployment and performance gains."}}
{"id": "2510.13370", "categories": ["cs.CR", "cs.NI"], "pdf": "https://arxiv.org/pdf/2510.13370", "abs": "https://arxiv.org/abs/2510.13370", "authors": ["Fernando Castillo", "Eduardo Brito", "Sebastian Werner", "Pille Pullonen-Raudvere", "Jonathan Heiss"], "title": "Towards Trusted Service Monitoring: Verifiable Service Level Agreements", "comment": "To be published in 3rd International Conference on Service-Oriented\n  Computing (ICSOC 2025). 15 pages. 4 figures", "summary": "Service Level Agreement (SLA) monitoring in service-oriented environments\nsuffers from inherent trust conflicts when providers self-report metrics,\ncreating incentives to underreport violations. We introduce a framework for\ngenerating verifiable SLA violation claims through trusted hardware monitors\nand zero-knowledge proofs, establishing cryptographic foundations for genuine\ntrustworthiness in service ecosystems. Our approach starts with\nmachine-readable SLA clauses converted into verifiable predicates and monitored\nwithin Trusted Execution Environments. These monitors collect timestamped\ntelemetry, organize measurements into Merkle trees, and produce signed\nattestations. Zero-knowledge proofs aggregate Service-Level Indicators to\nevaluate compliance, generating cryptographic proofs verifiable by\nstakeholders, arbitrators, or insurers in disputes, without accessing\nunderlying data. This ensures three security properties: integrity,\nauthenticity, and validity. Our prototype demonstrates linear scaling up to\nover 1 million events per hour for measurements with near constant-time proof\ngeneration and verification for single violation claims, enabling trustless SLA\nenforcement through cryptographic guarantees for automated compliance\nverification in service monitoring.", "AI": {"tldr": "This work enables verifiable SLA monitoring via TEEs and zero-knowledge proofs, ensuring trustless compliance verification with strong security properties and high scalability.", "motivation": "SLA monitoring suffers from trust conflicts when providers self-report metrics, incentivizing underreporting of violations. Existing solutions lack cryptographic assurance for tamper-proof enforcement.", "method": "The approach converts machine-readable SLA clauses into verifiable predicates within TEEs, collects timestamped telemetry in Merkle trees, and uses zero-knowledge proofs to generate cryptographically verifiable compliance evidence without exposing raw data.", "result": "The prototype achieves linear scalability beyond 1 million events/hour with near-constant-time proof generation/verification, demonstrating practical feasibility for large-scale service monitoring.", "conclusion": "The paper presents a framework for trustless SLA enforcement using TEEs and zero-knowledge proofs, enabling automated compliance verification with strong cryptographic guarantees."}}
{"id": "2510.13575", "categories": ["cs.SE", "D.2.5"], "pdf": "https://arxiv.org/pdf/2510.13575", "abs": "https://arxiv.org/abs/2510.13575", "authors": ["Han Fu", "Sigrid Eldh", "Kristian Wiklund", "Andreas Ermedahl", "Philipp Haller", "Cyrille Artho"], "title": "Auto-repair without test cases: How LLMs fix compilation errors in large industrial embedded code", "comment": "9 pages, 4 figures, conference: 2025 28th Euromicro Conference on\n  Digital System Design (DSD)", "summary": "The co-development of hardware and software in industrial embedded systems\nfrequently leads to compilation errors during continuous integration (CI).\nAutomated repair of such failures is promising, but existing techniques rely on\ntest cases, which are not available for non-compilable code.\n  We employ an automated repair approach for compilation errors driven by large\nlanguage models (LLMs). Our study encompasses the collection of more than 40000\ncommits from the product's source code. We assess the performance of an\nindustrial CI system enhanced by four state-of-the-art LLMs, comparing their\noutcomes with manual corrections provided by human programmers. LLM-equipped CI\nsystems can resolve up to 63 % of the compilation errors in our baseline\ndataset. Among the fixes associated with successful CI builds, 83 % are deemed\nreasonable. Moreover, LLMs significantly reduce debugging time, with the\nmajority of successful cases completed within 8 minutes, compared to hours\ntypically required for manual debugging.", "AI": {"tldr": "LLMs enable test-case-free compilation error repair in industrial CI, achieving 63% resolution accuracy and reducing debugging time from hours to minutes.", "motivation": "Compilation errors in co-developed hardware/software industrial systems are challenging to automate because existing methods require test cases, which are unavailable for non-compilable code.", "method": "The study collected over 40,000 commits and evaluated four state-of-the-art LLMs in an industrial CI system, comparing LLM-generated repairs to manual fixes by human programmers.", "result": "LLMs resolved 63% of compilation errors in the dataset, with 83% of fixes deemed reasonable and 65% of successful repairs completed within 8 minutes (vs. hours manually).", "conclusion": "LLMs can be effectively employed in industrial CI systems to resolve compilation errors in embedded systems, offering high accuracy and significantly reducing debugging time compared to manual methods."}}
{"id": "2510.13451", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.13451", "abs": "https://arxiv.org/abs/2510.13451", "authors": ["Li Bai", "Qingqing Ye", "Xinwei Zhang", "Sen Zhang", "Zi Liang", "Jianliang Xu", "Haibo Hu"], "title": "Toward Efficient Inference Attacks: Shadow Model Sharing via Mixture-of-Experts", "comment": "To appear in NeurIPS 2025", "summary": "Machine learning models are often vulnerable to inference attacks that expose\nsensitive information from their training data. Shadow model technique is\ncommonly employed in such attacks, such as membership inference. However, the\nneed for a large number of shadow models leads to high computational costs,\nlimiting their practical applicability. Such inefficiency mainly stems from the\nindependent training and use of these shadow models. To address this issue, we\npresent a novel shadow pool training framework SHAPOOL, which constructs\nmultiple shared models and trains them jointly within a single process. In\nparticular, we leverage the Mixture-of-Experts mechanism as the shadow pool to\ninterconnect individual models, enabling them to share some sub-networks and\nthereby improving efficiency. To ensure the shared models closely resemble\nindependent models and serve as effective substitutes, we introduce three novel\nmodules: path-choice routing, pathway regularization, and pathway alignment.\nThese modules guarantee random data allocation for pathway learning, promote\ndiversity among shared models, and maintain consistency with target models. We\nevaluate SHAPOOL in the context of various membership inference attacks and\nshow that it significantly reduces the computational cost of shadow model\nconstruction while maintaining comparable attack performance.", "AI": {"tldr": "The paper introduces SHAPOOL, a shadow pool training framework that reduces the computational cost of training multiple shadow models by jointly training shared models using a Mixture-of-Experts mechanism, while maintaining attack effectiveness.", "motivation": "Machine learning models are susceptible to inference attacks that require a large number of shadow models, which are costly to train and use independently.", "method": "SHAPOOL employs a Mixture-of-Experts mechanism as a shadow pool to train multiple shared models jointly. It introduces path-choice routing, pathway regularization, and pathway alignment to ensure model diversity and consistency with target models.", "result": "SHAPOOL significantly reduces the computational cost of shadow model construction while maintaining comparable performance in membership inference attacks.", "conclusion": "The proposed SHAPOOL framework offers an efficient and effective solution for training shadow models, improving the practicality of inference attacks with minimal resource consumption."}}
{"id": "2510.13692", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.13692", "abs": "https://arxiv.org/abs/2510.13692", "authors": ["Deepak A. Cherian"], "title": "Property Testing for Ocean Models. Can We Specify It? (Invited Talk)", "comment": "In Proceedings VSS 2025, arXiv:2510.12314", "summary": "I take inspiration from the property-testing literature, particularly the\nwork of Prof. John Hughes, and explore how such ideas might be applied to\nnumerical models of the ocean. Specifically, I ask whether geophysical fluid\ndynamics (GFD) theory, expressed as property tests, might be used to address\nthe oracle problem of testing the correctness of ocean models. I propose that a\nnumber of simple idealized GFD problems can be framed as property tests. These\nexamples clearly illustrate how physics naturally lends itself to specifying\nproperty tests. Which of these proposed tests might be most feasible and\nuseful, remains to be seen.", "AI": {"tldr": "This paper explores using property tests derived from geophysical fluid dynamics theory to validate ocean models, addressing the 'oracle problem' in model testing. While the approach shows theoretical promise, practical feasibility remains to be determined.", "motivation": "The paper aims to solve the oracle problem in testing ocean numerical models by leveraging property-testing methodologies from computer science, specifically those developed by Prof. John Hughes, to create physics-based validation criteria.", "method": "The author proposes framing simple idealized geophysical fluid dynamics (GFD) problems as property tests, inspired by property-testing literature, to address the oracle problem in ocean model validation.", "result": "The author demonstrates that physics (GFD theory) naturally aligns with property testing formulations, but notes that practical implementation details (e.g., which specific tests are most valuable) remain to be validated.", "conclusion": "The paper concludes that while the approach of using GFD-based property tests shows promise, further research is needed to determine the feasibility and utility of specific tests in practical ocean modeling contexts."}}
{"id": "2510.13462", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.13462", "abs": "https://arxiv.org/abs/2510.13462", "authors": ["Xin Zhao", "Xiaojun Chen", "Bingshan Liu", "Haoyu Gao", "Zhendong Zhao", "Yilong Chen"], "title": "Who Speaks for the Trigger? Dynamic Expert Routing in Backdoored Mixture-of-Experts Transformers", "comment": null, "summary": "Large language models (LLMs) with Mixture-of-Experts (MoE) architectures\nachieve impressive performance and efficiency by dynamically routing inputs to\nspecialized subnetworks, known as experts. However, this sparse routing\nmechanism inherently exhibits task preferences due to expert specialization,\nintroducing a new and underexplored vulnerability to backdoor attacks. In this\nwork, we investigate the feasibility and effectiveness of injecting backdoors\ninto MoE-based LLMs by exploiting their inherent expert routing preferences. We\nthus propose BadSwitch, a novel backdoor framework that integrates task-coupled\ndynamic trigger optimization with a sensitivity-guided Top-S expert tracing\nmechanism. Our approach jointly optimizes trigger embeddings during pretraining\nwhile identifying S most sensitive experts, subsequently constraining the Top-K\ngating mechanism to these targeted experts. Unlike traditional backdoor attacks\nthat rely on superficial data poisoning or model editing, BadSwitch primarily\nembeds malicious triggers into expert routing paths with strong task affinity,\nenabling precise and stealthy model manipulation. Through comprehensive\nevaluations across three prominent MoE architectures (Switch Transformer,\nQwenMoE, and DeepSeekMoE), we demonstrate that BadSwitch can efficiently hijack\npre-trained models with up to 100% success rate (ASR) while maintaining the\nhighest clean accuracy (ACC) among all baselines. Furthermore, BadSwitch\nexhibits strong resilience against both text-level and model-level defense\nmechanisms, achieving 94.07% ASR and 87.18% ACC on the AGNews dataset. Our\nanalysis of expert activation patterns reveals fundamental insights into MoE\nvulnerabilities. We anticipate this work will expose security risks in MoE\nsystems and contribute to advancing AI safety.", "AI": {"tldr": "Error", "motivation": "Error", "method": "Error", "result": "Error", "conclusion": "Error"}}
{"id": "2510.13697", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.13697", "abs": "https://arxiv.org/abs/2510.13697", "authors": ["Maksim Sapronov", "Evgeniy Glukhov"], "title": "On Pretraining for Project-Level Code Completion", "comment": null, "summary": "Repository-level pretraining is commonly used to enable large language models\nfor code to leverage codebase-wide context. This enhances their ability to\ngenerate accurate and context-aware code completions. In this work, we\ninvestigate how different repository-processing strategies affect in-context\nlearning in OpenCoder, a 1.5B-parameter model. We extend its context window\nfrom 4,096 to 16,384 tokens by training on additional 1B tokens of curated\nrepository-level data. Despite relying on a smaller dataset than competing\nmodels (which often use hundreds of billions of tokens), our model achieves\ncomparable performance on the Long Code Arena benchmark. We find that various\nrepository-processing techniques yield similarly strong results, with the\nprimary gain coming from adapting to a new rotary positional embedding (RoPE)\nscaling parameter. Finally, we show that a simpler file-level training approach\nat the original sequence length remains highly effective, opening up\nrepository-level code completion research to settings with more constrained\ndata and compute resources.", "AI": {"tldr": "By optimizing repository-level pretraining and using a new RoPE parameter, the 1.5B OpenCoder model matches state-of-the-art performance on code benchmarks with far less data, enabling practical code completion in resource-limited scenarios.", "motivation": "The paper investigates how repository-processing strategies impact in-context learning in code models to enable efficient context-aware code completions, especially for resource-constrained settings.", "method": "The method involved extending the model's context window by training on an additional 1B tokens of curated data, testing various repository-processing strategies, and adapting the RoPE scaling parameter. The model's performance was evaluated on the Long Code Arena benchmark.", "result": "The model achieved comparable performance on the Long Code Arena benchmark despite using a smaller dataset than competitors. Repository-processing techniques and the RoPE scaling adjustment improved results, while a simpler file-level approach at the original sequence length remained effective.", "conclusion": "The study demonstrates that repository-level pretraining with optimized techniques, such as the new RoPE scaling parameter, can achieve strong performance even with limited data, while simpler methods remain effective for constrained environments."}}
{"id": "2510.13538", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2510.13538", "abs": "https://arxiv.org/abs/2510.13538", "authors": ["Alexander Ponticello", "Filipo Sharevski", "Simon Anell", "Katharina Krombholz"], "title": "How Blind and Low-Vision Users Manage Their Passwords", "comment": null, "summary": "Managing passwords securely and conveniently is still an open problem for\nmany users. Existing research has examined users' password management\nstrategies and identified pain points, such as security concerns, leading to\ninsecure practices. We investigate how Blind and Low-Vision (BLV) users tackle\nthis problem and how password managers can assist them. This paper presents the\nresults of a qualitative interview study with N = 33 BLV participants. We found\nthat all participants utilize password managers to some extent, which they\nperceive as fairly accessible. However, the adoption is mainly driven by the\nconvenience of storing and retrieving passwords. The security advantages -\ngenerating strong, random passwords - were avoided mainly due to the absence of\npractical accessibility. Password managers do not adhere to BLV users'\nunderlying needs for agency, which stem from experiences with inaccessible\nsoftware and vendors who deprioritize accessibility issues. Underutilization of\npassword managers leads BLV users to adopt insecure practices, such as reusing\npredictable passwords or resorting to 'security through obscurity' by writing\nimportant credentials in braille. We conclude our analysis by discussing the\nneed to implement practical accessibility and usability improvements for\npassword managers as a way of establishing trust and secure practices while\nmaintaining BLV users' agency.", "AI": {"tldr": "This paper investigates the use of password managers by Blind and Low-Vision (BLV) users and highlights their convenience-driven adoption despite accessibility barriers to security features. It emphasizes the need for practical accessibility improvements to ensure secure password management.", "motivation": "The motivation is that managing passwords securely and conveniently remains a significant challenge for many users, including BLV individuals, due to accessibility issues in existing password managers that hinder secure practices.", "method": "The study involved a qualitative interview with 33 Blind and Low-Vision (BLV) participants to understand their password management practices in the context of accessibility barriers.", "result": "The study found that BLV users primarily adopt password managers for convenience in storing and retrieving passwords, but avoid security features like password generation due to accessibility barriers. This results in insecure practices such as password reuse and writing crucial information in braille.", "conclusion": "The paper concludes by emphasizing that at-the-moment accessibility and usability improvements for password managers can establish trust and ensure secure practices while respecting BLV users' sense of agency."}}
{"id": "2510.13543", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.13543", "abs": "https://arxiv.org/abs/2510.13543", "authors": ["Avihay Cohen"], "title": "In-Browser LLM-Guided Fuzzing for Real-Time Prompt Injection Testing in Agentic AI Browsers", "comment": "37 pages , 10 figures", "summary": "Large Language Model (LLM) based agents integrated into web browsers (often\ncalled agentic AI browsers) offer powerful automation of web tasks. However,\nthey are vulnerable to indirect prompt injection attacks, where malicious\ninstructions hidden in a webpage deceive the agent into unwanted actions. These\nattacks can bypass traditional web security boundaries, as the AI agent\noperates with the user privileges across sites. In this paper, we present a\nnovel fuzzing framework that runs entirely in the browser and is guided by an\nLLM to automatically discover such prompt injection vulnerabilities in real\ntime.", "AI": {"tldr": "The paper introduces a browser-based LLM-guided fuzzing framework for real-time detection of prompt injection vulnerabilities in agentic AI browsers.", "motivation": "Current agentic AI browsers, while powerful for web task automation, are susceptible to prompt injection attacks that can bypass security measures and allow malicious actions.", "method": "The authors developed a fuzzing framework that operates within the browser, using an LLM to guide the testing process and identify vulnerabilities in real-time.", "result": "The framework successfully uncovered prompt injection vulnerabilities in agentic AI browsers, demonstrating its effectiveness in real-time detection.", "conclusion": "The proposed LLM-guided fuzzing framework is an innovative solution to detect and mitigate prompt injection attacks in AI-integrated web browsers."}}
