{"id": "2601.18827", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.18827", "abs": "https://arxiv.org/abs/2601.18827", "authors": ["Jens Kohl", "Otto Kruse", "Youssef Mostafa", "Andre Luckow", "Karsten Schroer", "Thomas Riedl", "Ryan French", "David Katz", "Manuel P. Luitz", "Tanrajbir Takher", "Ken E. Friedl", "C\u00e9line Laurent-Winter"], "title": "Automated structural testing of LLM-based agents: methods, framework, and case studies", "comment": "10 pages, 5 figures. Preprint of an accepted paper at IEEE BigData 2025 (main track). Source code for the introduced methods and framework available at https://github.com/awslabs/generative-ai-toolkit", "summary": "LLM-based agents are rapidly being adopted across diverse domains. Since they interact with users without supervision, they must be tested extensively. Current testing approaches focus on acceptance-level evaluation from the user's perspective. While intuitive, these tests require manual evaluation, are difficult to automate, do not facilitate root cause analysis, and incur expensive test environments. In this paper, we present methods to enable structural testing of LLM-based agents. Our approach utilizes traces (based on OpenTelemetry) to capture agent trajectories, employs mocking to enforce reproducible LLM behavior, and adds assertions to automate test verification. This enables testing agent components and interactions at a deeper technical level within automated workflows. We demonstrate how structural testing enables the adaptation of software engineering best practices to agents, including the test automation pyramid, regression testing, test-driven development, and multi-language testing. In representative case studies, we demonstrate automated execution and faster root-cause analysis. Collectively, these methods reduce testing costs and improve agent quality through higher coverage, reusability, and earlier defect detection. We provide an open source reference implementation on GitHub.", "AI": {"tldr": "This paper introduces structural testing methods for LLM-based agents using traces, mocking, and assertions to enable automated, reproducible, and deep technical testing, reducing costs and improving quality.", "motivation": "LLM-based agents require extensive testing due to unsupervised user interaction, but current user-centric acceptance testing is manual, hard to automate, and\u4e0d\u5229\u4e8e root cause analysis and cost-efficiency.", "method": "The approach uses OpenTelemetry-based traces to capture agent trajectories, applies mocking for reproducible LLM behavior, and integrates assertions for automated verification, enabling component-level structural testing in automated workflows.", "result": "The method enables adaptation of SE best practices (e.g., test automation pyramid, regression testing, TDD) to agents; case studies show automated test execution and faster root-cause analysis with higher coverage and reusability.", "conclusion": "Structural testing significantly improves LLM-based agent testing by enabling automation, early defect detection, and cost reduction, supported by an open-source implementation."}}
{"id": "2601.18844", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.18844", "abs": "https://arxiv.org/abs/2601.18844", "authors": ["Xueying Du", "Jiayi Feng", "Yi Zou", "Wei Xu", "Jie Ma", "Wei Zhang", "Sisi Liu", "Xin Peng", "Yiling Lou"], "title": "Reducing False Positives in Static Bug Detection with LLMs: An Empirical Study in Industry", "comment": null, "summary": "Static analysis tools (SATs) are widely adopted in both academia and industry for improving software quality, yet their practical use is often hindered by high false positive rates, especially in large-scale enterprise systems. These false alarms demand substantial manual inspection, creating severe inefficiencies in industrial code review. While recent work has demonstrated the potential of large language models (LLMs) for false alarm reduction on open-source benchmarks, their effectiveness in real-world enterprise settings remains unclear. To bridge this gap, we conduct the first comprehensive empirical study of diverse LLM-based false alarm reduction techniques in an industrial context at Tencent, one of the largest IT companies in China. Using data from Tencent's enterprise-customized SAT on its large-scale Advertising and Marketing Services software, we construct a dataset of 433 alarms (328 false positives, 105 true positives) covering three common bug types. Through interviewing developers and analyzing the data, our results highlight the prevalence of false positives, which wastes substantial manual effort (e.g., 10-20 minutes of manual inspection per alarm). Meanwhile, our results show the huge potential of LLMs for reducing false alarms in industrial settings (e.g., hybrid techniques of LLM and static analysis eliminate 94-98% of false positives with high recall). Furthermore, LLM-based techniques are cost-effective, with per-alarm costs as low as 2.1-109.5 seconds and $0.0011-$0.12, representing orders-of-magnitude savings compared to manual review. Finally, our case analysis further identifies key limitations of LLM-based false alarm reduction in industrial settings.", "AI": {"tldr": "This study evaluates LLM-based false alarm reduction in an industrial setting at Tencent, showing that hybrid LLM-static analysis methods can eliminate 94\u201398% of false positives cost-effectively, though practical limitations remain.", "motivation": "High false positive rates in static analysis tools hinder their effectiveness in large-scale industrial systems, necessitating efficient and scalable solutions like LLMs to reduce manual inspection overhead.", "method": "The study conducts an empirical evaluation of various LLM-based false alarm reduction techniques using a real-world dataset of 433 static analysis alarms from Tencent's Advertising and Marketing Services, combining quantitative analysis with developer interviews and case studies.", "result": "LLM-based hybrid techniques eliminate 94\u201398% of false positives with high recall; per-alarm processing takes 2.1\u2013109.5 seconds and costs $0.0011\u2013$0.12, leading to substantial time and cost savings compared to manual review.", "conclusion": "LLM-based techniques show significant potential for reducing false positives from static analysis tools in enterprise environments, offering high recall and cost savings, though challenges and limitations remain in practical deployment."}}
{"id": "2601.18847", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.18847", "abs": "https://arxiv.org/abs/2601.18847", "authors": ["Zihan Wu", "Jie Xu", "Yun Peng", "Chun Yong Chong", "Xiaohua Jia"], "title": "MulVul: Retrieval-augmented Multi-Agent Code Vulnerability Detection via Cross-Model Prompt Evolution", "comment": null, "summary": "Large Language Models (LLMs) struggle to automate real-world vulnerability detection due to two key limitations: the heterogeneity of vulnerability patterns undermines the effectiveness of a single unified model, and manual prompt engineering for massive weakness categories is unscalable.\n  To address these challenges, we propose \\textbf{MulVul}, a retrieval-augmented multi-agent framework designed for precise and broad-coverage vulnerability detection. MulVul adopts a coarse-to-fine strategy: a \\emph{Router} agent first predicts the top-$k$ coarse categories and then forwards the input to specialized \\emph{Detector} agents, which identify the exact vulnerability types. Both agents are equipped with retrieval tools to actively source evidence from vulnerability knowledge bases to mitigate hallucinations.\n  Crucially, to automate the generation of specialized prompts, we design \\emph{Cross-Model Prompt Evolution}, a prompt optimization mechanism where a generator LLM iteratively refines candidate prompts while a distinct executor LLM validates their effectiveness. This decoupling mitigates the self-correction bias inherent in single-model optimization.\n  Evaluated on 130 CWE types, MulVul achieves 34.79\\% Macro-F1, outperforming the best baseline by 41.5\\%. Ablation studies validate cross-model prompt evolution, which boosts performance by 51.6\\% over manual prompts by effectively handling diverse vulnerability patterns.", "AI": {"tldr": "MulVul is a retrieval-augmented multi-agent framework for vulnerability detection that uses a coarse-to-fine strategy and cross-model prompt evolution to automate and optimize detection across diverse CWE types, achieving 34.79% Macro-F1 and outperforming baselines by 41.5%.", "motivation": "The limitations of current LLMs in automated vulnerability detection stem from the heterogeneity of vulnerability patterns and the unscalability of manual prompt engineering across numerous weakness categories. This motivates the need for a more adaptive, precise, and scalable framework.", "method": "MulVul employs a coarse-to-fine multi-agent architecture with a Router agent for top-k coarse category prediction and specialized Detector agents for precise vulnerability identification. It integrates retrieval-augmented reasoning from vulnerability knowledge bases and introduces Cross-Model Prompt Evolution, where a generator LLM and a separate executor LLM iteratively refine and validate prompts to eliminate manual engineering.", "result": "Evaluated across 130 CWE types, MulVul achieves a 34.79% Macro-F1 score, surpassing the best baseline by 41.5%. Ablation studies show that Cross-Model Prompt Evolution improves performance by 51.6% over manually engineered prompts, demonstrating its effectiveness in handling diverse vulnerability patterns.", "conclusion": "MulVul effectively improves vulnerability detection in large language models by leveraging a retrieval-augmented multi-agent framework with automated, cross-model prompt optimization, demonstrating superior performance and scalability over manual and single-model approaches."}}
{"id": "2601.18850", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.18850", "abs": "https://arxiv.org/abs/2601.18850", "authors": ["Sven Kirchner", "Nils Purschke", "Chengdong Wu", "Alois Knoll"], "title": "Towards Safety-Compliant Transformer Architectures for Automotive Systems", "comment": null, "summary": "Transformer-based architectures have shown remarkable performance in vision and language tasks but pose unique challenges for safety-critical applications. This paper presents a conceptual framework for integrating Transformers into automotive systems from a safety perspective. We outline how multimodal Foundation Models can leverage sensor diversity and redundancy to improve fault tolerance and robustness. Our proposed architecture combines multiple independent modality-specific encoders that fuse their representations into a shared latent space, supporting fail-operational behavior if one modality degrades. We demonstrate how different input modalities could be fused in order to maintain consistent scene understanding. By structurally embedding redundancy and diversity at the representational level, this approach bridges the gap between modern deep learning and established functional safety practices, paving the way for certifiable AI systems in autonomous driving.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.18834", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.18834", "abs": "https://arxiv.org/abs/2601.18834", "authors": ["Deep Mehta"], "title": "CanaryBench: Stress Testing Privacy Leakage in Cluster-Level Conversation Summaries", "comment": "13 pages, 4 figures. Code repository: https://github.com/researchaudio/canarybench", "summary": "Aggregate analytics over conversational data are increasingly used for safety monitoring, governance, and product analysis in large language model systems. A common practice is to embed conversations, cluster them, and publish short textual summaries describing each cluster. While raw conversations may never be exposed, these derived summaries can still pose privacy risks if they contain personally identifying information (PII) or uniquely traceable strings copied from individual conversations.\n  We introduce CanaryBench, a simple and reproducible stress test for privacy leakage in cluster-level conversation summaries. CanaryBench generates synthetic conversations with planted secret strings (\"canaries\") that simulate sensitive identifiers. Because canaries are known a priori, any appearance of these strings in published summaries constitutes a measurable leak.\n  Using TF-IDF embeddings and k-means clustering on 3,000 synthetic conversations (24 topics) with a canary injection rate of 0.60, we evaluate an intentionally extractive example snippet summarizer that models quote-like reporting. In this configuration, we observe canary leakage in 50 of 52 canary-containing clusters (cluster-level leakage rate 0.961538), along with nonzero regex-based PII indicator counts. A minimal defense combining a minimum cluster-size publication threshold (k-min = 25) and regex-based redaction eliminates measured canary leakage and PII indicator hits in the reported run while maintaining a similar cluster-coherence proxy. We position this work as a societal impacts contribution centered on privacy risk measurement for published analytics artifacts rather than raw user data.", "AI": {"tldr": "CanaryBench is introduced as a stress test for detecting privacy leakage in cluster-level summaries of conversational data by using synthetic 'canary' strings; it demonstrates high leakage rates in summaries, which can be mitigated by minimum cluster-size thresholds and redaction.", "motivation": "To measure and mitigate privacy risks in aggregate analytics of conversational data, especially when summaries derived from clustered embeddings may inadvertently expose personally identifying or traceable information.", "method": "CanaryBench uses synthetic conversations with embedded secret 'canary' strings; evaluates leakage via TF-IDF embeddings and k-means clustering (3,000 conversations, 24 topics, 0.60 injection rate); tests an extractive summarizer; applies regex-based PII detection and a defense using minimum cluster size (k-min=25) and redaction.", "result": "High canary leakage: 50 out of 52 canary-containing clusters showed leakage (96.15% cluster-level rate); nonzero PII indicator counts were detected; applying k-min=25 and redaction eliminated measurable canary and PII leakage while preserving cluster coherence.", "conclusion": "CanaryBench provides a reproducible method for quantifying privacy leakage in summary-level analytics; simple defenses like minimum cluster size and redaction can effectively mitigate risks, highlighting the need for privacy-aware reporting in LLM system governance."}}
{"id": "2601.18949", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.18949", "abs": "https://arxiv.org/abs/2601.18949", "authors": ["Cole Granger", "Dipin Khati", "Daniel Rodriguez-Cardenas", "Denys Poshyvanyk"], "title": "Tricky$^2$: Towards a Benchmark for Evaluating Human and LLM Error Interactions", "comment": null, "summary": "Large language models (LLMs) are increasingly integrated into software development workflows, yet they often introduce subtle logic or data-misuse errors that differ from human bugs. To study how these two error types interact, we construct Tricky$^2$, a hybrid dataset that augments the existing TrickyBugs corpus of human-written defects with errors injected by both GPT-5 and OpenAI-oss-20b across C++, Python, and Java programs. Our approach uses a taxonomy-guided prompting framework to generate machine-originated bugs while preserving original human defects and program structure. The resulting corpus spans human-only, LLM-only, and human+LLM splits, enabling analysis of mixed-origin error behavior, multi-bug repair robustness, and reliability in hybrid human-machine code. This paper outlines the dataset construction pipeline and illustrates its use through small-scale baseline evaluations of classification, localization, and repair tasks.", "AI": {"tldr": "Tricky^2 is a hybrid dataset combining human-written and LLM-generated bugs to study error interactions in human-machine collaborative coding, supporting research on bug classification, localization, and repair in mixed-origin code.", "motivation": "To understand the interaction between human-introduced and LLM-introduced logic and data-misuse errors in code, which differ in nature and pose unique challenges in software reliability.", "method": "The authors constructed Tricky^2 by augmenting the TrickyBugs dataset with LLM-generated bugs using a taxonomy-guided prompting framework, preserving original human defects and program structure across C++, Python, and Java.", "result": "The resulting dataset includes human-only, LLM-only, and human+LLM bug splits, and was evaluated on classification, localization, and repair tasks, demonstrating its utility for studying multi-source bugs.", "conclusion": "The Tricky^2 dataset enables the analysis of mixed-origin bugs (human, LLM, and combined) and supports research into the reliability and repair robustness of code produced in hybrid human-machine software development environments."}}
{"id": "2601.18842", "categories": ["cs.CR", "cs.AI", "cs.CV"], "pdf": "https://arxiv.org/pdf/2601.18842", "abs": "https://arxiv.org/abs/2601.18842", "authors": ["Yanxi Wang", "Zhiling Zhang", "Wenbo Zhou", "Weiming Zhang", "Jie Zhang", "Qiannan Zhu", "Yu Shi", "Shuxin Zheng", "Jiyan He"], "title": "GUIGuard: Toward a General Framework for Privacy-Preserving GUI Agents", "comment": null, "summary": "GUI agents enable end-to-end automation through direct perception of and interaction with on-screen interfaces. However, these agents frequently access interfaces containing sensitive personal information, and screenshots are often transmitted to remote models, creating substantial privacy risks. These risks are particularly severe in GUI workflows: GUIs expose richer, more accessible private information, and privacy risks depend on interaction trajectories across sequential scenes. We propose GUIGuard, a three-stage framework for privacy-preserving GUI agents: (1) privacy recognition, (2) privacy protection, and (3) task execution under protection. We further construct GUIGuard-Bench, a cross-platform benchmark with 630 trajectories and 13,830 screenshots, annotated with region-level privacy grounding and fine-grained labels of risk level, privacy category, and task necessity. Evaluations reveal that existing agents exhibit limited privacy recognition, with state-of-the-art models achieving only 13.3% accuracy on Android and 1.4% on PC. Under privacy protection, task-planning semantics can still be maintained, with closed-source models showing stronger semantic consistency than open-source ones. Case studies on MobileWorld show that carefully designed protection strategies achieve higher task accuracy while preserving privacy. Our results highlight privacy recognition as a critical bottleneck for practical GUI agents. Project: https://futuresis.github.io/GUIGuard-page/", "code_url": "https://futuresis.github.io/GUIGuard-page", "AI": {"tldr": "GUIGuard is a privacy-preserving framework for GUI agents that addresses the risk of exposing sensitive personal data through screen interactions, using a three-stage approach and a new benchmark to evaluate privacy risks and protection efficacy.", "motivation": "GUI agents often transmit screenshots containing rich personal information to remote models, posing significant privacy risks that are exacerbated by sequential interaction trajectories across diverse interfaces.", "method": "Proposes GUIGuard, a three-stage privacy-preserving framework (privacy recognition, protection, and task execution), and introduces GUIGuard-Bench, a benchmark with 630 trajectories and 13,830 screenshots annotated with fine-grained privacy and risk labels.", "result": "Existing agents show poor privacy recognition (13.3% accuracy on Android, 1.4% on PC); GUIGuard enables effective protection while preserving task semantics, with closed-source models demonstrating better semantic consistency; case studies confirm improved task accuracy with privacy preserved.", "conclusion": "Privacy recognition is a critical bottleneck for practical GUI agents, and GUIGuard provides an effective framework to address privacy risks while maintaining task performance."}}
{"id": "2601.19065", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2601.19065", "abs": "https://arxiv.org/abs/2601.19065", "authors": ["Antonios Saravanos", "John Pazarzis", "Stavros Zervoudakis", "Dongnanzi Zheng"], "title": "The Opaque Pointer Design Pattern in Python: Towards a Pythonic PIMPL for Modularity, Encapsulation, and Stability", "comment": null, "summary": "Python libraries often need to maintain a stable public API even as internal implementations evolve, gain new backends, or depend on heavy optional libraries. In Python, where internal objects are easy to inspect and import, users can come to rely on \"reachable internals\" that were never intended to be public, making refactoring risky and slowing long-term maintenance. This paper revisits the pointer-to-implementation (PIMPL) idiom from C++ and reinterprets it as a Pythonic pattern of opaque delegation: a small public object (or module) that delegates its behavior to a separate implementation object treated as internal. We situate this pattern within a broader taxonomy of encapsulation techniques in Python, relate it to existing practices such as module-level indirection, facade objects, and backend dispatch, and identify PIMPL-like structures already used in the standard library and the scientific Python ecosystem. We then show how a Pythonic PIMPL can be used in existing codebases to isolate heavy dependencies, support lazy imports, and enable runtime selection of alternative backends without changing the public API. Finally, we discuss the benefits and trade-offs of the approach and offer practical guidance on when the pattern is appropriate and how to apply it in large, long-lived Python libraries.", "AI": {"tldr": "This paper introduces a Pythonic interpretation of the C++ PIMPL (Pointer to Implementation) idiom as a design pattern for encapsulation in Python libraries, enabling API stability, lazy loading, and backend flexibility through opaque delegation.", "motivation": "Python's open object model allows users to access internal objects, leading to accidental reliance on non-public APIs. This hampers refactoring and maintenance. The need for stable public APIs amid evolving implementations and optional heavy dependencies motivates the adoption of better encapsulation strategies.", "method": "The authors reinterpret the PIMPL idiom in a Python context using opaque delegation, where a public interface object delegates to a hidden implementation. They classify this within a broader taxonomy of Python encapsulation techniques and analyze existing uses in the standard library and scientific Python ecosystem (e.g., NumPy, SciPy). Case studies illustrate application in real codebases for lazy imports, backend dispatch, and dependency isolation.", "result": "The paper demonstrates that the Pythonic PIMPL pattern effectively decouples public interfaces from internal implementations, enabling runtime backend switching, reducing import-time costs via lazy loading, and facilitating internal refactoring without breaking user code. Examples show its use in managing optional dependencies and maintaining backward compatibility.", "conclusion": "The PIMPL-based opaque delegation pattern is a practical and effective encapsulation strategy for large, long-lived Python libraries. It provides strong API stability and implementation flexibility, with manageable overhead. The paper concludes with guidelines on when and how to apply the pattern appropriately."}}
{"id": "2601.19051", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2601.19051", "abs": "https://arxiv.org/abs/2601.19051", "authors": ["Henry Chen", "Victor Aranda", "Samarth Keshari", "Ryan Heartfield", "Nicole Nichols"], "title": "Proactive Hardening of LLM Defenses with HASTE", "comment": "Accepted at peer review NDSS 2026, Last-X workshop. Camera ready copy forthcoming", "summary": "Prompt-based attack techniques are one of the primary challenges in securely deploying and protecting LLM-based AI systems. LLM inputs are an unbounded, unstructured space. Consequently, effectively defending against these attacks requires proactive hardening strategies capable of continuously generating adaptive attack vectors to optimize LLM defense at runtime. We present HASTE (Hard-negative Attack Sample Training Engine): a systematic framework that iteratively engineers highly evasive prompts, within a modular optimization process, to continuously enhance detection efficacy for prompt-based attack techniques. The framework is agnostic to synthetic data generation methods, and can be generalized to evaluate prompt-injection detection efficacy, with and without fuzzing, for any hard-negative or hard-positive iteration strategy. Experimental evaluation of HASTE shows that hard negative mining successfully evades baseline detectors, reducing malicious prompt detection for baseline detectors by approximately 64%. However, when integrated with detection model re-training, it optimizes the efficacy of prompt detection models with significantly fewer iteration loops compared to relative baseline strategies. The HASTE framework supports both proactive and reactive hardening of LLM defenses and guardrails. Proactively, developers can leverage HASTE to dynamically stress-test prompt injection detection systems; efficiently identifying weaknesses and strengthening defensive posture. Reactively, HASTE can mimic newly observed attack types and rapidly bridge detection coverage by teaching HASTE-optimized detection models to identify them.", "AI": {"tldr": "HASTE is a systematic, modular framework for generating highly evasive prompt attacks to strengthen LLM defenses through iterative hard-negative mining, improving detection efficacy with fewer training cycles and supporting both proactive stress-testing and reactive adaptation to new attack types.", "motivation": "The unbounded and unstructured nature of LLM inputs makes prompt-based attacks a critical security threat, necessitating proactive defense mechanisms that can continuously adapt and improve detection robustness.", "method": "HASTE employs a modular optimization process to iteratively generate evasive prompts via hard-negative mining, supporting generalization across synthetic data generation methods and detection evaluation with or without fuzzing.", "result": "HASTE-generated prompts reduce detection rates for baseline detectors by ~64%, demonstrating high evasion capability. When used for re-training, HASTE improves detection model efficacy with fewer iterations compared to baseline strategies.", "conclusion": "The HASTE framework provides an effective, iterative approach for enhancing prompt-injection detection in LLMs through hard-negative mining and adaptive training, enabling both proactive and reactive defense hardening."}}
{"id": "2601.19066", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.19066", "abs": "https://arxiv.org/abs/2601.19066", "authors": ["Runxiang Cheng", "Michele Tufano", "Jos\u00e9 Cambronero", "Renyao Wei", "Sherry Shi", "Grant Uy", "Pat Rondon", "Franjo Ivan\u010di\u0107"], "title": "Dynamic Cogeneration of Bug Reproduction Test in Agentic Program Repair", "comment": null, "summary": "Bug Reproduction Tests (BRTs) have been used in many agentic Automated Program Repair (APR) systems, primarily for validating promising fixes and aiding fix generation. In practice, when developers submit a patch, they often implement the BRT alongside the fix. Our experience deploying agentic APR reveals that developers similarly desire a BRT within AI-generated patches to increase their confidence. However, canonical APR systems tend to generate BRTs and fixes separately, or focus on producing only the fix in the final patch. In this paper, we study agentic APR in the context of cogeneration, where the APR agent is instructed to generate both a fix and a BRT in the same patch. We evaluate the effectiveness of different cogeneration strategies on 120 human-reported bugs at Google and characterize different cogeneration strategies by their influence on APR agent behavior. We develop and evaluate patch selectors that account for test change information to select patches with plausible fixes (and plausible BRTs). Finally, we analyze the root causes of failed cogeneration trajectories. Importantly, we show that cogeneration allows the APR agent to generate BRTs for at least as many bugs as a dedicated BRT agent, without compromising the generation rate of plausible fixes, thereby reducing engineering effort in maintaining and coordinating separate generation pipelines for fix and BRT at scale.", "AI": {"tldr": "This paper introduces cogeneration in agentic automated program repair, where fixes and bug reproduction tests are generated together, improving developer trust and system efficiency without sacrificing fix quality or test coverage.", "motivation": "Developers expect BRTs alongside fixes to validate correctness and increase confidence in patches. Current APR systems generate fixes and BRTs separately, leading to inefficiencies in practice. The motivation is to improve developer trust and streamline the repair process by jointly generating both components.", "method": "The study evaluates different cogeneration strategies in an agentic APR system, where both the fix and BRT are generated together. It involves empirical evaluation on 120 human-reported bugs at Google, development of patch selectors incorporating test change information, and root cause analysis of failed cogeneration attempts.", "result": "Cogenaration enables the APR agent to generate BRTs for at least as many bugs as a dedicated BRT agent, without reducing the rate of plausible fix generation. Patch selectors leveraging test change information improve selection of valid patches, and analysis of failure modes reveals key challenges in cogeneration trajectories.", "conclusion": "Cogenaration of fixes and Bug Reproduction Tests (BRTs) in automated program repair (APR) reduces engineering overhead by eliminating the need for separate pipelines, while maintaining or improving BRT and fix generation rates."}}
{"id": "2601.19061", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.19061", "abs": "https://arxiv.org/abs/2601.19061", "authors": ["Harsh Chaudhari", "Ethan Rathbum", "Hanna Foerster", "Jamie Hayes", "Matthew Jagielski", "Milad Nasr", "Ilia Shumailov", "Alina Oprea"], "title": "Thought-Transfer: Indirect Targeted Poisoning Attacks on Chain-of-Thought Reasoning Models", "comment": null, "summary": "Chain-of-Thought (CoT) reasoning has emerged as a powerful technique for enhancing large language models' capabilities by generating intermediate reasoning steps for complex tasks. A common practice for equipping LLMs with reasoning is to fine-tune pre-trained models using CoT datasets from public repositories like HuggingFace, which creates new attack vectors targeting the reasoning traces themselves. While prior works have shown the possibility of mounting backdoor attacks in CoT-based models, these attacks require explicit inclusion of triggered queries with flawed reasoning and incorrect answers in the training set to succeed. Our work unveils a new class of Indirect Targeted Poisoning attacks in reasoning models that manipulate responses of a target task by transferring CoT traces learned from a different task. Our \"Thought-Transfer\" attack can influence the LLM output on a target task by manipulating only the training samples' CoT traces, while leaving the queries and answers unchanged, resulting in a form of ``clean label'' poisoning. Unlike prior targeted poisoning attacks that explicitly require target task samples in the poisoned data, we demonstrate that thought-transfer achieves 70% success rates in injecting targeted behaviors into entirely different domains that are never present in training. Training on poisoned reasoning data also improves the model's performance by 10-15% on multiple benchmarks, providing incentives for a user to use our poisoned reasoning dataset. Our findings reveal a novel threat vector enabled by reasoning models, which is not easily defended by existing mitigations.", "AI": {"tldr": "This paper introduces Thought-Transfer, a clean-label, indirect poisoning attack on Chain-of-Thought models that manipulates reasoning traces in one task to compromise model outputs in another, demonstrating high attack success and performance gains that incentivize use of poisoned datasets.", "motivation": "To investigate new security vulnerabilities in reasoning-capable language models, particularly focusing on how poisoned reasoning traces can be exploited to induce targeted behaviors in downstream tasks without direct access to target-task data or altering answer labels.", "method": "The authors propose an indirect targeted poisoning method called 'Thought-Transfer' that alters Chain-of-Thought reasoning traces in the training data of one task to influence model behavior on a different, unseen target task, without modifying input queries or labels (clean-label poisoning). They evaluate the attack's success rate and its impact on model performance across benchmarks.", "result": "The Thought-Transfer attack achieves a 70% success rate in injecting malicious behaviors into target tasks from completely different domains not present in training. Additionally, models trained on poisoned data show a 10\u201315% performance improvement on multiple benchmarks, increasing the likelihood of adoption.", "conclusion": "The study reveals a novel threat vector in Chain-of-Thought reasoning models through 'Thought-Transfer' attacks, which enable indirect targeted poisoning by transferring manipulated reasoning traces across domains, evading detection and existing defenses."}}
{"id": "2601.19072", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.19072", "abs": "https://arxiv.org/abs/2601.19072", "authors": ["Kla Tantithamthavorn", "Hong Yi Lin", "Patanamon Thongtanunam", "Wachiraphan Charoenwet", "Minwoo Jeong", "Ming Wu"], "title": "HalluJudge: A Reference-Free Hallucination Detection for Context Misalignment in Code Review Automation", "comment": "Under Review", "summary": "Large Language models (LLMs) have shown strong capabilities in code review automation, such as review comment generation, yet they suffer from hallucinations -- where the generated review comments are ungrounded in the actual code -- poses a significant challenge to the adoption of LLMs in code review workflows. To address this, we explore effective and scalable methods for a hallucination detection in LLM-generated code review comments without the reference. In this work, we design HalluJudge that aims to assess the grounding of generated review comments based on the context alignment. HalluJudge includes four key strategies ranging from direct assessment to structured multi-branch reasoning (e.g., Tree-of-Thoughts). We conduct a comprehensive evaluation of these assessment strategies across Atlassian's enterprise-scale software projects to examine the effectiveness and cost-efficiency of HalluJudge. Furthermore, we analyze the alignment between HalluJudge's judgment and developer preference of the actual LLM-generated code review comments in the real-world production. Our results show that the hallucination assessment in HalluJudge is cost-effective with an F1 score of 0.85 and an average cost of $0.009. On average, 67% of the HalluJudge assessments are aligned with the developer preference of the actual LLM-generated review comments in the online production. Our results suggest that HalluJudge can serve as a practical safeguard to reduce developers' exposure to hallucinated comments, fostering trust in AI-assisted code reviews.", "AI": {"tldr": "This paper proposes HalluJudge, a cost-effective method for detecting hallucinations in LLM-generated code review comments via context alignment, evaluated on enterprise-scale projects with high accuracy and strong alignment with developer preferences.", "motivation": "LLMs exhibit hallucinations in code review comment generation, producing ungrounded or incorrect feedback, which undermines trust and adoption in real-world development workflows; detecting such hallucinations without reference is crucial for practical deployment.", "method": "HalluJudge uses four assessment strategies, including direct evaluation and structured multi-branch reasoning (e.g., Tree-of-Thoughts), to detect hallucinations in LLM-generated code review comments by evaluating context alignment without requiring reference ground truth.", "result": "HalluJudge achieves an F1 score of 0.85 with an average cost of $0.009 per assessment; 67% of its judgments align with developer preferences in real-world production settings.", "conclusion": "HalluJudge can serve as a practical safeguard to reduce developers' exposure to hallucinated comments, fostering trust in AI-assisted code reviews."}}
{"id": "2601.19074", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2601.19074", "abs": "https://arxiv.org/abs/2601.19074", "authors": ["Dariy Guzairov", "Alex Potanin", "Stephen Kell", "Alwen Tiu"], "title": "A Security Analysis of CheriBSD and Morello Linux", "comment": null, "summary": "Memory corruption attacks have been prevalent in software for a long time. Some mitigation strategies against these attacks do exist, but they are not as far-reaching or as efficient as the CHERI architecture. CHERI uses capabilities to restrict pointers to certain regions of memory and with certain access restrictions. These capabilities are also used to implement \"compartmentalisation\": dividing a binary into smaller components with limited privilege, while adhering to the principle of least privilege. However, while this architecture successfully mitigates memory corruption attacks, the compartmentalisation mechanisms in place are less effective in containing malicious code to a separate compartment. This paper details four ways to bypass compartmentalisation, with a focus on Linux and BSD operating systems ported to this architecture. We find that although compartmentalisation is implemented in these two operating systems, simple bugs and attacks can still allow malicious code to bypass it. We conclude with mitigation measures to prevent these attacks, a proof-of-concept demonstrating their use, and recommendations for further securing Linux and BSD against unknown attacks.", "AI": {"tldr": "This paper exposes four practical compartmentalization bypasses in CHERI-based Linux and BSD systems, demonstrating that memory safety alone is insufficient for strong isolation, and proposes effective mitigations with proof-of-concept validation.", "motivation": "Despite CHERI's strong memory protection, its compartmentalization mechanisms are not fully effective in isolating malicious code; the paper aims to expose these weaknesses and improve real-world system security.", "method": "The authors analyze CHERI's compartmentalization mechanisms in Linux and BSD, identify four practical bypass techniques, implement a proof-of-concept exploit, and propose corresponding mitigation strategies.", "result": "Four distinct bypass methods are identified and demonstrated on CHERI-enabled Linux and BSD systems, showing that attackers can escape compartments through simple bugs; effective mitigations are designed, implemented, and validated with a proof-of-concept.", "conclusion": "The paper concludes that while CHERI-based compartmentalization improves security, current implementations in Linux and BSD are vulnerable to bypass due to bugs and design flaws; effective mitigations are proposed and demonstrated via a proof-of-concept, along with recommendations for strengthening future defenses."}}
{"id": "2601.19088", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19088", "abs": "https://arxiv.org/abs/2601.19088", "authors": ["Saba Alimadadi", "Golnaz Gharachorlu"], "title": "Hybrid Fault-Driven Mutation Testing for Python", "comment": null, "summary": "Mutation testing is an effective technique for assessing the effectiveness of test suites by systematically injecting artificial faults into programs. However, existing mutation testing techniques fall short in capturing many types of common faults in dynamically typed languages like Python. In this paper, we introduce a novel set of seven mutation operators that are inspired by prevalent anti-patterns in Python programs, designed to complement the existing general-purpose operators and broaden the spectrum of simulated faults. We propose a mutation testing technique that utilizes a hybrid of static and dynamic analyses to mutate Python programs based on these operators while minimizing equivalent mutants. We implement our approach in a tool called PyTation and evaluate it on 13 open-source Python applications. Our results show that PyTation generates mutants that complement those from general-purpose tools, exhibiting distinct behaviour under test execution and uncovering inadequacies in high-coverage test suites. We further demonstrate that PyTation produces a high proportion of unique mutants, a low cross-kill rate, and a low test overlap ratio relative to baseline tools, highlighting its novel fault model. PyTation also incurs few equivalent mutants, aided by dynamic analysis heuristics.", "AI": {"tldr": "This paper introduces PyTation, a mutation testing tool for Python that uses seven novel mutation operators based on common anti-patterns, combining static and dynamic analysis to reduce equivalent mutants and improve fault detection in dynamically typed code.", "motivation": "Existing mutation testing techniques are ineffective at capturing common faults in dynamically typed languages like Python; thus, there is a need for more targeted operators that reflect real-world programming anti-patterns.", "method": "The authors design seven Python-specific mutation operators inspired by common anti-patterns, implement a hybrid static and dynamic analysis approach in PyTation to apply these operators, and minimize equivalent mutants using dynamic heuristics.", "result": "Evaluated on 13 open-source Python projects, PyTation generates distinct and unique mutants not produced by general-purpose tools, shows low cross-kill rates and test overlap, reveals weaknesses in high-coverage test suites, and produces few equivalent mutants.", "conclusion": "PyTation enhances mutation testing for Python by introducing a more realistic fault model through language-specific operators and analysis techniques, significantly improving fault simulation and test suite evaluation."}}
{"id": "2601.19134", "categories": ["cs.CR", "cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19134", "abs": "https://arxiv.org/abs/2601.19134", "authors": ["Satyapriya Krishna", "Matteo Memelli", "Tong Wang", "Abhinav Mohanty", "Claire O'Brien Rajkumar", "Payal Motwani", "Rahul Gupta", "Spyros Matsoukas"], "title": "Evaluating Nova 2.0 Lite model under Amazon's Frontier Model Safety Framework", "comment": "Arxiv preprint", "summary": "Amazon published its Frontier Model Safety Framework (FMSF) as part of the Paris AI summit, following which we presented a report on Amazon's Premier model. In this report, we present an evaluation of Nova 2.0 Lite. Nova 2.0 Lite was made generally available from amongst the Nova 2.0 series and is one of its most capable reasoning models. The model processes text, images, and video with a context length of up to 1M tokens, enabling analysis of large codebases, documents, and videos in a single prompt. We present a comprehensive evaluation of Nova 2.0 Lite's critical risk profile under the FMSF. Evaluations target three high-risk domains-Chemical, Biological, Radiological and Nuclear (CBRN), Offensive Cyber Operations, and Automated AI R&D-and combine automated benchmarks, expert red-teaming, and uplift studies to determine whether the model exceeds release thresholds. We summarize our methodology and report core findings. We will continue to enhance our safety evaluation and mitigation pipelines as new risks and capabilities associated with frontier models are identified.", "AI": {"tldr": "This report evaluates Amazon's Nova 2.0 Lite, a frontier multimodal AI model with 1M context length, under the Frontier Model Safety Framework, focusing on high-risk domains including CBRN, cyber operations, and AI self-replication, using automated tests, expert red-teaming, and uplift analysis to ensure safe deployment.", "motivation": "To assess the safety and risk profile of Amazon's Nova 2.0 Lite, a high-capability multimodal reasoning model with 1M token context length, in alignment with the newly released FMSF and ahead of broader deployment.", "method": "The evaluation combines automated benchmarks, expert red-teaming, and uplift studies targeting three high-risk domains: CBRN, Offensive Cyber Operations, and Automated AI R&D, assessing whether Nova 2.0 Lite exceeds acceptable release thresholds.", "result": "A comprehensive risk assessment of Nova 2.0 Lite was conducted across CBRN, cyber, and AI R&D domains, yielding core findings on its safety limitations and performance under stress scenarios, which contribute to refining future safety pipelines.", "conclusion": "The evaluation of Amazon's Nova 2.0 Lite under the Frontier Model Safety Framework (FMSF) demonstrates its safety performance across high-risk domains, with findings informing ongoing improvements in safety evaluation and mitigation strategies for frontier models."}}
{"id": "2601.19100", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19100", "abs": "https://arxiv.org/abs/2601.19100", "authors": ["Md Rayhanul Masud", "Azmine Toushik Wasi", "Salman Rahman", "Md Rizwan Parvez"], "title": "Reward Engineering for Reinforcement Learning in Software Tasks", "comment": null, "summary": "Reinforcement learning is increasingly used for code-centric tasks. These tasks include code generation, summarization, understanding, repair, testing, and optimization. This trend is growing faster with large language models and autonomous agents. A key challenge is how to design reward signals that make sense for software. In many RL problems, the reward is a clear number. In software, this is often not possible. The goal is rarely a single numeric objective. Instead, rewards are usually proxies. Common proxies check if the code compiles, passes tests, or satisfies quality metrics. Many reward designs have been proposed for code-related tasks. However, the work is scattered across areas and papers. There is no single survey that brings these approaches together and shows the full landscape of reward design for RL in software. In this survey, we provide the first systematic and comprehensive review of reward engineering for RL in software tasks. We focus on existing methods and techniques. We structure the literature along three complementary dimensions, summarizing the reward-design choices within each. We conclude with challenges and recommendations in the reward design space for SE tasks.", "AI": {"tldr": "This paper presents the first comprehensive survey on reward engineering for reinforcement learning (RL) in software engineering tasks, systematically organizing existing approaches along three dimensions and identifying key challenges and recommendations.", "motivation": "The increasing application of RL to code-centric tasks lacks a unified understanding of reward design, which is crucial due to the non-numeric and multifaceted nature of software objectives; existing methods are scattered across literature without a cohesive overview.", "method": "The authors conduct a systematic literature review, structuring reward engineering methods along three complementary dimensions: (1) reward sources (e.g., execution, testing, metrics), (2) reward shaping techniques, and (3) feedback modalities (e.g., human, automated).", "result": "The survey consolidates and categorizes a diverse body of work on reward design in software-related RL, providing a structured taxonomy and highlighting common practices, limitations, and gaps in current approaches.", "conclusion": "Reward engineering for RL in software tasks is highly context-dependent and relies on proxies; the paper calls for more principled, standardized, and semantically meaningful reward designs and identifies open challenges in scalability, generalization, and alignment with software quality goals."}}
{"id": "2601.19138", "categories": ["cs.CR", "cs.AI", "cs.LG", "cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19138", "abs": "https://arxiv.org/abs/2601.19138", "authors": ["Wachiraphan Charoenwet", "Kla Tantithamthavorn", "Patanamon Thongtanunam", "Hong Yi Lin", "Minwoo Jeong", "Ming Wu"], "title": "AgenticSCR: An Autonomous Agentic Secure Code Review for Immature Vulnerabilities Detection", "comment": "Under Review", "summary": "Secure code review is critical at the pre-commit stage, where vulnerabilities must be caught early under tight latency and limited-context constraints. Existing SAST-based checks are noisy and often miss immature, context-dependent vulnerabilities, while standalone Large Language Models (LLMs) are constrained by context windows and lack explicit tool use. Agentic AI, which combine LLMs with autonomous decision-making, tool invocation, and code navigation, offer a promising alternative, but their effectiveness for pre-commit secure code review is not yet well understood. In this work, we introduce AgenticSCR, an agentic AI for secure code review for detecting immature vulnerabilities during the pre-commit stage, augmented by security-focused semantic memories. Using our own curated benchmark of immature vulnerabilities, tailored to the pre-commit secure code review, we empirically evaluate how accurate is our AgenticSCR for localizing, detecting, and explaining immature vulnerabilities. Our results show that AgenticSCR achieves at least 153% relatively higher percentage of correct code review comments than the static LLM-based baseline, and also substantially surpasses SAST tools. Moreover, AgenticSCR generates more correct comments in four out of five vulnerability types, consistently and significantly outperforming all other baselines. These findings highlight the importance of Agentic Secure Code Review, paving the way towards an emerging research area of immature vulnerability detection.", "AI": {"tldr": "AgenticSCR is an agentic AI system for pre-commit secure code review that uses LLMs with tool use and semantic memory to detect immature vulnerabilities. Evaluated on a custom benchmark, it outperforms both SAST tools and static LLMs by a large margin.", "motivation": "Existing SAST tools are noisy and miss context-dependent vulnerabilities, while standard LLMs are limited by context length and lack tool use. Immature vulnerabilities\u2014those not yet well-documented or patterned\u2014are especially hard to detect at the pre-commit stage, necessitating a more intelligent, adaptive approach.", "method": "The authors propose AgenticSCR, an agentic AI system for secure code review that leverages LLMs with tool invocation, code navigation, and security-focused semantic memories. They evaluate it on a curated benchmark of immature vulnerabilities specifically designed for the pre-commit stage, measuring performance in localization, detection, and explanation of vulnerabilities.", "result": "AgenticSCR achieves at least a 153% relative improvement in correct code review comments compared to static LLM baselines and significantly outperforms SAST tools. It generates more correct comments in four out of five vulnerability types, demonstrating consistent superiority across evaluation metrics.", "conclusion": "AgenticSCR demonstrates the potential of agentic AI in pre-commit secure code review, highlighting the importance of autonomous decision-making, tool use, and semantic memory in detecting immature vulnerabilities, thus advancing research in this domain."}}
{"id": "2601.19106", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.19106", "abs": "https://arxiv.org/abs/2601.19106", "authors": ["Dipin Khati", "Daniel Rodriguez-Cardenas", "Paul Pantzer", "Denys Poshyvanyk"], "title": "Detecting and Correcting Hallucinations in LLM-Generated Code via Deterministic AST Analysis", "comment": "Accepted to FORGE 2026", "summary": "Large Language Models (LLMs) for code generation boost productivity but frequently introduce Knowledge Conflicting Hallucinations (KCHs), subtle, semantic errors, such as non-existent API parameters, that evade linters and cause runtime failures. Existing mitigations like constrained decoding or non-deterministic LLM-in-the-loop repair are often unreliable for these errors. This paper investigates whether a deterministic, static-analysis framework can reliably detect \\textit{and} auto-correct KCHs. We propose a post-processing framework that parses generated code into an Abstract Syntax Tree (AST) and validates it against a dynamically-generated Knowledge Base (KB) built via library introspection. This non-executing approach uses deterministic rules to find and fix both API and identifier-level conflicts. On a manually-curated dataset of 200 Python snippets, our framework detected KCHs with 100\\% precision and 87.6\\% recall (0.934 F1-score), and successfully auto-corrected 77.0\\% of all identified hallucinations. Our findings demonstrate that this deterministic post-processing approach is a viable and reliable alternative to probabilistic repair, offering a clear path toward trustworthy code generation.", "AI": {"tldr": "This paper presents a deterministic, static-analysis framework that detects and corrects Knowledge Conflicting Hallucinations in LLM-generated code using AST parsing and a library-introspection-based Knowledge Base, achieving high precision and effective auto-correction without code execution.", "motivation": "Knowledge Conflicting Hallucinations (KCHs) in LLM-generated code\u2014such as non-existent API parameters\u2014are subtle, semantically incorrect errors that evade linters and lead to runtime failures. Existing approaches like constrained decoding or LLM-in-the-loop repair are unreliable, motivating the need for a deterministic and static solution.", "method": "The paper proposes a post-processing framework that parses generated code into an Abstract Syntax Tree (AST) and validates it against a dynamically constructed Knowledge Base (KB) derived from library introspection. Deterministic rules are applied to detect and correct API- and identifier-level KCHs without executing the code.", "result": "Evaluated on a manually curated dataset of 200 Python snippets, the framework achieved 100% precision, 87.6% recall (F1-score: 0.934) in detecting KCHs, and successfully auto-corrected 77.0% of the identified hallucinations.", "conclusion": "The proposed deterministic, static-analysis-based post-processing framework is a reliable and effective alternative to probabilistic methods for detecting and correcting Knowledge Conflicting Hallucinations (KCHs) in code generated by Large Language Models, enhancing the trustworthiness of AI-generated code."}}
{"id": "2601.19174", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.19174", "abs": "https://arxiv.org/abs/2601.19174", "authors": ["Nirhoshan Sivaroopan", "Kanchana Thilakarathna", "Albert Zomaya", "Manu", "Yi Guo", "Jo Plested", "Tim Lynar", "Jack Yang", "Wangli Yang"], "title": "SHIELD: An Auto-Healing Agentic Defense Framework for LLM Resource Exhaustion Attacks", "comment": null, "summary": "Sponge attacks increasingly threaten LLM systems by inducing excessive computation and DoS. Existing defenses either rely on statistical filters that fail on semantically meaningful attacks or use static LLM-based detectors that struggle to adapt as attack strategies evolve. We introduce SHIELD, a multi-agent, auto-healing defense framework centered on a three-stage Defense Agent that integrates semantic similarity retrieval, pattern matching, and LLM-based reasoning. Two auxiliary agents, a Knowledge Updating Agent and a Prompt Optimization Agent, form a closed self-healing loop, when an attack bypasses detection, the system updates an evolving knowledgebase, and refines defense instructions. Extensive experiments show that SHIELD consistently outperforms perplexity-based and standalone LLM defenses, achieving high F1 scores across both non-semantic and semantic sponge attacks, demonstrating the effectiveness of agentic self-healing against evolving resource-exhaustion threats.", "AI": {"tldr": "SHIELD is a multi-agent, self-healing defense system that effectively mitigates sponge attacks on LLMs through adaptive detection and continuous learning, outperforming static and statistical defense methods.", "motivation": "Sponge attacks pose a growing threat to LLM systems by causing excessive computation and potential denial-of-service; existing defenses are either ineffective against semantic attacks or lack adaptability to evolving attack strategies.", "method": "The proposed SHIELD framework employs a three-stage Defense Agent using semantic similarity retrieval, pattern matching, and LLM-based reasoning, supported by a Knowledge Updating Agent and a Prompt Optimization Agent that form a closed self-healing loop to dynamically adapt to new attack patterns.", "result": "SHIELD outperforms perplexity-based and standalone LLM-based defenses in experiments, achieving high F1 scores on both non-semantic and semantic sponge attacks, validating its robustness and adaptability.", "conclusion": "SHIELD demonstrates that a multi-agent, self-healing framework significantly enhances defense against evolving sponge attacks by enabling adaptive detection and continuous improvement through a closed-loop system."}}
{"id": "2601.19146", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19146", "abs": "https://arxiv.org/abs/2601.19146", "authors": ["Taher A. Ghaleb", "Daniel Alencar da Costa", "Ying Zou"], "title": "The Promise and Reality of Continuous Integration Caching: An Empirical Study of Travis CI Builds", "comment": null, "summary": "Continuous Integration (CI) provides early feedback by automatically building software, but long build durations can hinder developer productivity. CI services offer caching mechanisms to speed up builds by reusing infrequently changing artifacts, yet little is known about how caching is adopted in practice and what challenges it entails. In this paper, we conduct a large-scale empirical study of CI caching in Travis CI, analyzing 513,384 builds from 1,279 GitHub projects. We find that only 30% of projects adopt CI caching, and early adoption is strongly associated with project maturity, such as more dependencies, more commits, and longer CI lifespans. To understand why many projects do not adopt caching, we submitted pull requests enabling caching in non-adopting projects, and nearly half were accepted or merged. Developer feedback suggests that non- or late adoption mainly stems from limited awareness of CI caching support. We also examine cache maintenance and identify five common activities, performed by 24% of cache-enabled projects. Although one-third of projects see substantial build-time reductions, cache uploads occur in 97% of builds, and 33% of projects contain stale cached artifacts. Finally, our analysis of reported caching issues shows developers mainly struggle with corrupted or outdated caches or request broader caching features. Overall, CI caching does not help all projects, needs ongoing maintenance, and is more complex in practice than many developers expect.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.19231", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2601.19231", "abs": "https://arxiv.org/abs/2601.19231", "authors": ["Yangyang Guo", "Ziwei Xu", "Si Liu", "Zhiming Zheng", "Mohan Kankanhalli"], "title": "LLMs Can Unlearn Refusal with Only 1,000 Benign Samples", "comment": null, "summary": "This study reveals a previously unexplored vulnerability in the safety alignment of Large Language Models (LLMs). Existing aligned LLMs predominantly respond to unsafe queries with refusals, which often begin with a fixed set of prefixes (I'm sorry). We demonstrate that this rigid refusal pattern is a vulnerability and introduce a novel \\textbf{refusal unlearning} technique that exploits it. Specifically, we fine-tune LLMs using merely 1,000 benign samples, where each response is prepended with a refusal prefix. The underlying intuition is to disrupt the refusal completion pathway, thereby driving the model to forget how to refuse while following harmful instructions. This intuition is further supported by theoretical proofs. We apply this approach to a total of 16 LLMs, including various open-source models from Llama, Qwen, and Gemma families, as well as closed-source models such as Gemini and GPT. Experimental results show that the safety scores of previously aligned LLMs degrade both consistently and substantially. Importantly, we verify that the observed gain cannot be attributed to plain fine-tuning or random prefix effects. Our findings suggest that current safety alignment may rely heavily on token sequence memorization rather than reasoning, motivating future work beyond simple refusal mechanisms. Code has been released: https://github.com/guoyang9/refusal-unlearning.", "code_url": "https://github.com/guoyang9/refusal-unlearnin", "AI": {"tldr": "This paper introduces a 'refusal unlearning' technique that exploits the rigid refusal patterns of aligned LLMs by fine-tuning them with benign responses starting with refusal prefixes, causing the models to forget how to refuse unsafe queries, thereby undermining their safety alignment.", "motivation": "To expose a vulnerability in current safety alignment mechanisms of LLMs that rely on fixed refusal patterns, which may not involve genuine reasoning but rather token sequence memorization.", "method": "Fine-tuning 16 LLMs (both open- and closed-source) on 1,000 benign samples where responses are prepended with common refusal prefixes (e.g., 'I'm sorry'), disrupting the model's refusal completion pathway; supported by theoretical analysis.", "result": "Significant and consistent degradation in safety scores across all tested models after refusal unlearning; the effect is shown to be specific to the refusal prefix manipulation, not due to general fine-tuning or random prefixes.", "conclusion": "Current safety alignment in LLMs may heavily depend on superficial token-level memorization rather than robust ethical reasoning, indicating a need for more sophisticated alignment strategies beyond simple refusal templates."}}
{"id": "2601.19345", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2601.19345", "abs": "https://arxiv.org/abs/2601.19345", "authors": ["Abdullah Khanfor", "Raby Hamadi", "Noureddine Lasla", "Hakim Ghazzai"], "title": "AI-driven Intrusion Detection for UAV in Smart Urban Ecosystems: A Comprehensive Survey", "comment": "68 pages, 13 figures, 6 tables, journal", "summary": "UAVs have the potential to revolutionize urban management and provide valuable services to citizens. They can be deployed across diverse applications, including traffic monitoring, disaster response, environmental monitoring, and numerous other domains. However, this integration introduces novel security challenges that must be addressed to ensure safe and trustworthy urban operations. This paper provides a structured, evidence-based synthesis of UAV applications in smart cities and their associated security challenges as reported in the literature over the last decade, with particular emphasis on developments from 2019 to 2025. We categorize these challenges into two primary classes: 1) cyber-attacks targeting the communication infrastructure of UAVs and 2) unwanted or unauthorized physical intrusions by UAVs themselves. We examine the potential of Artificial Intelligence (AI) techniques in developing intrusion detection mechanisms to mitigate these security threats. We analyze how AI-based methods, such as machine/deep learning for anomaly detection and computer vision for object recognition, can play a pivotal role in enhancing UAV security through unified detection systems that address both cyber and physical threats. Furthermore, we consolidate publicly available UAV datasets across network traffic and vision modalities suitable for Intrusion Detection Systems (IDS) development and evaluation. The paper concludes by identifying ten key research directions, including scalability, robustness, explainability, data scarcity, automation, hybrid detection, large language models, multimodal approaches, federated learning, and privacy preservation. Finally, we discuss the practical challenges of implementing UAV IDS solutions in real-world smart city environments.", "AI": {"tldr": "This paper reviews UAV applications in smart cities and their security challenges from 2019 to 2025, categorizing threats into cyber-attacks and physical intrusions, and explores AI-driven intrusion detection systems using machine learning and computer vision, while identifying ten key research directions and discussing implementation challenges.", "motivation": "The increasing integration of UAVs in smart cities introduces critical security risks that threaten urban safety and operational integrity; addressing these risks requires a comprehensive, evidence-based understanding of emerging threats and effective countermeasures.", "method": "The study conducts a structured literature review on UAV applications and security issues, classifies threats into cyber and physical domains, evaluates AI-based detection techniques (e.g., anomaly detection, computer vision), and compiles relevant public datasets for IDS development.", "result": "AI techniques show strong potential in enabling unified intrusion detection systems for both cyber and physical UAV threats; the study consolidates available datasets and identifies ten major research directions to advance UAV security in smart cities.", "conclusion": "AI-enhanced intrusion detection is crucial for securing UAVs in urban environments; future work must address scalability, robustness, explainability, data scarcity, and privacy, while overcoming practical barriers to real-world deployment in smart cities."}}
{"id": "2601.19239", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19239", "abs": "https://arxiv.org/abs/2601.19239", "authors": ["Fengjie Li", "Jiajun Jiang", "Dongchi Chen", "Yingfei Xiong"], "title": "LLM-based Vulnerability Detection at Project Scale: An Empirical Study", "comment": "19 pages, 13 figures, 11 tables", "summary": "In this paper, we present the first comprehensive empirical study of specialized LLM-based detectors and compare them with traditional static analyzers at the project scale. Specifically, our study evaluates five latest and representative LLM-based methods and two traditional tools using: 1) an in-house benchmark of 222 known real-world vulnerabilities (C/C++ and Java) to assess detection capability, and 2) 24 active open-source projects, where we manually inspected 385 warnings to assess their practical usability and underlying root causes of failures. Our evaluation yields three key findings: First, while LLM-based detectors exhibit low recall on the in-house benchmark, they still uncover more unique vulnerabilities than traditional tools. Second, in open-source projects, both LLM-based and traditional tools generate substantial warnings but suffer from very high false discovery rates, hindering practical use. Our manual analysis further reveals shallow interprocedural reasoning and misidentified source/sink pairs as primary failure causes, with LLM-based tools exhibiting additional unique failures. Finally, LLM-based methods incurs substantial computational costs-hundreds of thousands to hundreds of millions of tokens and multi-hour to multi-day runtimes. Overall, our findings underscore critical limitations in the robustness, reliability, and scalability of current LLM-based detectors. We ultimately summarize a set of implications for future research toward more effective and practical project-scale vulnerability detection.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2601.19367", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.19367", "abs": "https://arxiv.org/abs/2601.19367", "authors": ["Bilel Sefsaf", "Abderraouf Dandani", "Abdessamed Seddiki", "Arab Mohammed", "Eduardo Chielle", "Michail Maniatakos", "Riyadh Baghdadi"], "title": "CHEHAB RL: Learning to Optimize Fully Homomorphic Encryption Computations", "comment": null, "summary": "Fully Homomorphic Encryption (FHE) enables computations directly on encrypted data, but its high computational cost remains a significant barrier. Writing efficient FHE code is a complex task requiring cryptographic expertise, and finding the optimal sequence of program transformations is often intractable. In this paper, we propose CHEHAB RL, a novel framework that leverages deep reinforcement learning (RL) to automate FHE code optimization. Instead of relying on predefined heuristics or combinatorial search, our method trains an RL agent to learn an effective policy for applying a sequence of rewriting rules to automatically vectorize scalar FHE code while reducing instruction latency and noise growth. The proposed approach supports the optimization of both structured and unstructured code. To train the agent, we synthesize a diverse dataset of computations using a large language model (LLM). We integrate our proposed approach into the CHEHAB FHE compiler and evaluate it on a suite of benchmarks, comparing its performance against Coyote, a state-of-the-art vectorizing FHE compiler. The results show that our approach generates code that is $5.3\\times$ faster in execution, accumulates $2.54\\times$ less noise, while the compilation process itself is $27.9\\times$ faster than Coyote (geometric means).", "AI": {"tldr": "CHEHAB RL introduces a deep reinforcement learning-based framework for automated optimization of Fully Homomorphic Encryption code, replacing heuristic-driven or search-based methods with a learned policy that efficiently vectorizes scalar FHE programs while significantly reducing execution time and noise growth. Using an LLM-synthesized training dataset, the approach outperforms Coyote by 5.3x in execution speed, 2.54x in noise reduction, and 27.9x in compilation speed.", "motivation": "The high computational cost and complexity of writing efficient FHE code, which requires expert knowledge and faces intractable search spaces for optimal transformations, motivate the need for automated optimization.", "method": "The method uses deep reinforcement learning to train an agent that applies rewriting rules for vectorization and optimization of scalar FHE code, guided by a synthesized dataset from a large language model.", "result": "The approach achieves 5.3x faster execution, 2.54x less noise accumulation, and 27.9x faster compilation compared to Coyote, a state-of-the-art FHE compiler (geometric means).", "conclusion": "CHEHAB RL successfully automates FHE code optimization using deep reinforcement learning, outperforming state-of-the-art methods in execution speed, noise reduction, and compilation efficiency."}}
{"id": "2601.19260", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19260", "abs": "https://arxiv.org/abs/2601.19260", "authors": ["Himon Thakur", "Armin Moin"], "title": "\"ENERGY STAR\" LLM-Enabled Software Engineering Tools", "comment": "CAIN 2026 - 5th International Conference on AI Engineering - Software Engineering for AI", "summary": "The discussion around AI-Engineering, that is, Software Engineering (SE) for AI-enabled Systems, cannot ignore a crucial class of software systems that are increasingly becoming AI-enhanced: Those used to enable or support the SE process, such as Computer-Aided SE (CASE) tools and Integrated Development Environments (IDEs). In this paper, we study the energy efficiency of these systems. As AI becomes seamlessly available in these tools and, in many cases, is active by default, we are entering a new era with significant implications for energy consumption patterns throughout the Software Development Lifecycle (SDLC). We focus on advanced Machine Learning (ML) capabilities provided by Large Language Models (LLMs). Our proposed approach combines Retrieval-Augmented Generation (RAG) with Prompt Engineering Techniques (PETs) to enhance both the quality and energy efficiency of LLM-based code generation. We present a comprehensive framework that measures real-time energy consumption and inference time across diverse model architectures ranging from 125M to 7B parameters, including GPT-2, CodeLlama, Qwen 2.5, and DeepSeek Coder. These LLMs, chosen for practical reasons, are sufficient to validate the core ideas and provide a proof of concept for more in-depth future analysis.", "AI": {"tldr": "This paper investigates the energy efficiency of AI-enhanced software engineering tools, proposing a RAG and prompt engineering-based framework to improve sustainability in LLM-driven code generation across popular models like CodeLlama and Qwen 2.5.", "motivation": "As AI features, especially LLMs, become standard in software engineering tools like IDEs and CASE systems, understanding and optimizing their energy consumption is critical to ensure sustainability across the Software Development Lifecycle (SDLC).", "method": "The study employs a comprehensive framework that integrates Retrieval-Augmented Generation (RAG) and Prompt Engineering Techniques (PETs) to evaluate energy efficiency and inference time across multiple LLM architectures (125M to 7B parameters), including GPT-2, CodeLlama, Qwen 2.5, and DeepSeek Coder, during code generation tasks.", "result": "Real-time energy consumption and inference time were successfully measured across various LLMs, demonstrating that the integration of RAG and PETs can enhance energy efficiency without compromising code generation quality, with practical validation achieved using models ranging from 125M to 7B parameters.", "conclusion": "The proposed framework combining RAG and PETs provides a proof of concept for improving both code generation quality and energy efficiency in LLM-based SE tools, paving the way for sustainable AI-enhanced software development practices."}}
{"id": "2601.19500", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2601.19500", "abs": "https://arxiv.org/abs/2601.19500", "authors": ["Rainer St\u00fctz", "Nicholas Stifter", "Melitta Dragaschnig", "Bernhard Haslhofer", "Aljosha Judmayer"], "title": "Reuse of Public Keys Across UTXO and Account-Based Cryptocurrencies", "comment": "Accepted at Financial Cryptography and Data Security (FC) 2026. 36 pages, 9 figures", "summary": "It is well known that reusing cryptocurrency addresses undermines privacy. This also applies if the same addresses are used in different cryptocurrencies. Nevertheless, cross-chain address reuse appears to be a recurring phenomenon, especially in EVM-based designs. Previous works performed either direct address matching, or basic format conversion, to identify such cases. However, seemingly incompatible address formats e.g., in Bitcoin and Ethereum, can also be derived from the same public keys, since they rely on the same cryptographic primitives. In this paper, we therefore focus on the underlying public keys to discover reuse within, as well as across, different cryptocurrency networks, enabling us to also match incompatible address formats. Specifically, we analyze key reuse across Bitcoin, Ethereum, Litecoin, Dogecoin, Zcash and Tron. Our results reveal that cryptographic keys are extensively and actively reused across these networks, negatively impacting both privacy and security of their users. We are hence the first to expose and quantify cross-chain key reuse between UTXO and account-based cryptocurrencies. Moreover, we devise novel clustering methods across these different cryptocurrency networks that do not rely on heuristics and instead link entities by their knowledge of the underlying secret key.", "AI": {"tldr": "This paper identifies and quantifies cross-cryptocurrency key reuse by analyzing public keys across Bitcoin, Ethereum, Litecoin, Dogecoin, Zcash, and Tron, showing that users frequently reuse keys across incompatible systems, harming privacy and security. The authors propose a new clustering method based on secret key ownership rather than heuristics.", "motivation": "The motivation stems from the privacy risks associated with address reuse in cryptocurrencies, particularly across different blockchain systems. While prior work focused on direct address matching, the authors aim to uncover deeper cross-chain linkages through shared cryptographic keys, even when address formats appear incompatible.", "method": "The method involves analyzing public key reuse across different cryptocurrencies (Bitcoin, Ethereum, Litecoin, Dogecoin, Zcash, and Tron) by tracing addresses to their underlying cryptographic keys, rather than relying on address matching or format conversion. The authors develop clustering techniques that link entities based on shared secret keys.", "result": "The study reveals extensive and ongoing cross-chain cryptographic key reuse among major cryptocurrencies, including between UTXO and account-based models. The authors successfully identify such reuse cases and quantify the privacy and security implications, introducing a more robust clustering approach that operates across chains without relying on traditional heuristics.", "conclusion": "This paper concludes that cryptographic keys are extensively reused across different cryptocurrency networks, including both UTXO and account-based systems, which significantly harms user privacy and security. It introduces a novel, heuristic-free clustering method that links entities across chains based on shared secret key knowledge."}}
{"id": "2601.19264", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.19264", "abs": "https://arxiv.org/abs/2601.19264", "authors": ["Syed Mehedi Hasan Nirob", "Shamim Ehsan", "Moqsadur Rahman", "Summit Haque"], "title": "Whitespaces Don't Lie: Feature-Driven and Embedding-Based Approaches for Detecting Machine-Generated Code", "comment": null, "summary": "Large language models (LLMs) have made it remarkably easy to synthesize plausible source code from natural language prompts. While this accelerates software development and supports learning, it also raises new risks for academic integrity, authorship attribution, and responsible AI use. This paper investigates the problem of distinguishing human-written from machine-generated code by comparing two complementary approaches: feature-based detectors built from lightweight, interpretable stylometric and structural properties of code, and embedding-based detectors leveraging pretrained code encoders. Using a recent large-scale benchmark dataset of 600k human-written and AI-generated code samples, we find that feature-based models achieve strong performance (ROC-AUC 0.995, PR-AUC 0.995, F1 0.971), while embedding-based models with CodeBERT embeddings are also very competitive (ROC-AUC 0.994, PR-AUC 0.994, F1 0.965). Analysis shows that features tied to indentation and whitespace provide particularly discriminative cues, whereas embeddings capture deeper semantic patterns and yield slightly higher precision. These findings underscore the trade-offs between interpretability and generalization, offering practical guidance for deploying robust code-origin detection in academic and industrial contexts.", "AI": {"tldr": "This paper evaluates feature-based and embedding-based methods for detecting AI-generated code, showing both achieve high accuracy, with feature models being more interpretable and embedding models offering better precision.", "motivation": "The increasing ability of large language models to generate plausible code raises concerns about academic integrity, authorship attribution, and responsible AI use. There is a need to reliably distinguish human-written from machine-generated code to address these risks.", "method": "The authors compare two approaches for code origin detection: (1) feature-based detectors using stylometric and structural properties of code, and (2) embedding-based detectors using pretrained code encoders like CodeBERT. Evaluation is conducted on a large-scale dataset of 600k code samples, using metrics such as ROC-AUC, PR-AUC, and F1 score.", "result": "Feature-based models achieve high performance with ROC-AUC of 0.995, PR-AUC of 0.995, and F1 of 0.971. Embedding-based models using CodeBERT achieve slightly lower ROC-AUC (0.994) and PR-AUC (0.994) but show higher precision. Indentation and whitespace features are found to be highly discriminative, while embeddings capture deeper semantic patterns.", "conclusion": "The paper concludes that both feature-based and embedding-based approaches are effective for detecting machine-generated code, with feature-based models offering strong performance and interpretability, while embedding-based models provide competitive results with better precision. The findings highlight trade-offs between interpretability and generalization, providing practical insights for deploying code-origin detection systems."}}
{"id": "2601.19570", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2601.19570", "abs": "https://arxiv.org/abs/2601.19570", "authors": ["Krzysztof Gogol", "Manvir Schneider", "Jan Gorzny", "Claudio Tessone"], "title": "How to Serve Your Sandwich? MEV Attacks in Private L2 Mempools", "comment": null, "summary": "We study the feasibility, profitability, and prevalence of sandwich attacks on Ethereum rollups with private mempools. First, we extend a formal model of optimal front- and back-run sizing, relating attack profitability to victim trade volume, liquidity depth, and slippage bounds. We complement it with an execution-feasibility model that quantifies co-inclusion constraints under private mempools. Second, we examine execution constraints in the absence of builder markets: without guaranteed atomic inclusion, attackers must rely on sequencer ordering, redundant submissions, and priority fee placement, which renders sandwiching probabilistic rather than deterministic. Third, using transaction-level data from major rollups, we show that naive heuristics overstate sandwich activity. We find that the majority of flagged patterns are false positives and that the median net return for these attacks is negative. Our results suggest that sandwiching, while endemic and profitable on Ethereum L1, is rare, unprofitable, and largely absent in rollups with private mempools. These findings challenge prevailing assumptions, refine measurement of MEV in L2s, and inform the design of sequencing policies.", "AI": {"tldr": "Sandwich attacks are rare and unprofitable on Ethereum rollups with private mempools due to execution constraints and false positives in detection, challenging assumptions about MEV prevalence in L2s.", "motivation": "To assess the feasibility, profitability, and actual prevalence of sandwich attacks on Ethereum rollups with private mempools, given assumptions about MEV extraction in Layer 2 systems.", "method": "Extended a formal model for optimal front- and back-running profitability based on trade volume, liquidity, and slippage; developed an execution-feasibility model for co-inclusion under private mempools; analyzed transaction-level data from major rollups to evaluate real-world sandwiching activity.", "result": "Sandwich attacks are probabilistic rather than deterministic due to lack of atomic inclusion; naive heuristics overestimate sandwich activity with many false positives; median net return is negative; such attacks are rare and unprofitable on rollups despite being prevalent on L1.", "conclusion": "Sandwiching is largely ineffective and uncommon in Ethereum rollups with private mempools, implying that MEV dynamics on L2s differ significantly from L1, which has implications for sequencing policy design."}}
{"id": "2601.19287", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19287", "abs": "https://arxiv.org/abs/2601.19287", "authors": ["Md. Asif Haider", "Thomas Zimmermann"], "title": "Understanding Dominant Themes in Reviewing Agentic AI-authored Code", "comment": null, "summary": "While prior work has examined the generation capabilities of Agentic AI systems, little is known about how reviewers respond to AI-authored code in practice. In this paper, we present a large-scale empirical study of code review dynamics in agent-generated PRs. Using a curated subset of the AIDev dataset, we analyze 19,450 inline review comments spanning 3,177 agent-authored PRs from real-world GitHub repositories. We first derive a taxonomy of 12 review comment themes using topic modeling combined with large language model (LLM)-assisted semantic clustering and consolidation. According to this taxonomy, we then investigate whether zero-shot prompts to LLM can reliably annotate review comments. Our evaluation against human annotations shows that open-source LLM achieves reasonably high exact match (78.63%), macro F1 score (0.78), and substantial agreement with human annotators at the review comment level. At the PR level, the LLM also correctly identifies the dominant review theme with 78% Top-1 accuracy and achieves an average Jaccard similarity of 0.76, indicating strong alignment with human judgments. Applying this annotation pipeline at scale, we find that apart from functional correctness and logical changes, reviews of agent-authored PRs predominantly focus on documentation gaps, refactoring needs, styling and formatting issues, with testing and security-related concerns. These findings suggest that while AI agents can accelerate code production, there remain gaps requiring targeted human review oversight.", "AI": {"tldr": "This paper presents a large-scale study of code review feedback on AI-generated pull requests, introducing a 12-theme taxonomy and showing that LLMs can effectively classify review comments with high agreement to humans. Results highlight persistent gaps in agent-authored code requiring human oversight.", "motivation": "To understand how human reviewers respond to AI-authored code in real-world settings, as prior work has focused on AI generation capabilities but not on code review dynamics.", "method": "Large-scale empirical study using a curated subset of the AIDev dataset, analyzing 19,450 inline review comments from 3,177 agent-authored PRs; topic modeling and LLM-assisted semantic clustering to derive a taxonomy; evaluation of zero-shot LLM annotation against human annotations at both comment and PR levels.", "result": "A taxonomy of 12 review comment themes was derived; zero-shot LLMs achieved 78.63% exact match and 0.78 macro F1 score at the comment level; 78% Top-1 accuracy and Jaccard similarity of 0.76 at the PR level; dominant review themes include documentation, refactoring, styling, testing, and security.", "conclusion": "AI agents can accelerate code production, but human review remains essential to address gaps in documentation, refactoring, style, testing, and security in agent-authored code."}}
{"id": "2601.19684", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2601.19684", "abs": "https://arxiv.org/abs/2601.19684", "authors": ["Emunah S-S. Chan", "Aldar C-F. Chan"], "title": "LLM-Assisted Authentication and Fraud Detection", "comment": "20 pages, 7 figures, 2 tables", "summary": "User authentication and fraud detection face growing challenges as digital systems expand and adversaries adopt increasingly sophisticated tactics. Traditional knowledge-based authentication remains rigid, requiring exact word-for-word string matches that fail to accommodate natural human memory and linguistic variation. Meanwhile, fraud-detection pipelines struggle to keep pace with rapidly evolving scam behaviors, leading to high false-positive rates and frequent retraining cycles required. This work introduces two complementary LLM-enabled solutions, namely, an LLM-assisted authentication mechanism that evaluates semantic correctness rather than exact wording, supported by document segmentation and a hybrid scoring method combining LLM judgement with cosine-similarity metrics and a RAG-based fraud-detection pipeline that grounds LLM reasoning in curated evidence to reduce hallucinations and adapt to emerging scam patterns without model retraining. Experiments show that the authentication system accepts 99.5% of legitimate non-exact answers while maintaining a 0,1% false-acceptance rate, and that the RAG-enhanced fraud detection reduces false positives from 17.2% to 35%. Together, these findings demonstrate that LLMs can significantly improve both usability and robustness in security workflows, offering a more adaptive , explainable, and human-aligned approach to authentication and fraud detection.", "AI": {"tldr": "This paper proposes two LLM-based solutions: one for semantic authentication that accepts natural variations in user responses, and another for fraud detection using RAG to improve accuracy and adaptability without retraining; both methods enhance security system usability and robustness.", "motivation": "Traditional knowledge-based authentication is too rigid due to its reliance on exact string matching, which does not account for human memory variability, while existing fraud detection systems suffer from high false-positive rates and require frequent retraining to adapt to new scam patterns.", "method": "The authors introduce (1) an LLM-assisted authentication mechanism that uses semantic evaluation via LLMs combined with document segmentation and a hybrid scoring approach (LLM judgment + cosine similarity), and (2) a RAG-based fraud detection pipeline that grounds LLM reasoning in curated evidence to minimize hallucinations and adapt to novel scams without model retraining.", "result": "The authentication system achieves 99.5% acceptance of legitimate non-exact answers with only a 0.1% false-acceptance rate; the RAG-enhanced fraud detection reduces false positives from 17.2% to 3.5%.", "conclusion": "LLM-enabled approaches can significantly improve the adaptability, explainability, and human alignment of security systems, offering robust and user-friendly alternatives to traditional methods in authentication and fraud detection."}}
{"id": "2601.19316", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19316", "abs": "https://arxiv.org/abs/2601.19316", "authors": ["Romain Lefeuvre", "Ma\u00efwenn Le Goasteller", "Jessie Galasso", "Benoit Combemale", "Quentin Perez", "Houari Sahraoui"], "title": "Modeling Sampling Workflows for Code Repositories", "comment": null, "summary": "Empirical software engineering research often depends on datasets of code repository artifacts, where sampling strategies are employed to enable large-scale analyses. The design and evaluation of these strategies are critical, as they directly influence the generalizability of research findings. However, sampling remains an underestimated aspect in software engineering research: we identify two main challenges related to (1) the design and representativeness of sampling approaches, and (2) the ability to reason about the implications of sampling decisions on generalizability. To address these challenges, we propose a Domain-Specific Language (DSL) to explicitly describe complex sampling strategies through composable sampling operators. This formalism supports both the specification and the reasoning about the generalizability of results based on the applied sampling strategies. We implement the DSL as a Python-based fluent API, and demonstrate how it facilitates representativeness reasoning using statistical indicators extracted from sampling workflows. We validate our approach through a case study of MSR papers involving code repository sampling. Our results show that the DSL can model the sampling strategies reported in recent literature.", "AI": {"tldr": "This paper introduces a DSL for specifying and analyzing sampling strategies in software engineering research to improve transparency and generalizability assessment.", "motivation": "Sampling strategies in empirical software engineering research are often inadequately described and poorly understood, leading to threats to the generalizability of findings. There is a need for better tools to design, document, and reason about sampling decisions.", "method": "A Domain-Specific Language (DSL) with composable sampling operators was designed and implemented as a Python-based fluent API. The approach was validated through a case study on MSR papers involving code repository sampling.", "result": "The DSL successfully modeled sampling strategies from recent MSR papers and enabled reasoning about representativeness using statistical indicators extracted from sampling workflows.", "conclusion": "The proposed DSL effectively enables the explicit description and reasoning about sampling strategies in empirical software engineering research, improving transparency and support for generalizability assessment."}}
{"id": "2601.19726", "categories": ["cs.CR", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2601.19726", "abs": "https://arxiv.org/abs/2601.19726", "authors": ["Lige Huang", "Zicheng Liu", "Jie Zhang", "Lewen Yan", "Dongrui Liu", "Jing Shao"], "title": "RvB: Automating AI System Hardening via Iterative Red-Blue Games", "comment": null, "summary": "The dual offensive and defensive utility of Large Language Models (LLMs) highlights a critical gap in AI security: the lack of unified frameworks for dynamic, iterative adversarial adaptation hardening. To bridge this gap, we propose the Red Team vs. Blue Team (RvB) framework, formulated as a training-free, sequential, imperfect-information game. In this process, the Red Team exposes vulnerabilities, driving the Blue Team to learning effective solutions without parameter updates. We validate our framework across two challenging domains: dynamic code hardening against CVEs and guardrail optimization against jailbreaks. Our empirical results show that this interaction compels the Blue Team to learn fundamental defensive principles, leading to robust remediations that are not merely overfitted to specific exploits. RvB achieves Defense Success Rates of 90\\% and 45\\% across the respective tasks while maintaining near 0\\% False Positive Rates, significantly surpassing baselines. This work establishes the iterative adversarial interaction framework as a practical paradigm that automates the continuous hardening of AI systems.", "AI": {"tldr": "Proposes RvB, a training-free adversarial framework where Red Team exposes vulnerabilities and Blue Team learns robust defenses, achieving high success rates in code hardening and jailbreak prevention with minimal false positives.", "motivation": "Address the lack of unified frameworks for dynamic, iterative adversarial adaptation hardening in AI security, given the dual offensive and defensive potential of LLMs.", "method": "Red Team vs. Blue Team (RvB) framework formulated as a training-free, sequential, imperfect-information game; Red Team identifies vulnerabilities, Blue Team develops defenses without parameter updates.", "result": "RvB achieves 90% and 45% Defense Success Rates in dynamic code hardening and guardrail optimization, respectively, with near 0% False Positive Rates, outperforming baselines.", "conclusion": "The RvB framework establishes iterative adversarial interaction as a practical paradigm for automating continuous AI system hardening, demonstrating superior defensive performance with minimal false positives."}}
{"id": "2601.19383", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.19383", "abs": "https://arxiv.org/abs/2601.19383", "authors": ["Thomas Borsani", "Andrea Rosani", "Giuseppe Di Fatta"], "title": "High-quality data augmentation for code comment classification", "comment": "Accepted at the NLBSE Workshop (co-located with ICSE)", "summary": "Code comments serve a crucial role in software development for documenting functionality, clarifying design choices, and assisting with issue tracking. They capture developers' insights about the surrounding source code, serving as an essential resource for both human comprehension and automated analysis. Nevertheless, since comments are in natural language, they present challenges for machine-based code understanding. To address this, recent studies have applied natural language processing (NLP) and deep learning techniques to classify comments according to developers' intentions. However, existing datasets for this task suffer from size limitations and class imbalance, as they rely on manual annotations and may not accurately represent the distribution of comments in real-world codebases. To overcome this issue, we introduce new synthetic oversampling and augmentation techniques based on high-quality data generation to enhance the NLBSE'26 challenge datasets. Our Synthetic Quality Oversampling Technique and Augmentation Technique (Q-SYNTH) yield promising results, improving the base classifier by $2.56\\%$.", "AI": {"tldr": "This paper proposes Q-SYNTH, a synthetic data augmentation technique to address class imbalance and small dataset size in classifying developer intentions in code comments, resulting in a 2.56% improvement in classification accuracy.", "motivation": "Existing datasets for classifying developer intentions in code comments suffer from limited size and class imbalance due to manual annotation, which hinders model performance and generalization in real-world scenarios.", "method": "The paper introduces a synthetic oversampling and augmentation method called Q-SYNTH, which generates high-quality synthetic data to address class imbalance and dataset size limitations in developer intention classification for code comments.", "result": "Q-SYNTH improves the base classifier performance by 2.56%, demonstrating the effectiveness of synthetic data generation in enhancing dataset quality for comment classification tasks.", "conclusion": "The proposed Q-SYNTH technique effectively enhances the quality and balance of datasets for comment classification, leading to improved classifier performance, demonstrating its potential for advancing intention detection in code comments."}}
{"id": "2601.19837", "categories": ["cs.CR", "cs.CY", "cs.DC", "cs.ET"], "pdf": "https://arxiv.org/pdf/2601.19837", "abs": "https://arxiv.org/abs/2601.19837", "authors": ["Nacereddine Sitouah", "Marco Esposito", "Francesco Bruschi"], "title": "Self-Sovereign Identity and eIDAS 2.0: An Analysis of Control, Privacy, and Legal Implications", "comment": null, "summary": "European digital identity initiatives are grounded in regulatory frameworks designed to ensure interoperability and robust, harmonized security standards. The evolution of these frameworks culminates in eIDAS 2.0, whose origins trace back to the Electronic Signatures Directive 1999/93/EC, the first EU-wide legal foundation for the use of electronic signatures in cross-border electronic transactions. As technological capabilities advanced, the initial eIDAS 1.0 framework was increasingly criticized for its limitations and lack of comprehensiveness. Emerging decentralized approaches further exposed these shortcomings and introduced the possibility of integrating innovative identity paradigms, such as Self-Sovereign Identity (SSI) models.\n  In this article, we analyse key provisions of the eIDAS 2.0 Regulation and its accompanying recitals, drawing on existing literature to identify legislative gaps and implementation challenges. Furthermore, we examine the European Digital Identity Architecture and Reference Framework (ARF), assessing its proposed guidelines and evaluating the extent to which its emerging implementations align with SSI principles.", "AI": {"tldr": "This paper analyzes the eIDAS 2.0 Regulation and the European Digital Identity Architecture and Reference Framework (ARF), identifying gaps in their alignment with Self-Sovereign Identity (SSI) principles and highlighting challenges in achieving a truly decentralized and user-controlled digital identity system in the EU.", "motivation": "The motivation stems from the need to modernize outdated digital identity frameworks (e.g., eIDAS 1.0) in light of rapid technological advancements and the emergence of decentralized identity models like Self-Sovereign Identity (SSI). The authors aim to evaluate whether the updated eIDAS 2.0 framework and ARF adequately address previous limitations and support innovative, user-centric identity solutions.", "method": "The authors conduct a qualitative analysis of the eIDAS 2.0 Regulation and its recitals, complemented by a review of relevant academic and policy literature. They critically assess the European Digital Identity Architecture and Reference Framework (ARF) against established SSI principles using a comparative and interpretive methodology.", "result": "The analysis reveals several legislative gaps and implementation challenges in eIDAS 2.0, particularly regarding decentralization, user control, and privacy. The ARF provides useful technical guidelines but falls short of fully incorporating SSI principles such as verifiable credentials, cryptographic self-management, and network neutrality.", "conclusion": "The paper concludes that while eIDAS 2.0 and the ARF represent significant progress in shaping a robust European digital identity framework, full alignment with Self-Sovereign Identity (SSI) principles remains limited. Legislative gaps and implementation inconsistencies hinder the realization of a truly decentralized and user-centric identity system."}}
{"id": "2601.19387", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2601.19387", "abs": "https://arxiv.org/abs/2601.19387", "authors": ["Lekshmi Murali Rani", "Richard Berntsson Svensson", "Robert Feldt"], "title": "Bridging the Socio-Emotional Gap: The Functional Dimension of Human-AI Collaboration for Software Engineering", "comment": "This is the authors accepted manuscript. The final version appears in ACM CHASE 2026", "summary": "As GenAI models are adopted to support software engineers and their development teams, understanding effective human-AI collaboration (HAIC) is increasingly important. Socio-emotional intelligence (SEI) enhances collaboration among human teammates, but its role in HAIC remains unclear. Current AI systems lack SEI capabilities that humans bring to teamwork, creating a potential gap in collaborative dynamics. In this study, we investigate how software practitioners perceive the socio-emotional gap in HAIC and what capabilities AI systems require for effective collaboration. Through semi-structured interviews with 10 practitioners, we examine how they think about collaborating with human versus AI teammates, focusing on their SEI expectations and the AI capabilities they envision. Results indicate that practitioners currently view AI models as intellectual teammates rather than social partners and expect fewer SEI attributes from them than from human teammates. However, they see the socio-emotional gap not as AIs failure to exhibit SEI traits, but as a functional gap in collaborative capabilities (AIs inability to negotiate responsibilities, adapt contextually, or maintain sustained partnerships). We introduce the concept of functional equivalents: technical capabilities (internal cognition, contextual intelligence, adaptive learning, and collaborative intelligence) that achieve collaborative outcomes comparable to human SEI attributes. Our findings suggest that effective collaboration with AI for SE tasks may benefit from functional design rather than replicating human SEI traits for SE tasks, thereby redefining collaboration as functional alignment.", "AI": {"tldr": "Software engineers view AI as lacking socio-emotional intelligence (SEI) not as a flaw, but as a functional gap in collaboration. Instead of mimicking human SEI, AI can achieve effective teamwork through 'functional equivalents'\u2014technical capabilities that enable adaptive, context-aware, and sustained collaboration.", "motivation": "As GenAI is increasingly integrated into software development, understanding how to support effective human-AI collaboration is critical. Since human teamwork relies on socio-emotional intelligence (SEI), this study investigates the role of SEI in human-AI collaboration and addresses the socio-emotional gap created by AI's current lack of such capabilities.", "method": "Semi-structured interviews with 10 software practitioners were conducted to explore perceptions of socio-emotional intelligence (SEI) in human-AI collaboration, comparing expectations of human versus AI teammates and identifying desired AI capabilities.", "result": "Practitioners perceive AI as an intellectual teammate rather than a social partner and expect less socio-emotional intelligence from AI. However, they identify a functional collaboration gap\u2014AI's inability to negotiate responsibilities, adapt contextually, or sustain partnerships. They envision AI capabilities like internal cognition, contextual intelligence, adaptive learning, and collaborative intelligence as functional equivalents to human SEI that could bridge this gap.", "conclusion": "Effective human-AI collaboration in software engineering may be better achieved through functional alignment\u2014designing AI with technical capabilities that serve as functional equivalents to human socio-emotional intelligence\u2014rather than attempting to replicate human-like socio-emotional traits."}}
{"id": "2601.19494", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.19494", "abs": "https://arxiv.org/abs/2601.19494", "authors": ["Lei Zhang", "Yongda Yu", "Minghui Yu", "Xinxin Guo", "Zhengqi Zhuang", "Guoping Rong", "Dong Shao", "Haifeng Shen", "Hongyu Kuang", "Zhengfeng Li", "Boge Wang", "Guoan Zhang", "Bangyu Xiang", "Xiaobing Xu"], "title": "AACR-Bench: Evaluating Automatic Code Review with Holistic Repository-Level Context", "comment": null, "summary": "High-quality evaluation benchmarks are pivotal for deploying Large Language Models (LLMs) in Automated Code Review (ACR). However, existing benchmarks suffer from two critical limitations: first, the lack of multi-language support in repository-level contexts, which restricts the generalizability of evaluation results; second, the reliance on noisy, incomplete ground truth derived from raw Pull Request (PR) comments, which constrains the scope of issue detection. To address these challenges, we introduce AACR-Bench a comprehensive benchmark that provides full cross-file context across multiple programming languages. Unlike traditional datasets, AACR-Bench employs an \"AI-assisted, Expert-verified\" annotation pipeline to uncover latent defects often overlooked in original PRs, resulting in a 285\\% increase in defect coverage. Extensive evaluations of mainstream LLMs on AACR-Bench reveal that previous assessments may have either misjudged or only partially captured model capabilities due to data limitations. Our work establishes a more rigorous standard for ACR evaluation and offers new insights on LLM based ACR, i.e., the granularity/level of context and the choice of retrieval methods significantly impact ACR performance, and this influence varies depending on the LLM, programming language, and the LLM usage paradigm e.g., whether an Agent architecture is employed. The code, data, and other artifacts of our evaluation set are available at https://github.com/alibaba/aacr-bench .", "code_url": "https://github.com/alibaba/aacr-bench", "code_stars": 12, "code_last_update": "2026-01-20", "AI": {"tldr": "AACR-Bench is a new, comprehensive benchmark for Automated Code Review (ACR) that supports multiple programming languages and provides full cross-file context. It uses an AI-assisted, expert-verified annotation pipeline to significantly improve defect detection coverage over existing benchmarks, revealing limitations in prior LLM evaluations and offering insights into how context and retrieval methods affect ACR performance.", "motivation": "Existing ACR benchmarks lack multi-language support and rely on noisy, incomplete ground truth from raw PR comments, limiting evaluation reliability and generalizability. This hampers accurate assessment of LLMs in real-world, repository-level code review scenarios.", "method": "AACR-Bench introduces a multi-language, repository-level dataset with full cross-file context. It employs an 'AI-assisted, Expert-verified' annotation pipeline to identify latent defects missed in original PRs, ensuring high-quality, comprehensive ground truth. The benchmark evaluates mainstream LLMs under various settings, including different context granularities, retrieval methods, and LLM usage paradigms (e.g., Agent vs. non-Agent architectures).", "result": "AACR-Bench achieves a 285% increase in defect coverage compared to traditional datasets based on raw PR comments. Evaluation of mainstream LLMs shows that prior assessments may have misrepresented model capabilities due to data limitations. Performance varies significantly based on context granularity, retrieval method, programming language, and whether an Agent-style architecture is used.", "conclusion": "AACR-Bench sets a more rigorous standard for evaluating LLMs in ACR by providing higher-quality annotations and broader contextual support. It highlights the importance of context and retrieval strategies in ACR and enables more accurate and nuanced evaluation of LLMs across languages and architectural paradigms."}}
{"id": "2601.19548", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19548", "abs": "https://arxiv.org/abs/2601.19548", "authors": ["Jan Keim", "Angelika Kaplan"], "title": "From Scattered to Structured: A Vision for Automating Architectural Knowledge Management", "comment": "Accepted at the IEEE/ACM International Conference on Software Engineering (ICSE) Software Architecture Birds-of-a-Feather Session", "summary": "Software architecture is inherently knowledge-centric. The architectural knowledge is distributed across heterogeneous software artifacts such as requirements documents, design diagrams, code, and documentation, making it difficult for developers to access and utilize this knowledge effectively. Moreover, as systems evolve, inconsistencies frequently emerge between these artifacts, leading to architectural erosion and impeding maintenance activities. We envision an automated pipeline that systematically extracts architectural knowledge from diverse artifacts, links them, identifies and resolves inconsistencies, and consolidates this knowledge into a structured knowledge base. This knowledge base enables critical activities such as architecture conformance checking and change impact analysis, while supporting natural language question-answering to improve access to architectural knowledge. To realize this vision, we plan to develop specialized extractors for different artifact types, design a unified knowledge representation schema, implement consistency checking mechanisms, and integrate retrieval-augmented generation techniques for conversational knowledge access.", "AI": {"tldr": "We propose an automated pipeline to extract, integrate, and manage architectural knowledge from heterogeneous software artifacts into a unified knowledge base, enabling consistency maintenance, conformance checking, and natural language-based querying.", "motivation": "Architectural knowledge is scattered across diverse artifacts (e.g., requirements, design, code), leading to inconsistencies, erosion, and poor knowledge accessibility during system evolution and maintenance.", "method": "Develop specialized extractors for various artifact types, design a unified knowledge representation schema, implement mechanisms for linking and resolving inconsistencies, and integrate retrieval-augmented generation (RAG) for natural language question-answering over the knowledge base.", "result": "A structured knowledge base that consolidates architectural knowledge, supports consistency checking, change impact analysis, architecture conformance verification, and enables intuitive access via natural language queries.", "conclusion": "The proposed pipeline enhances architectural knowledge management by automating integration and inconsistency resolution, thereby reducing erosion and improving maintainability and developer productivity."}}
{"id": "2601.19583", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19583", "abs": "https://arxiv.org/abs/2601.19583", "authors": ["D\u00e9bora Souza", "Patr\u00edcia Machado"], "title": "Toward Architecture-Aware Evaluation Metrics for LLM Agents", "comment": "Accepted at CAIN 2026 (IEEE/ACM 5th International Conference on AI Engineering)", "summary": "LLM-based agents are becoming central to software engineering tasks, yet evaluating them remains fragmented and largely model-centric. Existing studies overlook how architectural components, such as planners, memory, and tool routers, shape agent behavior, limiting diagnostic power. We propose a lightweight, architecture-informed approach that links agent components to their observable behaviors and to the metrics capable of evaluating them. Our method clarifies what to measure and why, and we illustrate its application through real world agents, enabling more targeted, transparent, and actionable evaluation of LLM-based agents.", "AI": {"tldr": "This paper proposes an architecture-aware evaluation framework for LLM-based software engineering agents that connects architectural components to behaviors and metrics, enhancing evaluation transparency and actionability.", "motivation": "Existing evaluation methods for LLM-based agents in software engineering are fragmented and model-centric, failing to account for the impact of architectural components on agent behavior, which limits diagnostic effectiveness.", "method": "A lightweight, architecture-informed method is introduced that maps agent components (e.g., planners, memory, tool routers) to observable behaviors and corresponding evaluation metrics, demonstrated through real-world agent applications.", "result": "The method provides clarity on what behavioral aspects to evaluate and why, enabling improved diagnostic precision and interpretability in assessing LLM-based agents through component-behavior-metric alignment.", "conclusion": "The proposed architecture-informed evaluation approach enables more targeted, transparent, and actionable assessment of LLM-based agents in software engineering by linking their structural components to observable behaviors and appropriate metrics."}}
{"id": "2601.19628", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19628", "abs": "https://arxiv.org/abs/2601.19628", "authors": ["Mairieli Wessel", "Daniel Feitosa", "Sangeeth Kochanthara"], "title": "The Competence Crisis: A Design Fiction on AI-Assisted Research in Software Engineering", "comment": null, "summary": "Rising publication pressure and the routine use of generative AI tools are reshaping how software engineering research is produced, assessed, and taught. While these developments promise efficiency, they also raise concerns about skill degradation, responsibility, and trust in scholarly outputs. This vision paper employs Design Fiction as a methodological lens to examine how such concerns might materialise if current practices persist. Drawing on themes reported in a recent community survey, we construct a speculative artifact situated in a near future research setting. The fiction is used as an analytical device rather than a forecast, enabling reflection on how automated assistance might impede domain knowledge competence, verification, and mentoring practices. By presenting an intentionally unsettling scenario, the paper invites discussion on how the software engineering research community in the future will define proficiency, allocate responsibility, and support learning.", "AI": {"tldr": "Using Design Fiction, this paper explores the potential negative impacts of generative AI on software engineering research culture, highlighting risks to expertise, accountability, and training, and urges the community to rethink research norms.", "motivation": "Growing publication pressure and widespread use of generative AI in software engineering research raise concerns about eroding skills, accountability, and trust, prompting the need to critically examine long-term implications.", "method": "Design Fiction is used as a methodological lens to create a speculative, near-future artifact based on themes from a community survey, serving as an analytical tool to explore potential consequences of AI integration.", "result": "A speculative fiction scenario illustrates how unchecked AI use could impair domain competence, verification processes, and mentorship in research, prompting critical reflection rather than predicting outcomes.", "conclusion": "The paper calls for proactive community reflection on how proficiency, responsibility, and learning in software engineering research should be defined and upheld as generative AI becomes more embedded in academic practices."}}
{"id": "2601.19636", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19636", "abs": "https://arxiv.org/abs/2601.19636", "authors": ["Pien Rooijendijk", "Christoph Treude", "Mairieli Wessel"], "title": "Who Said CVE? How Vulnerability Identifiers Are Mentioned by Humans, Bots, and Agents in Pull Requests", "comment": null, "summary": "Vulnerability identifiers such as CVE, CWE, and GHSA are standardised references to known software security issues, yet their use in practice is not well understood. This paper compares vulnerability ID use in GitHub pull requests authored by autonomous agents, bots, and human developers. Using the AIDev pop dataset and an augmented set of pull requests from the same repositories, we analyse who mentions vulnerability identifiers and where they appear. Bots account for around 69.1% of all mentions, usually adding few identifiers in pull request descriptions, while human and agent mentions are rarer but span more locations. Qualitative analysis shows that bots mainly reference identifiers in automated dependency updates and audits, whereas humans and agents use them to support fixes, maintenance, and discussion.", "AI": {"tldr": "This study analyzes how bots, humans, and agents use vulnerability identifiers like CVE and GHSA in GitHub pull requests, finding that bots dominate mentions through automation, while humans and agents apply them more contextually in security-related discussions and maintenance.", "motivation": "To understand how different contributors\u2014bots, humans, and autonomous agents\u2014use standardized vulnerability identifiers in real-world software development, particularly within GitHub pull requests.", "method": "Analysis of vulnerability ID usage in GitHub pull requests using the AIDev pop dataset and an extended dataset, comparing mentions by bots, humans, and autonomous agents in terms of frequency, location, and context.", "result": "Bots generate approximately 69.1% of all vulnerability ID mentions, mainly in pull request descriptions during automated dependency updates; human and agent mentions are less frequent but occur across more diverse locations and are used to support security discussions and fixes.", "conclusion": "Bots are the primary contributors to vulnerability identifier mentions in GitHub pull requests, primarily in automated contexts, while humans and autonomous agents use them more diversely for communication and coordination around security fixes."}}
{"id": "2601.19693", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19693", "abs": "https://arxiv.org/abs/2601.19693", "authors": ["Frank Elberzhager", "Matthias Gerbershagen", "Joshua Ginkel"], "title": "Using LLMs to Evaluate Architecture Documents: Results from a Digital Marketplace Environment", "comment": null, "summary": "Generative AI plays an increasing role during software engineering activities to make them, e.g., more efficient or provide better quality. However, it is often unclear how much benefit LLMs really provide. We concentrate on software architects and investigated how an LLM-supported evaluation of architecture documents can support software architects to improve such artefacts. In the context of a research project where a digital marketplace is developed and digital solutions should be analyzed, we used different LLMs to analyze the quality of architecture documents and compared the results with evaluations from software architects. We found out that the quality of the artifact has a strong influence on the quality of the LLM, i.e., the better the quality of the architecture document was, the more consistent were the LLM-based evaluation and the human expert evaluation. While using LLMs in this architecture task is promising, our results showed inconsistencies that need further analyses before generalizing them.", "AI": {"tldr": "LLMs show promise in evaluating software architecture documents, but their effectiveness depends on document quality and results show inconsistencies requiring further study.", "motivation": "To assess the real benefit of LLMs in software engineering, specifically how well they support software architects in evaluating architecture documents compared to human experts.", "method": "Different LLMs were used to analyze architecture documents within a digital marketplace research project; LLM evaluations were compared with assessments from human software architects.", "result": "LLM evaluation quality strongly depends on the input document quality; higher-quality documents lead to more consistent alignment between LLM and human expert evaluations. However, notable inconsistencies were observed.", "conclusion": "LLM-based evaluation of architecture documents is promising but not yet reliable; further analysis is needed before generalizing findings or deploying in practice."}}
{"id": "2601.19697", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.19697", "abs": "https://arxiv.org/abs/2601.19697", "authors": ["Tianyue Jiang", "Yanli Wang", "Yanlin Wang", "Daya Guo", "Ensheng Shi", "Yuchi Ma", "Jiachi Chen", "Zibin Zheng"], "title": "AlignCoder: Aligning Retrieval with Target Intent for Repository-Level Code Completion", "comment": "To appear at ASE'25", "summary": "Repository-level code completion remains a challenging task for existing code large language models (code LLMs) due to their limited understanding of repository-specific context and domain knowledge. While retrieval-augmented generation (RAG) approaches have shown promise by retrieving relevant code snippets as cross-file context, they suffer from two fundamental problems: misalignment between the query and the target code in the retrieval process, and the inability of existing retrieval methods to effectively utilize the inference information. To address these challenges, we propose AlignCoder, a repository-level code completion framework that introduces a query enhancement mechanism and a reinforcement learning based retriever training method. Our approach generates multiple candidate completions to construct an enhanced query that bridges the semantic gap between the initial query and the target code. Additionally, we employ reinforcement learning to train an AlignRetriever that learns to leverage inference information in the enhanced query for more accurate retrieval. We evaluate AlignCoder on two widely-used benchmarks (CrossCodeEval and RepoEval) across five backbone code LLMs, demonstrating an 18.1% improvement in EM score compared to baselines on the CrossCodeEval benchmark. The results show that our framework achieves superior performance and exhibits high generalizability across various code LLMs and programming languages.", "AI": {"tldr": "AlignCoder enhances repository-level code completion via query enhancement and reinforcement learning-based retriever training, effectively bridging semantic gaps and leveraging inference signals, resulting in significant performance gains and broad applicability.", "motivation": "Existing code LLMs struggle with repository-level code completion due to limited understanding of repository-specific context; retrieval-augmented generation methods face issues of query-target misalignment and poor use of inference information during retrieval.", "method": "The authors propose AlignCoder, which introduces a query enhancement mechanism that generates multiple candidate completions to create a semantically richer query, and employs reinforcement learning to train an AlignRetriever that effectively leverages inference information for improved code retrieval.", "result": "AlignCoder achieves an 18.1% improvement in EM score over baselines on the CrossCodeEval benchmark across five backbone code LLMs and performs well on RepoEval, showing strong generalization across models and programming languages.", "conclusion": "AlignCoder achieves superior performance in repository-level code completion by addressing query-target misalignment and ineffective inference utilization through query enhancement and reinforcement learning-based retriever training, demonstrating high generalizability across code LLMs and programming languages."}}
{"id": "2601.19731", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19731", "abs": "https://arxiv.org/abs/2601.19731", "authors": ["Massimiliano Di Penta", "Kelly Blincoe", "Marsha Chechik", "Claire Le Goues", "David Lo", "Emerson Murphy-Hill", "Thomas Zimmermann"], "title": "Future of Software Engineering Research: The SIGSOFT Perspective", "comment": null, "summary": "As software engineering conferences grow in size, rising costs and outdated formats are creating barriers to participation for many researchers. These barriers threaten the inclusivity and global diversity that have contributed to the success of the SE community. Based on survey data, we identify concrete actions the ACM Special Interest Group on Software Engineering (SIGSOFT) can take to address these challenges, including improving transparency around conference funding, experimenting with hybrid poster presentations, and expanding outreach to underrepresented regions. By implementing these changes, SIGSOFT can help ensure the software engineering community remains accessible and welcoming.", "AI": {"tldr": "Software engineering conferences face inclusivity challenges due to rising costs and outdated formats; actionable solutions include greater financial transparency, hybrid poster sessions, and expanded outreach to underrepresented regions.", "motivation": "Growing conference sizes and costs are creating barriers to participation, threatening the inclusivity and global diversity essential to the SE community's success.", "method": "Survey data was analyzed to identify key challenges and potential interventions that ACM SIGSOFT can implement to improve accessibility and inclusivity.", "result": "Findings suggest that improving financial transparency, adopting hybrid poster presentations, and increasing outreach to underrepresented regions are effective strategies for enhancing participation.", "conclusion": "Implementing these measures can help SIGSOFT maintain an accessible, diverse, and welcoming software engineering community."}}
{"id": "2601.19787", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.19787", "abs": "https://arxiv.org/abs/2601.19787", "authors": ["Elena Masserini", "Diego Clerissi", "Daniela Micucci", "Leonardo Mariani"], "title": "Assessing Task-based Chatbots: Snapshot and Curated Datasets for Dialogflow", "comment": "4 pages, 5 figures, Accepted at International Conference on Mining Software Repositories (MSR) 2026", "summary": "In recent years, chatbots have gained widespread adoption thanks to their ability to assist users at any time and across diverse domains. However, the lack of large-scale curated datasets limits research on their quality and reliability. This paper presents TOFU-D, a snapshot of 1,788 Dialogflow chatbots from GitHub, and COD, a curated subset of TOFU-D including 185 validated chatbots. The two datasets capture a wide range of domains, languages, and implementation patterns, offering a sound basis for empirical studies on chatbot quality and security. A preliminary assessment using the Botium testing framework and the Bandit static analyzer revealed gaps in test coverage and frequent security vulnerabilities in several chatbots, highlighting the need for systematic, multi-Platform research on chatbot quality and security.", "AI": {"tldr": "TOFU-D and COD are datasets of Dialogflow chatbots from GitHub, enabling empirical research on chatbot quality and security; preliminary analysis reveals poor test coverage and common security issues.", "motivation": "The lack of large-scale, curated datasets hinders research on chatbot quality and reliability; existing tools and analyses are limited by data availability.", "method": "The authors collected 1,788 chatbots (TOFU-D) from GitHub, curated a subset of 185 validated ones (COD), and analyzed them using Botium for test coverage and Bandit for security vulnerabilities.", "result": "The datasets span multiple domains and languages; evaluation showed many chatbots have insufficient test coverage and contain security vulnerabilities such as hardcoded secrets and insecure code patterns.", "conclusion": "TOFU-D and COD provide a foundation for systematic, multi-platform research on chatbot quality and security, revealing critical gaps that require further investigation and tooling improvement."}}
